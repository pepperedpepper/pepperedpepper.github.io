<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>OS on peppered pepper</title>
        <link>https://pepperedpepper.github.io/tags/os/</link>
        <description>Recent content in OS on peppered pepper</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Wed, 27 Jul 2022 01:00:00 +0900</lastBuildDate><atom:link href="https://pepperedpepper.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[OS] Chapter 12. 디스크 관리</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-12/</link>
        <pubDate>Wed, 27 Jul 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-12/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;디스크의-구조&#34;&gt;디스크의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/12-01-disk.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;디스크의 구조&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;논리블록(logical block)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스크의 &lt;strong&gt;단위 정보 저장 공간&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;1차원 배열처럼 취급한다.&lt;/li&gt;
&lt;li&gt;논리블록 단위로 저장, 전송된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;섹터(sector)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스크 내에서 &lt;strong&gt;논리블록이 저장되는 물리적인 위치&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;섹터가 0이면 최외곽 실린더의 첫 번째 트랙에 있는 첫 번째 섹터이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;디스크-관리&#34;&gt;디스크 관리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;physical-formatting (low-level formatting)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스크를 컨트롤러가 읽고 쓸수 있도록 섹터들로 나누는 과정이다.&lt;/li&gt;
&lt;li&gt;각 섹터는 &lt;code&gt;header&lt;/code&gt; + &lt;code&gt;실제 data&lt;/code&gt;(보통 512bytes) + &lt;code&gt;trailer&lt;/code&gt;로 구성된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt;와 &lt;code&gt;trailer&lt;/code&gt;는 sector number, ECC(error-collecting code)등의 정보가 저장되며, 컨트롤러가 직접 접근 및 운영한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(2) &lt;strong&gt;partitioning&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스크를 하나 이상의 실린더 그룹으로 나누는 과정이다.&lt;/li&gt;
&lt;li&gt;운영체제는 이것을 독립적인 디스크(logical disk)로 취급한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(3) &lt;strong&gt;logical-formatting&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일시스템을 만드는 것이다.&lt;/li&gt;
&lt;li&gt;FAT, inode, free space 등의 구조가 포함된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(4) &lt;strong&gt;booting&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;ROM에 저장되어 있는 small bootstrap loader를 실행하는 것이다.&lt;/li&gt;
&lt;li&gt;실행하면, full bootstrap loader program이 있는 섹터 0을 로드해서 실행한다.&lt;/li&gt;
&lt;li&gt;그러면, 운영체제의 커널을 찾아서 그것을 로드해서 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;디스크-스케줄링&#34;&gt;디스크 스케줄링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;디스크 접근 시간(access time)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;탐색시간(seek time)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;헤드를 해당 실린더로 움직이는데 걸리는 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;회전지연시간(rotational latency)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;전송시간(transfer time)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;해당 섹터가 헤드에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;회전지연시간, 전송시간은 상대적인 수치가 작을 뿐 아니라 운영체제가 통제하기 힘든 부분이다.
&lt;ul&gt;
&lt;li&gt;따라서 운영체제는 탐색시간을 줄이기 위해 &lt;strong&gt;헤드의 움직임을 최소화하는 스케줄링 작업&lt;/strong&gt;을 한다.&lt;/li&gt;
&lt;li&gt;그렇다면 &lt;strong&gt;여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떤 순서로 처리할 것인가?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;1-fcfsfirst-come-first-served-스케줄링&#34;&gt;(1) FCFS(First Come First Served) 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;디스크에 &lt;strong&gt;먼저 들어온 요청&lt;/strong&gt;을 먼저 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;2-sstfshortest-seek-time-first-스케줄링&#34;&gt;(2) SSTF(Shortest Seek Time First) 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;헤드의 현재 위치로부터 &lt;strong&gt;가장 가까운 위치&lt;/strong&gt;에 있는 요청을 먼저 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기아 현상(starvation)&lt;/strong&gt; 을 발생시킬 수 있다.
&lt;ul&gt;
&lt;li&gt;헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;3-scan-알고리즘&#34;&gt;(3) SCAN 알고리즘&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;헤드가 &lt;strong&gt;정해진 방향으로 이동&lt;/strong&gt;하면서 길목에 있는 요청들을 처리하며 지나간다.&lt;/li&gt;
&lt;li&gt;엘리베이터 스케줄링 알고리즘(elevator scheduling algorithm)이라고도 부른다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;탐색시간의 편차&lt;/strong&gt;가 있다.
&lt;ul&gt;
&lt;li&gt;제일 안쪽, 바깥쪽에 비해서 가운데 위치가 기다리는 평균시간이 더 짧다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;4-c-scancircular-scan-알고리즘&#34;&gt;(4) C-SCAN(Circular-SCAN) 알고리즘&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;헤드가 &lt;strong&gt;정해진 방향으로 이동&lt;/strong&gt;하면서 길목에 있는 요청들을 처리하는 것은 SCAN과 똑같지만, 끝에 도달하면 요청을 처리하지 않고 출발점으로 이동만 하는 방식이다.&lt;/li&gt;
&lt;li&gt;이동거리는 길어지지만, 탐색시간의 편차를 줄이기 위함이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;5-look과-c-look-알고리즘&#34;&gt;(5) LOOK과 C-LOOK 알고리즘&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;헤드가 한쪽 방향으로 이동하다가, 더 이상 &lt;strong&gt;그 방향에 대기 중인 요청이 없으면 헤드 진행 방향을 바꾸는&lt;/strong&gt; 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;다중-디스크-환경에서의-스케줄링&#34;&gt;다중 디스크 환경에서의 스케줄링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;다중 디스크 환경에서의 스케줄링은 그 목표에 따라 결정이 달라진다.
&lt;ul&gt;
&lt;li&gt;탐색시간 줄이기
&lt;ul&gt;
&lt;li&gt;헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크를 선택한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;디스크 간의 부하균형(load balancing)
&lt;ul&gt;
&lt;li&gt;모든 디스크에 요청이 골고루 분배되도록 스케줄링한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;전력소모 줄이기
&lt;ul&gt;
&lt;li&gt;일부 디스크에 요청을 집중시키고 나머지 디스크는 회전을 정지시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;스왑-영역-관리&#34;&gt;스왑 영역 관리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;디스크를 사용하는 두 가지 이유
&lt;ul&gt;
&lt;li&gt;(1) 메모리의 휘발성 → &lt;strong&gt;파일 시스템&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(2) 메모리의 공간 부족 → &lt;strong&gt;스왑 영역&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/12-02-swapArea.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;파일 시스템과 스왑 영역&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스왑 영역&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;가상 메모리 시스템에서 디스크를 메모리의 연장 공간으로 사용한다.&lt;/li&gt;
&lt;li&gt;파일 시스템과 별도의 파티션을 사용하는 것이 일반적이다.
&lt;ul&gt;
&lt;li&gt;일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조되므로, 공간 효율성보다는 속도 효율성이 우선시 된다.&lt;/li&gt;
&lt;li&gt;따라서, &lt;strong&gt;블록의 크기 및 저장 방식이 일반 파일 시스템과 다르다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;raid&#34;&gt;RAID&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RAID(Redundant Array of Independent Disks)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;디스크 여러개를 묶어서 함께 사용&lt;/strong&gt;하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;RAID의 사용 목적
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;디스크 처리 속도 향상&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;여러 디스크에 블록의 내용을 &lt;strong&gt;분산 저장&lt;/strong&gt;한다. 그리고 병렬적으로 읽는다. (interleaving, striping)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신뢰성(reliability) 향상&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;동일한 정보를 디스크에 &lt;strong&gt;중복 저장&lt;/strong&gt;한다. 하나의 디스크가 고장나도 다른 디스크에서 읽어올 수 있다. (mirroring, shadowing)&lt;/li&gt;
&lt;li&gt;단순한 중복 저장이 아니라, 일부 디스크에 parity를 저장해서 공간 효율성을 높일 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 11. 파일 시스템</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-11/</link>
        <pubDate>Wed, 20 Jul 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-11/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;파일과-파일-시스템&#34;&gt;파일과 파일 시스템&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;File&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A named collection of related information&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;일반적으로 비휘발성의 보조기억장치에 저장된다.&lt;/li&gt;
&lt;li&gt;운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 관리한다.&lt;/li&gt;
&lt;li&gt;Operation
&lt;ul&gt;
&lt;li&gt;create, read, write, reposition(lseek), delete, open, close 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;File attribute&lt;/strong&gt; (혹은 파일의 metadata)
&lt;ul&gt;
&lt;li&gt;파일 자체의 내용이 아니라 파일을 관리하기 위한 &lt;strong&gt;각종 정보들&lt;/strong&gt;이다.
&lt;ul&gt;
&lt;li&gt;파일 이름, 유형, 저장된 위치, 파일 사이즈&lt;/li&gt;
&lt;li&gt;접근 권한(읽기/쓰기/실행), 시간(생성/변경/사용), 소유자 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;File system&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;운영체제에서 &lt;strong&gt;파일을 관리하는 부분&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;파일, 파일의 메타데이터, 디렉터리 등의 정보를 관리한다.&lt;/li&gt;
&lt;li&gt;파일의 저장방법을 결정한다.&lt;/li&gt;
&lt;li&gt;파일을 보호한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Directory&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;해당 디렉터리에 &lt;strong&gt;속한 파일의 이름, 메타데이터 등의 정보를 가지는 파일&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일이다.&lt;/li&gt;
&lt;li&gt;Operation
&lt;ul&gt;
&lt;li&gt;search for a file, create a file, delete a file&lt;/li&gt;
&lt;li&gt;list a dictionary, rename a file, traverse the file system&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Partition(= Logical Disk)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;하나의 디스크 안에 여러개의 파티션을 둘 수도 있고, 여러개의 디스크를 하나의 파티션으로 둘 수도 있다.&lt;/li&gt;
&lt;li&gt;물리적인 디스크를 파티션으로 구성한 뒤에, 각각의 파티션에 파일 시스템을 깔거나 swapping 등의 다른 용도로 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open(a/b/c)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;디스크로부터 파일 c의 메타데이터를 메모리로 가지고 오기 위해서 디렉터리 경로를 search 한다.
&lt;ul&gt;
&lt;li&gt;루트 디렉터리 &lt;code&gt;/&lt;/code&gt;를 &lt;code&gt;open&lt;/code&gt;하고, 그 안에서 파일 &lt;code&gt;a&lt;/code&gt;의 위치 획득&lt;/li&gt;
&lt;li&gt;파일 &lt;code&gt;a&lt;/code&gt;를 &lt;code&gt;read&lt;/code&gt;하고, 그 안에서 파일 &lt;code&gt;b&lt;/code&gt;의 위치 획득&lt;/li&gt;
&lt;li&gt;파일 &lt;code&gt;b&lt;/code&gt;를 &lt;code&gt;read&lt;/code&gt;하고, 그 안에서 파일 &lt;code&gt;c&lt;/code&gt;의 위치 획득&lt;/li&gt;
&lt;li&gt;파일 &lt;code&gt;c&lt;/code&gt;를 &lt;code&gt;open&lt;/code&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;디렉터리 search에 너무 많은 시간이 소요되기 때문에 &lt;code&gt;open&lt;/code&gt;을 &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;와 따로둔다.
&lt;ul&gt;
&lt;li&gt;그래서 한번 &lt;code&gt;open&lt;/code&gt;한 파일은 &lt;code&gt;read&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt;할 때 디렉터리 search가 불필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;파일-보호&#34;&gt;파일 보호&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 파일들에 대해 누구에게 어떤 유형의 접근(read/write/execution)을 허락할 것인가?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;접근 제어 방법&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Access control Matrix&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Access control list
&lt;ul&gt;
&lt;li&gt;파일별로 누구에게 어떤 접근 권한이 있는지 표시한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Capability
&lt;ul&gt;
&lt;li&gt;사용자별로 자신이 접근 권한을 가진 파일, 해당 권한을 표시한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grouping&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;전체 사용자를 owner, group, public으로 구분하고 각 파일에 대해 각각의 그룹에 대한 접근 권한(rwx)을 3비트씩 표시한다.&lt;/li&gt;
&lt;li&gt;UNIX 예시: &lt;code&gt;rwxr--r--&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Password&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일마다 password를 두는 방법이다.&lt;/li&gt;
&lt;li&gt;모든 접근 권한에 대해 하나의 password를 두기: all-or-nothing&lt;/li&gt;
&lt;li&gt;접근 권한별로 password를 두기: 암기 문제, 관리 문제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;파일-시스템-마운팅&#34;&gt;파일 시스템 마운팅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;File system Mounting&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;특정 파티션에 있는 파일 시스템의 특정 디텍터리에, 다른 파티션의 파일 시스템을 마운트하는 것이다.&lt;/li&gt;
&lt;li&gt;서로 다른 파일 시스템에 접근할 수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;파일-접근-방법&#34;&gt;파일 접근 방법&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;순차 접근(sequential access)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;카세프 테이프를 사용하는 것처럼 접근하는 방식이다.&lt;/li&gt;
&lt;li&gt;읽거나 쓰면, offset이 자동으로 증가한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; → &lt;code&gt;b&lt;/code&gt; → &lt;code&gt;c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;직접 접근, 임의 접근(direct access, random access)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;LP 레코드 판과 같이 접근하는 방식이다.&lt;/li&gt;
&lt;li&gt;파일을 구성하는 레코드를 임의의 순서로 접근할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; → &lt;code&gt;c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;디스크에-파일-정보를-저장하는-방법&#34;&gt;디스크에 파일 정보를 저장하는 방법&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/11-01-contiguousAllocation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;연속 할당&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;Contiguous Allocation&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스크의 연속적인 블럭에 파일을 저장하는 방법이다.&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;빠른 I/O가 가능하다. 한번의 디스크 seek/rotation으로 많은 바이트를 transfer할 수 있다.&lt;/li&gt;
&lt;li&gt;직접 접근(랜덤 접근)이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;비어있는 블럭이 있어도 연속되는 블럭이 충분치 않으면 저장할 수 없다. (외부 조각)&lt;/li&gt;
&lt;li&gt;파일의 크기를 늘리는데(File grow) 제약이 있다. 파일 생성 시에 얼마나 큰 hole을 할당할 것인가? grow 가능 vs 낭비(내부 조각)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/11-02-linkedAllocation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;연결 할당&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(2) &lt;strong&gt;Linked Allocation&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일을 불연속적으로 저장하고 pointer로 연결하는 방법이다.&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;외부조각이 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;직접 접근이 불가능하다.&lt;/li&gt;
&lt;li&gt;신뢰성(Reliability)문제. 하나의 섹터가 고장나면 연결된 다른 섹터에 접근할 수 없게된다.&lt;/li&gt;
&lt;li&gt;다음 위치를 가리키는 pointer의 저장공간이 필요하기 때문에 공간의 효율성이 떨어진다. 512bytes/sector, 4bytes/pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FAT(File-allocation table) 파일 시스템&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;pointer를 별도의 공간에 저장해서 신뢰성, 공간 효율성의 문제를 해결한 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/11-03-indexedAllocation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;인덱스 할당&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(3) &lt;strong&gt;Indexed Allocation&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;index를 가지고 있는 블럭을 두는 방법이다.&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;외부조각이 발생하지 않는다.&lt;/li&gt;
&lt;li&gt;직접접근이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;작은 크기의 파일이더라도 index를 저장하기 위한 블럭이 필요하므로 공간 낭비가 있다.&lt;/li&gt;
&lt;li&gt;너무 큰 크기의 파일은 여러개의 index 블럭이 필요하다. (해결방법: linked-scheme, multi-level index)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;실제로-사용되는-파일-시스템의-구조&#34;&gt;실제로 사용되는 파일 시스템의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/11-04-unixFileSystem.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;UNIX 파일 시스템&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UNIX 파일 시스템&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Boot block&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;부팅에 필요한 정보(bootstrap loader)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Super block&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일 시스템에 관한 총체적인 정보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inode list&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일 이름을 제외한 파일의 모든 &lt;strong&gt;메타데이터&lt;/strong&gt;를 저장&lt;/li&gt;
&lt;li&gt;(위에서 메타데이터는 파일의 디렉터리에 저장된다고 했지만 유닉스나 기타 실제 파일 시스템에서는 파일 이름만 디렉터리에 저장되고 나머지. 메타데이터들은 여기에 저장된다)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data block&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일의 실제 내용을 보관&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/11-05-fat.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;FAT 파일 시스템&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FAT 파일 시스템&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Data block의 개수 만큼 FAT 블럭이 존재하고, 내용에는 다음 블럭이 어딘지가 저장되어(pointer) 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;free-spcae-management&#34;&gt;Free-Spcae Management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;비어 있는 블럭들을 어떻게 관리할 것인가?
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(1) Bit map / Bit vector&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;블럭이 비어있는지 혹은 사용중인지를 &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;로 저장한다.&lt;/li&gt;
&lt;li&gt;따라서 부가적인 공간을 필요로 한다.&lt;/li&gt;
&lt;li&gt;연속적인 가용 공간을 찾기에 효과적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(2) Linked list&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;모든 비어있는 블럭들을 링크로 연결한다. (free list)&lt;/li&gt;
&lt;li&gt;공간의 낭비가 없다.&lt;/li&gt;
&lt;li&gt;연속적인 가용 공간을 찾기 쉽기 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(3) Grouping&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;linked list 방법의 변형이다. 첫 번째 빈 블럭이 n개의 pointer를 가지고, 또 다시 n-1번째의 빈 블럭이 n개의 pointer를 가진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(4) Counting&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로그램들이 종종 여러 개의 연속적인 블럭을 할당하고 반납한다는 성질에 착안해서, 빈 블럭의 첫 번째 위치와 거기서 부터 몇 개의 빈블럭이 연속되어 있는지를 쌍으로 저장한다.&lt;/li&gt;
&lt;li&gt;(first free block, # of contiguous free blocks)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;directory-implementation&#34;&gt;Directory Implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;디렉터리를 어떻게 구현할 것인가?
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(1) Linear list&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일의 이름과 메타데이터를 리스트로 저장한다. &amp;lt;file name, file metadata&amp;gt;&lt;/li&gt;
&lt;li&gt;구현이 간단하다.&lt;/li&gt;
&lt;li&gt;디렉터리 내에 파일이 있는지 찾기 위해서는 linear search가 필요하다. (time-consuming)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(2) Hash table&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;linear list에다가 hashing을 추가한 것이다.&lt;/li&gt;
&lt;li&gt;해시 함수를 적용해서 파일 이름을 파일의 위치로 바꾸어주고, 거기에 이름과 메타데이터를 저장한다.&lt;/li&gt;
&lt;li&gt;탐색시간을 없앴다.&lt;/li&gt;
&lt;li&gt;충돌 발생 가능성이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;파일의 메타데이터를 어디에 보관할 것인가?
&lt;ul&gt;
&lt;li&gt;(1) 디렉터리에 보관&lt;/li&gt;
&lt;li&gt;(2) 디렉터리에는 pointer를 두고, 다른 곳에 보관(inode, FAT 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;긴 파일명의 지원
&lt;ul&gt;
&lt;li&gt;파일 이름이 고정 크기의 entry의 길이 보다 길어지면, entry의 마지막 부분에 이름의 뒷부분이 위치한 포인터를 둔다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;vfs와-nfs&#34;&gt;VFS와 NFS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VFS(Virtual File System)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;서로 다른 다양한 파일 시스템에 대해 동일한 시스템 콜 인터페이스(API)를 통해 접근할 수 있게 해주는 운영체제의 layer이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NFS(Network File System)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;분산 시스템에서 네트워크를 통해 파일을 공유하는 대표적인 파일 공유 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;page-cache와-buffer-cache&#34;&gt;Page cache와 Buffer cache&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/11-06-cache.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;캐슁 기법&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Page cache&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;가상 메모리에서, swap area에 있는 페이지에 대한 접근을 빠르게 하기 위해 물리적인 메모리에 올린 프레임들이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buffer cache&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일 시스템에서, I/O 처리를 빠르게 하기 위해서 메모리에 올린 파일의 블럭이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memorey-mapped I/O&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;파일의 일부분을 메모리에 매핑을 시켜서, 이 영역에 대한 접근 연산은 I/O를 수행하게 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unified Buffer Cache&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;최근의 OS에서는 기존의 Buffer cache가 Page cache에 통합되었다. 그래서 파일의 블럭 단위가 아니라 페이지 단위로 캐싱된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 10. 가상 메모리</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-10/</link>
        <pubDate>Wed, 13 Jul 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-10/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;요구-페이징&#34;&gt;요구 페이징&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;운영체제는 CPU에서 당장 수행해야 할 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓았다가 다시 필요해지면 메모리에 올리가 있는 부분과 교체하는 방식을 사용한다.&lt;/li&gt;
&lt;li&gt;이렇게 하면, &lt;strong&gt;메모리의 연장 공간인 것처럼 디스크 스왑 영역을 사용&lt;/strong&gt;할 수 있게 된다. 그래서 프로그램은 물리적 메모리의 크기 제약을 신경쓰지 않아도 되므로 각자 독자적인 메모리 주소 공간을 가질 수 있게 된다.&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;프로세스마다 가지고 있는 0번지부터 시작하는 메모리 주소 공간&lt;/strong&gt;&lt;/mark&gt;을 &lt;strong&gt;가상 메모리(virtual memory)&lt;/strong&gt; 라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;프로세스의 이런 주소 공간을 어떤 단위로 메모리에 적재하는가에 따라 &lt;strong&gt;요구 페이징(demand paging)&lt;/strong&gt; 과 &lt;strong&gt;요구 세그먼테이션(demand segmentation)&lt;/strong&gt; 방식으로 나뉜다.
&lt;ul&gt;
&lt;li&gt;대부분 요구 페이징 방식을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;요구 페이징(demand paging)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로그램을 실행했을 때, 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라, &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;당장 사용될 페이지만을 올리는 방식&lt;/strong&gt;&lt;/mark&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;물리적 메모리 용량보다 더 큰 프로그램도 실행할 수 있다.&lt;/li&gt;
&lt;li&gt;당장 사용할 페이지만 올리기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 올리는 데 드는 입출력 오버헤드도 감소한다.&lt;/li&gt;
&lt;li&gt;사용되지 않을 주소 영역에 대한 입출력까지 수행하던 기존 방식에 비해 응답 시간을 단축시킬 수 있다.&lt;/li&gt;
&lt;li&gt;또한 시스템이 더 많은 프로세스를 수용할 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;해당 페이지가 메모리에 존재하는지 표시하기 위해 &lt;strong&gt;유효-무효 비트(valid-invalid bit)&lt;/strong&gt; 를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페이지 부재(page fault)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아서&lt;/strong&gt;&lt;/mark&gt; 유효-무효 비트가 무효로 세팅되어 있는 경우이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;페이지-부재를-처리하는-방식&#34;&gt;페이지 부재를 처리하는 방식&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/10-01-pageFault.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;페이지 부재 처리&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) CPU가 무효 페이지에 접근하면, (2) 주소 변환을 담당하는 하드웨어인 &lt;strong&gt;MMU가 페이지 부재트랩(page fault trap)을 발생&lt;/strong&gt;시칸다.&lt;/li&gt;
&lt;li&gt;CPU의 제어권이 &lt;strong&gt;커널 모드&lt;/strong&gt;로 전환되고, 운영체제의 &lt;strong&gt;페이지 부재 처리루틴(page fault handler)이 호출&lt;/strong&gt;된다.&lt;/li&gt;
&lt;li&gt;(3, 4) 해당 페이지의 접근이 &lt;strong&gt;적법한 것으로 판명된 경우, 물리적 메모리에서 비어 있는 프레임을 할당 받아서 그 공간에 해당 페이지를 읽어온다.&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;만약 비어있는 프레임이 없다면, 기존에 메모리에 올라와 있는 &lt;strong&gt;페이지 중 하나를 디스크로 쫒아낸다.&lt;/strong&gt; (스왑 아웃; swap out)&lt;/li&gt;
&lt;li&gt;페이지를 메모리로 적재하는데 오랜시간이 걸리므로 해당 프로세스는 CPU를 빼앗기고 &lt;strong&gt;봉쇄 상태&lt;/strong&gt;가 된다.&lt;/li&gt;
&lt;li&gt;현재까지 수행되던 CPU 레지스터 상태 및 프로그램 카운터 값은 &lt;strong&gt;프로세스 제어블록에 저장&lt;/strong&gt;해 두어서 나중에 이 프로세스가 CPU를 할당 받으면 정확히 같은 상태에서 다음 명령을 수행할 수 있도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(5) 디스크 입출력이 완료되어서 인터럽트가 발생하면 페이지 테이블에서 해당 페이지의 &lt;strong&gt;유효-무효 비트를 유효로 설정하고, 봉쇄되었던 프로세스를 준비 큐로 이동&lt;/strong&gt;시킨다.&lt;/li&gt;
&lt;li&gt;(6) 이 프로세스가 CPU를 할당 받으면 프로세스 제어블록에 저장해두었던 값을 복원시켜 이전에 중단되었던 명령(instruction)부터 실행을 재개한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;요구-페이징의-성능&#34;&gt;요구 페이징의 성능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;유효 접근시간 (effective access time)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ = (1 - P) \times $ 메모리 접근시간 $ + P \times ($ 페이지 부재 발생 처리 오버헤드 $+$ 메모리에 빈 프레임이 없는 경우 스왑 아웃 오버헤드 $+$ 요청된 페이지의 스왑 인 오버헤드 $+$ 프로세스의 재시작 오버헤드$)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;페이지 부재 발생비율(page fault rate)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ 0 \le P \le 1 $&lt;/li&gt;
&lt;li&gt;$ P = 0 : $ 페이지 부재가 한 번도 일어나지 않은 경우&lt;/li&gt;
&lt;li&gt;$ P = 1 : $ 모든 참조 요청에서 페이지 부재가 발생한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;요구 페이징의 성능에 가장 큰 영향을 미치는 요소는 &lt;strong&gt;페이지 부재의 발생 빈도&lt;/strong&gt;이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$P = 0$이면, 즉 페이지 부재가 일어나지 않으면, 오로지 메모리 접근 시간만 소요된다.&lt;/li&gt;
&lt;li&gt;$P \ne 0$이면, 즉 페이지 부재가 일어나면, 많은 오버헤드가 필요하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;페이지-교체&#34;&gt;페이지 교체&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/10-02-pageReplacement.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;페이지 교체&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;페이지 교체(page replacement)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;페이지 부재가 발생했을 때 메모리에 빈 공간이 없으면, 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫒아내서 공간을 확보한다. 이것을 페이지 교체라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페이지 교체 알고리즘&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;어떤 페이지를 쫒아낼 것인가&lt;/strong&gt;&lt;/mark&gt;를 결정하는 알고리즘이다.&lt;/li&gt;
&lt;li&gt;이 알고리즘의 목표는 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;페이지 부재율을 최소화하는 것&lt;/strong&gt;&lt;/mark&gt;이다.&lt;/li&gt;
&lt;li&gt;성능평가
&lt;ul&gt;
&lt;li&gt;페이지 참조열(page reference string)에 대해 페이지 부재율을 계산함으로써 평가할 수 있다.&lt;/li&gt;
&lt;li&gt;해당 번호의 페이지가 메모리에 올라와 있으면 적중(hit), 없으면 부재가 발생했다고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;1-최적-페이지-교체&#34;&gt;(1) 최적 페이지 교체&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Optimal Algorithm&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;빌레디의 최적 알고리즘(Belady&amp;rsquo;s optimal algorithm), MIN, OPT&lt;/strong&gt; 등으로 불린다.&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;가장 먼 미래에 참조될 페이지를 먼저 교체&lt;/strong&gt;&lt;/mark&gt;하는 방법이다.&lt;/li&gt;
&lt;li&gt;미래에 어떤 페이지가 어떤 순서로 참조될지 미리 알고있다는 전제하에 알고리즘을 운영하므로, 실제 온라인으로 사용할 수 있는 알고리즘이 아니다. 이런 알고리즘을 &lt;strong&gt;오프라인 알고리즘&lt;/strong&gt;이라고 부른다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;어떤 경우라도 가장 적은 페이지 부재율을 보장&lt;/strong&gt;하므로, 다른 알고리즘의 성능을 평가하는 &lt;strong&gt;상한선(upper bound)을 제공&lt;/strong&gt;한다. 즉, 최적 알고리즘과 유사한 결과가 나오면 좋은 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;2-선입선출-알고리즘-fifo&#34;&gt;(2) 선입선출 알고리즘 (FIFO)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;First In First Out&lt;/li&gt;
&lt;li&gt;메모리에 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;가장 먼저 올라온 페이지를 먼저 교체&lt;/strong&gt;&lt;/mark&gt;하는 방법이다.&lt;/li&gt;
&lt;li&gt;향후 참조 가능성을 생각하지 않기 때문에 비효율적인 상황이 발생할 수 있다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FIFO 이상 현상(FIFO anomaly)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;메모리를 증가시켰음에도 불구하고 페이지 부재가 오히려 늘어나는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;3-lru-알고리즘&#34;&gt;(3) LRU 알고리즘&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Least Recently Used&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;가장 오래전에 참조한 페이지를 먼저 교체&lt;/strong&gt;&lt;/mark&gt;하는 방법이다.&lt;/li&gt;
&lt;li&gt;최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높다는 성질인, &lt;strong&gt;시간 지역성(temporal locality)&lt;/strong&gt; 에 따른 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;4-lfu-알고리즘&#34;&gt;(4) LFU 알고리즘&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Least Frequently Used&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;과거에 참조 횟수(reference count)가 가장 적은 페이지를 먼저 교체&lt;/strong&gt;&lt;/mark&gt;하는 방법이다.&lt;/li&gt;
&lt;li&gt;참조 횟수를 계산하는 방식에 따라&amp;hellip;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Incached-LFU&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;페이지가 메모리에서 쫒겨났다가 다시 들어오면 참조 횟수가 1이된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perfect-LFU&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;과거의 총 참조 횟수를 카운트한다.&lt;/li&gt;
&lt;li&gt;과거의 참조 기록을 모두 보관해야 하므로 오베헤드가 상대적으로 크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;LRU의 경우에는 직전에 참조된 시점만을 반영하지만 LFU는 장기적인 시간 규모에서의 참조 성향을 고려한다.
&lt;ul&gt;
&lt;li&gt;참조열이 &lt;code&gt;1, 1, 1, 1, 2, 2, 3, 3, 2, 4, 5&lt;/code&gt;와 같고 현재 &lt;code&gt;5&lt;/code&gt; 페이지를 참조하기 위해 페이지 교체를 해야한다고 했을 때,&lt;/li&gt;
&lt;li&gt;LRU는 가장 오래전에 참조한 &lt;code&gt;1&lt;/code&gt;을 내쫒는다. $O(1)$의 시간 복잡도가 걸린다.&lt;/li&gt;
&lt;li&gt;LFU는 가장 참조 횟수가 적은 &lt;code&gt;4&lt;/code&gt;를 내쫒는다. 힙(heap)을 사용해서 $O(log n)$의 시간 복잡도가 걸린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;캐쉬-운영의-시간-제약&#34;&gt;캐쉬 운영의 시간 제약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;캐슁 기법&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;한정된 빠른 공간(=캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식이다.&lt;/li&gt;
&lt;li&gt;paging system(디스크의 스왑 영역의 페이지를 캐싱)외에도 cache memory, buffer caching(디스크의 파일 시스템의 파일의 블럭을 캐싱), web caching(지리적으로 멀리 떨어져있는 컴퓨터에서 웹서버에서 매번 읽어오지 않고 내 컴퓨터에 캐싱되어 있는 것을 읽어오는 것) 등 다양한 분야에서 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;교체 알고리즘은 &lt;strong&gt;캐쉬 운영의 시간 제약&lt;/strong&gt;이 있다.
&lt;ul&gt;
&lt;li&gt;교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없다.&lt;/li&gt;
&lt;li&gt;buffer caching이나 web caching의 경우에는
&lt;ul&gt;
&lt;li&gt;$O(1)$, $O(log n)$ 정도까지만 허용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;paging system의 경우 제약 조건이 더 있다.
&lt;ul&gt;
&lt;li&gt;페이지 부재가 발생한 경우에만, 트랩이 발생하고 제어권이 넘어가서 운영체제가 관리할 수 있게 된다.&lt;/li&gt;
&lt;li&gt;그래서 페이지가 이미 메모리에 존재하는 경우에는 &lt;strong&gt;운영체제가 참조 시각 등의 정보를 알 수 없다.&lt;/strong&gt; 그래서 $O(1)$이더라도 LRU의 리스트(참조한 것들의 목록) 조작도 불가능하게 된다.&lt;/li&gt;
&lt;li&gt;그렇기 때문에 LRU, LFU는 사실 paging system에 적절한 알고리즘들은 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;5-클럭-알고리즘nur&#34;&gt;(5) 클럭 알고리즘(NUR)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Not Used Recently&lt;/li&gt;
&lt;li&gt;LRU, LFU 알고리즘은 페이지 참조 시각, 참조 횟수를 소프트웨어적으로 유지하고 비교하므로 오버헤드가 발생한다.&lt;/li&gt;
&lt;li&gt;클럭 알고리즘은 이것을 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;하드웨어적으로 지원&lt;/strong&gt;&lt;/mark&gt;해서 훨씬 빠르고 효율적으로 이루어지게 한다.&lt;/li&gt;
&lt;li&gt;대부분의 시스템에서 이 알고리즘을 채택한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LRU를 근사시킨 알고리즘&lt;/strong&gt;이다.
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;최근에 참조되지 않은 페이지를 교체&lt;/strong&gt;&lt;/mark&gt;하는 것은 LRU와 동일하다.&lt;/li&gt;
&lt;li&gt;하지만 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;참조 시점이 가장 오래되었다는 것을 보장하지는 못한다.&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/10-03-clockAlogorithm.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;클럭 알고리즘&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 프레임 마다 &lt;strong&gt;참조 비트(reference bit)&lt;/strong&gt; 를 두어 사용한다.
&lt;ul&gt;
&lt;li&gt;해당 프레임의 페이지가 참조될 때 하드웨어에 의해 &lt;code&gt;1&lt;/code&gt;로 자동 세팅된다.&lt;/li&gt;
&lt;li&gt;교체 대상 페이지를 찾을 때는 &lt;code&gt;1&lt;/code&gt;인 페이지는 &lt;code&gt;0&lt;/code&gt;으로 만들고 지나가고, &lt;code&gt;0&lt;/code&gt;인 페이지를 만나면 교체한다.&lt;/li&gt;
&lt;li&gt;즉, 시곗바늘이 한 바퀴 도는 동안 다시 참조되지 않은 페이지를 교체하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;modified bit(dirty bit)&lt;/strong&gt; 를 둘 수도 있다.
&lt;ul&gt;
&lt;li&gt;참조 비트는 Read한 페이지라면, 이것은 최근에 Write로 변경된 페이지(I/O를 동반하는 페이지)를 &lt;code&gt;1&lt;/code&gt;로 세팅한다.&lt;/li&gt;
&lt;li&gt;modified bit이 &lt;code&gt;1&lt;/code&gt;인 페이지를 교체하려면 수정된 내용을 디스크에 쓰고 교체해야한다. 그래서 &lt;code&gt;0&lt;/code&gt;인 페이지를 교체하는 것이 더 효율적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;할당량&#34;&gt;할당량&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;각 프로세스에 얼마만큼의 메모리 공간을 할당할 것인가?&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어, 반복문을 실행 중인 프로세스의 경우 반복문을 구성하는 페이지들을 한꺼번에 메모리에 올려 놓는 것이 페이지 부재가 덜 발생한다.&lt;/li&gt;
&lt;li&gt;혹은 명령을 실행할 때 프로세스의 주소 공간에서 코드, 데이터, 스택 등의 각기 다른 영역을 참조하기 때문에 적어도 일정 수준 이상의 프레임을 할당해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;할당 알고리즘
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;균등할당(equal allocation)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;모든 프로세스에게 &lt;u&gt;균일하게&lt;/u&gt; 할당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비례할당(proportional allocation)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스 크기에 &lt;u&gt;비례해서&lt;/u&gt; 할당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;우선순위 할당(priority allocation)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스의 &lt;u&gt;우선순위에 따라&lt;/u&gt; 할당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프레임의-범위&#34;&gt;프레임의 범위&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;교체 대상이 될 프레임의 범위를 어떻게 정할 것인가?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;전역교체(global replacement)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;모든 프레임&lt;/u&gt;이 교체 대상이 된다.&lt;/li&gt;
&lt;li&gt;교체할 프레임은 다른 프로세스에게 할당된 것일 수 있다. 즉, 페이지 교체 시 다른 프로세스에 할당된 프레임을 빼앗아올 수 있는 방식이다. 다시 말하면, 전체 메모리를 각 프로세스가 공유해서 사용하고 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방법이다.&lt;/li&gt;
&lt;li&gt;워킹 셋, PFF 알고리즘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;지역교체(local replacement)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;현재 수행 중인 &lt;u&gt;프로세스에게 할당된 프레임 내에서만&lt;/u&gt; 교체 대상을 선정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;스레싱&#34;&gt;스레싱&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/10-04-thrashing.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;스레싱&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스레싱(thrashing)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;잦은 페이지 부재로 CPU 이용률이 급격히 저하되는 현상&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;프로세스의 원활한 수행을 위해 필요한 최소한의 페이지 만큼 메모리를 할당받지 못하면?
&lt;ul&gt;
&lt;li&gt;페이지 부재율이 높아진다.&lt;/li&gt;
&lt;li&gt;CPU 이용률(CPU utilization)이 낮아진다.&lt;/li&gt;
&lt;li&gt;운영체제는 &lt;strong&gt;다중 프로그래밍의 정도(multi-programming degree; MPD; 메모리에 동시에 올라가 있는 프로세스의 수)&lt;/strong&gt; 를 높인다.&lt;/li&gt;
&lt;li&gt;또 다시 새로운 프로세스가 시스템에 추가된다. 그러면 프로세스 당 할당된 프레임의 수가 더욱 감소한다.&lt;/li&gt;
&lt;li&gt;페이지 부재가 빈번히 발생하여, 프로세스들은 서로의 페이지를 교체하며 스왑 인과 스왑 아웃을 지속적으로 발생시킨다.&lt;/li&gt;
&lt;li&gt;따라서 대부분의 시간에 CPU는 할일이 없게된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MPD를 적절히 조절해서, CPU 이용률을 높이는 동시에 스레싱 발생을 방지하는 방법&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;(아래&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;1-워킹셋-알고리즘&#34;&gt;(1) 워킹셋 알고리즘&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;참조의 지역성(locality of reference)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스는 일정 시간 동안 특정 주소 영역을 집중적으로 참조하는 경향이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;지역성 집합(locality set)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;집중적으로 참조되는 페이지들의 집합.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;워킹셋 알고리즘(working-set algorithm)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘이다.&lt;/li&gt;
&lt;li&gt;프로세스가 일정 시간 동안 원활히 수행되기 위해 &lt;strong&gt;한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합&lt;/strong&gt;을 &lt;strong&gt;워킹셋(working-set)&lt;/strong&gt; 이라고 정의한다.&lt;/li&gt;
&lt;li&gt;이 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;워킹셋이 한꺼번에 메모리에 올라갈 수 있는 경우에만 그 프로세스에게 메모리를 할당&lt;/strong&gt;&lt;/mark&gt;한다.&lt;/li&gt;
&lt;li&gt;그렇지 못한다면 할당된 모든 프레임을 반납하고 디스크로 스왑 아웃시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;워킹셋을 결정하는 법
&lt;ul&gt;
&lt;li&gt;윈도우의 크기가 $\Delta$인 경우, 페이지가 참조된 시점부터 $\Delta$시간 동안은 메모리에 유지하고, 그 시점이 지나면 메모리에서 지워버린다.&lt;/li&gt;
&lt;li&gt;$t_i$ 시각에서의 워킹셋 $WS(t_i)$&lt;/li&gt;
&lt;li&gt;$=$ 시간간격 $[t_i - \Delta, t_i]$ 사이에 참조된 서로 다른 페이지들의 집합&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;2-페이지-부재-빈도-알고리즘&#34;&gt;(2) 페이지 부재 빈도 알고리즘&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/10-05-pff.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;페이지 부재 빈도 알고리즘&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;페이지 부재 빈도 알고리즘(page-fault frequency scheme)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;페이지 부재율의 상한값과 하한값을 두어서, 상한값을 넘기면 프레임을 추가로 할당하고, 하한값 이하로 떨어지면 프레임 수를 줄이는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 9. 메모리 관리</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-09/</link>
        <pubDate>Wed, 06 Jul 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-09/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;주소-바인딩&#34;&gt;주소 바인딩&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;논리적 주소(Logical address) = Virtual address&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스마다 독립적으로 가지는 주소 공간이다.&lt;/li&gt;
&lt;li&gt;각 프로세스마다 0번지부터 시작한다.&lt;/li&gt;
&lt;li&gt;CPU가 보는 주소는 이 논리적 주소이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;물리적 주소(Physical address)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;메모리에 실제로 올라가는 위치이다.&lt;/li&gt;
&lt;li&gt;낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다. &lt;br /&gt;
&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-01-physicalMemory.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;메모리 영역&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;주소 바인딩&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU가 기계어 명령을 수행하려고 논리적 주소를 통해 메모리를 참조하면, 그 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.&lt;/li&gt;
&lt;li&gt;이렇게 &lt;u&gt;논리적 주소를 물리적 주소로 연결시켜주는 것&lt;/u&gt;을 주소 바인딩이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;주소 바인딩의 시점에 따라 그 종류가 나뉠 수 있겠다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Symbolic address → Logical address →&lt;mark style=&#34;background-color: lightblue&#34;&gt;(이 시점이 언제인가?)&lt;/mark&gt; Physical address&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;여기서 Symbolic address는 프로그래머가 사용하는, 숫자가 아닌 심볼로 된 주소를 의미한다. 이것이 컴파일이 되면 숫자로 된 Logical address로 바뀌겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;주소-바인딩의-종류&#34;&gt;주소 바인딩의 종류&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-02-binding.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;주소 바인딩의 종류 예시&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;컴파일 타임 바인딩(compile time binding)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;물리적 메모리의 주소가 컴파일 시에 결정된다.&lt;/li&gt;
&lt;li&gt;컴파일러가 &lt;u&gt;절대 코드(absolute code)&lt;/u&gt; 를 생성하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로드 타임 바인딩(load time bining)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;물리적 메모리의 주소가 프로그램의 실행이 시작될 때 결정된다.&lt;/li&gt;
&lt;li&gt;컴파일러가 &lt;u&gt;재배치 가능 코드(relocatable code)&lt;/u&gt; 를 생성한 경우 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;런타임 바인딩(runtime binding = executione time binding)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로그램을 시작한 후에도 물리적 메모리의 주소를 변경할 수 있는 방식이다.&lt;/li&gt;
&lt;li&gt;CPU가 주소를 참조할 때마다 &lt;u&gt;주소 매핑 테이블(address mapping table)&lt;/u&gt; 을 이용해서 바인딩을 점검한다.&lt;/li&gt;
&lt;li&gt;하드웨어적 지원이 필요하다.
&lt;ul&gt;
&lt;li&gt;**MMU, 기준 레지스터, 한계 레지스터, **&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;런타임-바인딩을-위한-하드웨어적-지원-요소&#34;&gt;런타임 바인딩을 위한 하드웨어적 지원 요소&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-03-mmu.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;MMU 예시&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메모리 관리 유닛 (Memory Management Unit; MMU)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;논리적 주소를 물리적 주소로 바인딩 해주는 하드웨어 장치이다.&lt;/li&gt;
&lt;li&gt;CPU가 사용자 프로세스의 논리적 주소를 참조하려고 할 때, &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;그 주소값에 기준 레지스터(base register)의 값을 더해서&lt;/strong&gt;&lt;/mark&gt; 물리적 주소값을 얻어낸다.&lt;/li&gt;
&lt;li&gt;그래서 사용자 프로세스는 논리적 주소만 다루고, 실제 물리적 주소를 다루지 못하면 알 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;기준 레지스터 = 재배치 레지스터 (base register = relocation register)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해당 프로세스의 &lt;u&gt;물리적 메모리 시작 주소&lt;/u&gt;를 가지고 있다.&lt;/li&gt;
&lt;li&gt;따라서 논리적 주소는 일종의 오프셋(offset) 개념으로 생각할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;한계 레지스터 (limit register)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;논리적 주소값에 기준 레지스터 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우를 방지하기 위해서, 해당 프로세스의 &lt;u&gt;논리적 주소의 최댓값(프로세스의 크기)&lt;/u&gt;을 가지고 있다.&lt;/li&gt;
&lt;li&gt;만약 주소 공간을 벗어나는 경우에는 트랩을 발생시켜 해당 프로세스를 강제종료시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;메모리-관리와-관련된-용어&#34;&gt;메모리 관리와 관련된 용어&lt;/h2&gt;
&lt;h3 id=&#34;동적로딩dynamic-loading&#34;&gt;동적로딩(Dynamic loading)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;의미
&lt;ul&gt;
&lt;li&gt;프로세스 주소 공간 전체를 메모리에 올리는 것이 아니라 해당 부분이 불릴 때, 그 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;일부분만을 메모리에 적재하는 방식&lt;/strong&gt;&lt;/mark&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;목적
&lt;ul&gt;
&lt;li&gt;여러 프로그램이 메모리에 올라가는 다중 프로그래밍 방식에서 더 많은 프로세스를 동시에 올려놓기 위함이다.&lt;/li&gt;
&lt;li&gt;사용되지도 않는 많은 양의 코드가 메모리에 올라가는 것을 막아서 &lt;strong&gt;메모리를 효율적&lt;/strong&gt;으로 쓸 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용 방법
&lt;ul&gt;
&lt;li&gt;운영체제의 특별한 지원 없이, 프로그램 자체에서 구현이 가능하다.&lt;/li&gt;
&lt;li&gt;운영체제가 라이브러리를 통해 지원할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;중첩overlays&#34;&gt;중첩(Overlays)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;의미
&lt;ul&gt;
&lt;li&gt;동적로딩과 같다. 하지만 역사적인 목적이 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;목적
&lt;ul&gt;
&lt;li&gt;단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용 방법
&lt;ul&gt;
&lt;li&gt;프로그래머가 수작업으로 구현해서 수작업 중첩(Manual Overlays)이라고도 불렸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;동적연결dynamic-linking&#34;&gt;동적연결(Dynamic linking)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;연결(linking)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;소스 코드를 컴파일해서 생성된 &lt;u&gt;목적 파일(object file)&lt;/u&gt;과, 이미 컴파일 된 &lt;u&gt;라이브러리 파일(library file)들&lt;/u&gt;을 묶어서 &lt;u&gt;하나의 실행 파일을 생성하는 과정&lt;/u&gt;을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;동적연결 의미
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;연결을 실행 시간까지 미루는 기법&lt;/u&gt;이다. 즉, &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;프로그램이 실행되고 라이브러리 함수를 호출해서야 라이브러리에 대한 연결&lt;/strong&gt;&lt;/mark&gt;이 이루어진다.&lt;/li&gt;
&lt;li&gt;라이브러리 호출 부분에 라이브러리 위치를 찾기 위한 &lt;strong&gt;스텁(stub)&lt;/strong&gt; 이라는 작은 코드를 둔다. 프로그램이 실행되고 라이브러리 함수를 호출하면, 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는 지 살펴본다. 라이브러리가 메모리에 있으면 불러오고,없으면, 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;목적
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정적연결(Static linking)&lt;/strong&gt; 와 비교된다.
&lt;ul&gt;
&lt;li&gt;정적연결은 라이브러리가 프로그램의 실행 파일에 포함된다. (예: &lt;code&gt;printf&lt;/code&gt; 함수의 라이브러리 코드) 따라서 실행 파일이 커진다.&lt;/li&gt;
&lt;li&gt;또한 동일한 라이브러리를 각각의 프로세스가 메모리에 올려서 메모리의 낭비가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동적연결의 경우 공통으로 사용하는 라이브러리를 한 번만 적재하므로 &lt;strong&gt;메모리 효율성&lt;/strong&gt;을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용 방법
&lt;ul&gt;
&lt;li&gt;운영체제의 도움이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;스와핑swapping&#34;&gt;스와핑(Swapping)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;의미
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;프로세스의 주소 공간 전체를 메모리에서 디스크에 있는 스왑 영역(swap area)으로 쫒아내는 것&lt;/strong&gt;&lt;/mark&gt;이다.&lt;/li&gt;
&lt;li&gt;스왑 영역은 &lt;strong&gt;백킹 스토어(backing store)&lt;/strong&gt; 라고도 부르며, 디스크 안에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다.&lt;/li&gt;
&lt;li&gt;이것은 프로세스가 종료되어서가 아니라, 특정 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;중기 스케줄러에 의해 스왑 아웃될 프로세스가 선정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;목적
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;메모리에 존재하는 프로세스의 수&lt;/strong&gt;를 조절하기 위함이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;바인딩과 연관해서 생각해보면&amp;hellip;
&lt;ul&gt;
&lt;li&gt;컴파일, 로드 타임 바인딩 방식
&lt;ul&gt;
&lt;li&gt;돌아올 때는 &lt;strong&gt;원래 있던 메모리 위치&lt;/strong&gt;로 스왑 인해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;런타임 바인딩 방식
&lt;ul&gt;
&lt;li&gt;빈 메모리 &lt;strong&gt;아무 곳에나&lt;/strong&gt; 프로세스를 올릴 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;물리적-메모리의-할당-방식&#34;&gt;물리적 메모리의 할당 방식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;물리적 메모리의 낮은 주소 영역에는 운영 체제가 올라가고, 인터럽트 벡터, 운영체제 커널이 여기 위치한다.&lt;/li&gt;
&lt;li&gt;물리적 메모리의 높은 주소 영역에는 여러가지 사용자 프로세스들이 올라간다.&lt;/li&gt;
&lt;li&gt;여기서는 &lt;strong&gt;사용자 프로세스 영역의 관리 방법&lt;/strong&gt;에 대해 살펴본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h2 id=&#34;연속할당-방식&#34;&gt;연속할당 방식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Contiguous allocation&lt;/li&gt;
&lt;li&gt;각각의 프로세스를 물리적 메모리의 &lt;strong&gt;연속적인 공간에&lt;/strong&gt; 올리는 방식이다.&lt;/li&gt;
&lt;li&gt;물리적 메모리를 다수의 분할로 나누어서 하나의 분할에 하나의 프로세스가 적재되도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-04-contiguousAllocation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;연속할당 방식&#34;
	
	
&gt;&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id=&#34;1-고정-분할-방식&#34;&gt;(1) 고정 분할 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fixed partition allocation&lt;/li&gt;
&lt;li&gt;물리적 메모리를 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;주어진 개수만큼 영구적인 분할로 미리 나누어두는&lt;/strong&gt;&lt;/mark&gt; 방식이다.&lt;/li&gt;
&lt;li&gt;분할의 크기는 모두 동일하게 할 수도 있고, 서로 다르게 할 수도 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;하나의 분할에는 하나의 프로그램만을 적재&lt;/strong&gt;할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;동시에 메모리에 올릴 수 있는 프로그램 수가 고정되어 있으므로 융통성이 떨어진다.&lt;/li&gt;
&lt;li&gt;외부 단편화와 내부 단편화가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;외부 단편화(external fragmentation)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;해당 분할이 비어 있지만 프로그램의 크기가 더 커서 할당할 수 없어 낭비되는 공간이 생긴 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;내부 단편화(internal fragmentation)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;할당된 분할이 프로그램 크기에 비해 더 커서 낭비되는 공간이 생긴 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-가변-분할-방식&#34;&gt;(2) 가변 분할 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Variable partition allocation&lt;/li&gt;
&lt;li&gt;물리적 메모리를 미리 나누어 두지 않고, &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;프로그램 크기에 따라서 동적으로 분할의 크기, 개수가 변하는&lt;/strong&gt;&lt;/mark&gt; 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동적 메모리 할당 문제(dynamic storage-allocation problem)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;주소 공간의 크기가 $n$인 프로세스를 메모리에 올릴 때, 물리적 메모리 내 가용 공간(hole) 중에 &lt;u&gt;어떤 위치에 올릴 것인가?&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;방법1. &lt;strong&gt;최초적합(first-fit)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;크기가 $n$이상인 가용 공간 중, &lt;u&gt;가장 먼저 찾아지는 곳&lt;/u&gt;에 프로세스를 할당한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;방법2. &lt;strong&gt;최적적합(best-fit)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;크기가 $n$이상인 가용 공간 중, &lt;u&gt;가장 작은 곳&lt;/u&gt;에 프로세스를 할당한다.&lt;/li&gt;
&lt;li&gt;많은 수의 작은 가용 공간들이 생성되겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;방법3. &lt;strong&gt;최악적합(worts-fit)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;가용 공간 중에서 크기가 &lt;u&gt;가장 큰 곳&lt;/u&gt;에 프로세스를 할당한다.&lt;/li&gt;
&lt;li&gt;상대적으로 큰 가용 공간들이 생성되겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;외부 단편화가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;해결 방법: &lt;strong&gt;컴팩션(compaction)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;사용 중인 메모리 영역을 한쪽으로 몰고, 가용 공간을 다른 한쪽으로 몰아서, 하나의 큰 가용 공간을 만드는 방법이다.&lt;/li&gt;
&lt;li&gt;비용이 매우 많이 드는 작업이다.&lt;/li&gt;
&lt;li&gt;물리적 메모리 위치를 옮겨야 하므로, 런타임 바인딩 방식에서만 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;불연속할당-방식&#34;&gt;불연속할당 방식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Noncontiguous allocation&lt;/li&gt;
&lt;li&gt;하나의 프로세스를 물리적 메모리의 여러 영역에 &lt;strong&gt;분산해서&lt;/strong&gt; 적재하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;1-페이징-기법&#34;&gt;(1) 페이징 기법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Paging&lt;/li&gt;
&lt;li&gt;각 프로세스의 주소 공간을 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;동일한 크기의 페이지로 자르고&lt;/strong&gt;&lt;/mark&gt;, 물리적 메모리도 프레임(frame)으로 잘라서 적재시키는 방식이다.&lt;/li&gt;
&lt;li&gt;논리적 메모리 주소를 가진 페이지를 물리적 메모리의 몇 번째 프레임에 있는지로 변환하기 위한 &lt;strong&gt;페이지 테이블(page table)&lt;/strong&gt; 이 필요하다.
&lt;ul&gt;
&lt;li&gt;따라서 &lt;strong&gt;페이지의 개수만큼의 entry&lt;/strong&gt;(항목; 페이지 테이블의 레코드)가 필요하다.&lt;/li&gt;
&lt;li&gt;각 프로세스 마다 페이지 테이블이 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;주소-변환-기법&#34;&gt;주소 변환 기법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-05-paging.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;페이징&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;논리적인 페이지 번호 &lt;code&gt;p&lt;/code&gt;로 페이지 테이블에 접근한다. 거기에서 물리적인 프레임 번호 &lt;code&gt;f&lt;/code&gt;를 얻는다.&lt;/li&gt;
&lt;li&gt;프레임 내에서의 위치(오프셋 &lt;code&gt;d&lt;/code&gt;)는 프레임 내에서의 주소로 그대로 사용된다. &lt;code&gt;f&lt;/code&gt; + &lt;code&gt;d&lt;/code&gt;로 물리적 메모리에 접근한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;페이지-테이블의-구현&#34;&gt;페이지 테이블의 구현&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;페이지 테이블 기준 레지스터(page-table base register; PTBR)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;페이지 테이블은 메인 메모리에 상주하는데, PTBR은 이 물리적 메모리에서 &lt;u&gt;페이지 테이블이 존재하는 시작 위치&lt;/u&gt;를 가리킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페이지 테이블 길이 레지스터(page-table length register; PTLR)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;페이지 테이블의 크기&lt;/u&gt;를 보관한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;모든 메모리 접근 연산에는 2번의 메모리 접근이 필요하다.
&lt;ul&gt;
&lt;li&gt;페이지 테이블 접근 1번, 실제 데이터 접근 1번.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;따라서 메모리 접근 속도 향상을 위해, &lt;strong&gt;TLB(Translation Look-aside Buffer; 고속의 주소 변환용 하드웨어 캐시 메모리)&lt;/strong&gt; 를 사용하기도 한다.
&lt;ul&gt;
&lt;li&gt;이것은 빈번히 참조되는 페이지에 대한 주소 변환 정보를 가지고 있다. 페이지 테이블을 참조하기 전에 이 캐시를 먼저 살펴보고 없으면 페이지 테이블을 참조한다.&lt;/li&gt;
&lt;li&gt;페이지 테이블 처럼 모든 주소를 가지고 있는 게 아니라서, 저장되어 있는 순서에 따라 페이지 번호 &lt;code&gt;p&lt;/code&gt;를 알 수 없다. 따라서 페이지 번호 &lt;code&gt;p&lt;/code&gt;가 함께 프레임 번호 &lt;code&gt;f&lt;/code&gt;가 쌍으로 저장되어 있다.&lt;/li&gt;
&lt;li&gt;각 프로세스마다 주소 변환 정보가 다르기 때문에 페이지 테이블이 따로 존재하고, TLB도 마찬가지이다. 그래서 &lt;strong&gt;문맥교환 시에 TLB의 entry는 비워진다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;TLB의 모든 entry를 다 찾아보는 오버헤드를 줄이기 위해서 일반적으로 병렬탐색(parallel search)이 가능한 &lt;strong&gt;연관 레지스터(associative register)&lt;/strong&gt; 를 사용한다. 병렬탐색이란 TLB 내의 모든 entry를 동시에 탐색할 수 있는 기능을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;메모리 접근 시간(Effective Access Time; EAT)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;$ EAT = (1 + \epsilon)\alpha + (2 + \epsilon)(1 - \alpha)$&lt;/li&gt;
&lt;li&gt;$ EAT = 2 + \epsilon - \alpha $&lt;/li&gt;
&lt;li&gt;$1$ : 메모리 접근 시간&lt;/li&gt;
&lt;li&gt;$\epsilon$ : 연관 레지스터에 접근하는 시간&lt;/li&gt;
&lt;li&gt;$\alpha$ : 요청된 페이지에 대한 주소 변환 정보가 연관 레지스터에 존재할 확률 (Hit ratio)&lt;/li&gt;
&lt;li&gt;$ (1 + \epsilon)\alpha $ : hit. TLB에 존재하는 경우&lt;/li&gt;
&lt;li&gt;$ (2 + \epsilon)(1 - \alpha) $ : miss. TLB에 존재하지 않는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;계층적-페이징&#34;&gt;계층적 페이징&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-06-twoLevelPaging.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2단계 페이징&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컴퓨터가 $32bit$ 주소 체계를 사용한다면, $2^{32}byte(4GB)$의 주소 공간을 갖는 프로그램을 지원할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지 하나의 크기가 $4KB$라고 한다면, $4GB / 4KB = 1M$ 개의 페이지 테이블 entry가 필요하다.&lt;/li&gt;
&lt;li&gt;페이지 테이블 안에 한 entry의 크기가 $4byte$ 정도인데 그러면 총 $4byte \times 1M = 4MB$라는 공간이 필요하다. 프로세스 마다 $4MB$의 페이지 테이블을 모두 메모리에 집어 넣으면 공간 낭비가 심할 것이다.&lt;/li&gt;
&lt;li&gt;실제로 프로그램이 사용하는 부분은 메모리의 지극히 일부분이므로, 2단계 페이징(two-level paging) 기법을 사용해서 메모리의 낭비를 줄인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2단계 페이징(two-level paging)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;외부 페이지 테이블(outer page table)&lt;/strong&gt; 과 &lt;strong&gt;내부 페이지 테이블(inner page table)&lt;/strong&gt; 의 두 단계를 걸쳐 주소를 변환한다.&lt;/li&gt;
&lt;li&gt;사용되지 않는 주소 공간에 대해서는 &lt;strong&gt;외부 페이지 테이블의 entry를 &lt;code&gt;NULL&lt;/code&gt;로 설정해서 내부 페이지 테이블을 생성하지 않는 것&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;외부 페이지 테이블 번호 &lt;code&gt;P1&lt;/code&gt;과 내부 페이지 테이블 번호 &lt;code&gt;P2&lt;/code&gt;, 프레임 내에서의 오프셋 &lt;code&gt;d&lt;/code&gt;로 주소를 변환한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지 하나의 크기가 $4KB(2^{12}byte)$이므로, 그 내부에서 오프셋을 결정하기 위해서 &lt;code&gt;d&lt;/code&gt;는 $12bit$이어야 한다.&lt;/li&gt;
&lt;li&gt;내부 페이지 테이블은 페이지화되어서 페이지 하나의 크기인 $4KB$의 공간을 차지한다. 여기서 각 entry는 $4byte$이므로 entry의 총 수는 $4KB / 4byte = 1K$ 개이다. 이것은 $2^{10}$개 이므로, 내부 페이지 테이블의 &lt;code&gt;P2&lt;/code&gt;는 $10bit$가 된다.&lt;/li&gt;
&lt;li&gt;그리고 전체 주소 크기 $32it$에서 $12bit$, $10bit$를 뺀 $10bit$가 &lt;code&gt;P1&lt;/code&gt;의 크기가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;공유-페이지&#34;&gt;공유 페이지&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;공유 코드(shared code) = 재진입 가능 코드(re-entrant code) = 순수 코드(pure code)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;여러 프로세스에서 공통으로 사용될 수 있도록 작성된 코드이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;읽기 전용(read-only)&lt;/strong&gt; 의 특징을 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;공유 페이지(shread page)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;공유 코드를 담고 있는 페이지이다.&lt;/li&gt;
&lt;li&gt;여러 프로세스에 의해 공유되므로, 물리적 메모리에 하나만 적재되어 사용된다.
&lt;ul&gt;
&lt;li&gt;예를 들어, 문서 편집기 프로그램을 공유 페이지를 사용해서 작성한 경우, 이 프로세스를 여러 개 수행시키더라도 공유 코드를 담은 페이지는 메모리에 하나만 올라가고 여러 프로세스가 코드를 공유해서 사용하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이것을 사용하는 모든 프로세스의 &lt;strong&gt;논리적 주소 공간에서 동일한 페이지 번호&lt;/strong&gt;를 갖고 있어야만 한다. 물리적 주소가 같은 것은 당연하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;사유 페이지(private page)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;공유 페이지와 반대로, 프로세스들이 독자적으로 사용하는 페이지이다.&lt;/li&gt;
&lt;li&gt;사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어떠한 위치에 있어도 무방하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;메모리-보호&#34;&gt;메모리 보호&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;페이지 테이블의 각 entry에는 주소 변환 정보뿐만 아니라 메모리 보호를 위한 비트를 두고 있다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;보호비트(protection bit)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;각 페이지에 대한 접근 권한을 담고 있다.&lt;/li&gt;
&lt;li&gt;한 프로세스의 주소 공간은 다른 프로세스에 의해 접근될 수 없으므로 &amp;lsquo;누구&amp;rsquo;에 해당하는 접근 권한을 설정할 필요는 없다. 각 페이지에 &lt;strong&gt;&amp;lsquo;어떠한&amp;rsquo; 접근&lt;/strong&gt;을 허용하는지의 정보가 저장된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유효-무효 비트(valid-invalid bit)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;valid는 해당 주소의 메모리에 그 페이지가 존재함을 뜻한다. 유효한 내용이 있으므로 접근을 허용한다.&lt;/li&gt;
&lt;li&gt;invalid는 해당 주소의 메모리에 유효한 내용이 없음을 뜻한다. 유효한 내용이 없으므로 접근을 불허한다.
&lt;ul&gt;
&lt;li&gt;프로세스가 그 주소 부분을 사용하지 않고 있거나, 해당 페이지가 메모리에 올라와 있지 않고 백킹스토어에 존재하는 경우이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;역페이지-테이블&#34;&gt;역페이지 테이블&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;페이지 테이블에는 공간의 낭비가 발생한다.
&lt;ul&gt;
&lt;li&gt;모든 프로세스 별로 그 논리적 주소에 대응하는 모든 페이지에 대해 페이지 테이블 entry가 존재하기 때문이다.&lt;/li&gt;
&lt;li&gt;entry는 그 페이지가 물리적 메모리에 있든 없든간에 존재한다.&lt;/li&gt;
&lt;li&gt;그래서 대안으로 역페이지 테이블이 등장했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-07-invertedPageTable.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;역페이지 테이블&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;역페이지 테이블(Inverted page table)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라, 물리적 주소에 대해 페이지 테이블을 만드는 것이다.&lt;/li&gt;
&lt;li&gt;그래서 물리적 주소의 페이지 프레임 하나당 페이지 테이블의 entry 하나를 둔다. 즉, &lt;strong&gt;시스템 전체(system-wide)에 페이지 테이블을 하나만 두는 방법&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;entry에는 &lt;code&gt;프로세스의 id&lt;/code&gt;와 논리적 페이지 번호(&lt;code&gt;p&lt;/code&gt;)가 들어있다.&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해 페이지 테이블 전체를 탐색해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;조치
&lt;ul&gt;
&lt;li&gt;연관 레지스터를 사용해서 페이지 테이블 전체 entry를 병렬탐색 할 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-세그먼테이션&#34;&gt;(2) 세그먼테이션&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Segmentation&lt;/li&gt;
&lt;li&gt;프로그램의 주소 공간을 코드, 데이터, 스택 등 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;의미 있는 단위인 세그먼트로 나누어서&lt;/strong&gt;&lt;/mark&gt; 세그먼트 단위로 적재하는 방식이다.
&lt;ul&gt;
&lt;li&gt;논리적 단위(logical unit)로 나누었기 때문에 그 크기가 균일하지 않다.&lt;/li&gt;
&lt;li&gt;세그먼트를 함수 단위로 정의할 수도 있다. (&lt;code&gt;main()&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global variables&lt;/code&gt;, &lt;code&gt;stack&lt;/code&gt;, &lt;code&gt;symbol table&lt;/code&gt;, &lt;code&gt;arrays&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;주소-변환-기법-1&#34;&gt;주소 변환 기법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-08-segmentTable.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;세그먼트 테이블&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;논리적인 세그먼트 번호 &lt;code&gt;s&lt;/code&gt;는 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트인지를 알려준다. 이것을 사용해서 세그먼트 테이블에 접근한다.&lt;/li&gt;
&lt;li&gt;물리적 메모리의 세그먼트 내에서의 위치(오프셋 &lt;code&gt;d&lt;/code&gt;)는 그대로 사용된다. &lt;code&gt;base&lt;/code&gt; + &lt;code&gt;d&lt;/code&gt; 로 물리적 메모리에 접근한다.&lt;/li&gt;
&lt;li&gt;세그먼트 테이블의 각 entry는 기준점 &lt;code&gt;base&lt;/code&gt;와 한계점 &lt;code&gt;limit&lt;/code&gt;를 가지고 있다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;base&lt;/code&gt;는 물리적 메모리에서 그 세그먼트의 시작 위치를 나타낸다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;limit&lt;/code&gt;은 그 세그먼트의 길이를 나타낸다.
&lt;ul&gt;
&lt;li&gt;페이징에서는 이것이 필요 없었다. 길이가 모두 일정하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;세그먼트 테이블 기준 레지스터(Segment-Table Base Register; STBR)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;물리적 메모리에서 &lt;u&gt;세그먼트 테이블이 존재하는 시작 위치&lt;/u&gt;를 가리킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;세그먼트 테이블 길이 레지스터(Segment-Table Length Register; STLR)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 &lt;u&gt;세그먼트의 개수&lt;/u&gt;를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;세그먼테이션 기법에서는 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확인한다.
&lt;ul&gt;
&lt;li&gt;(1) 요청된 세그먼트 번호 &lt;code&gt;s&lt;/code&gt;가 STLR에 저장된 세그먼트 길이 값보다 작은 값인가?&lt;/li&gt;
&lt;li&gt;(2) 오프셋 값 &lt;code&gt;d&lt;/code&gt;가 세그먼트의 길이 &lt;code&gt;limit&lt;/code&gt;보다 작은 값인가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;공유-보호-할당&#34;&gt;공유, 보호, 할당&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;공유, 보호
&lt;ul&gt;
&lt;li&gt;공유 세그먼트(shared segment) 개념을 지원한다.&lt;/li&gt;
&lt;li&gt;세그먼테이션 기법에서도 페이징 기법과 마찬가지로 entry에 보호비트와 유효-무효 비트를 둔다.&lt;/li&gt;
&lt;li&gt;페이징에 비해 공유와 보안 측면에서 효과적이다.
&lt;ul&gt;
&lt;li&gt;페이지는 동일 크기로 무조건 자르기 때문에 한 페이지에 읽기 전용 접근 권한을 주더라도 코드영역과 데이터영역이 같이 들어가 있을 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 세그먼트는 의미적인 단위로 나뉘므로, 공유나 보안 처럼 &lt;strong&gt;의미적인 단위에 대해 수행하는 업무에서는 훨씬 효과적&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;할당
&lt;ul&gt;
&lt;li&gt;최초적합(first-fit), 최적적합(best-fit) 방식을 사용해서 세그먼트를 가용 공간에 할당할 수 있다.&lt;/li&gt;
&lt;li&gt;세그먼트의 크기가 모두 균일하지 않으므로 &lt;strong&gt;외부 조각이 발생&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-페이지드-세그먼테이션&#34;&gt;(3) 페이지드 세그먼테이션&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Paged segmentation&lt;/li&gt;
&lt;li&gt;페이징 기법과 세그먼테이션 기법의 장점만을 취하는 주소 변환 기법이다.&lt;/li&gt;
&lt;li&gt;프로그램의 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;주소 공간을 의미 단위인 세그먼트로 나누되, 세그먼트를 임의의 길이가 아닌 동일한 크기의 페이지들의 집합으로 구성&lt;/strong&gt;&lt;/mark&gt;하는 방식이다.&lt;/li&gt;
&lt;li&gt;따라서 하나의 세그먼트는 페이지 크기의 배수가 된다. 그리고 물리적 메모리에 적재하는 단위는 페이지 단위로 한다.
&lt;ul&gt;
&lt;li&gt;외부조각의 문제점을 해결하며, 의미 단위로 프로세스 간의 공유나 접근권한 보호가 이루어지도록 해서 각각의 단점을 보완한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h4 id=&#34;주소-변환-기법-2&#34;&gt;주소 변환 기법&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/09-09-pagedSegmentTable.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;페이지드 세그먼테이션 테이블&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용한다.&lt;/li&gt;
&lt;li&gt;세그먼트 번호 &lt;code&gt;s&lt;/code&gt;로 세그먼트 테이블에 접근해서, 세그먼트 길이 &lt;code&gt;segment-length&lt;/code&gt;와 페이지 테이블의 시작 주소 &lt;code&gt;page-table base&lt;/code&gt;를 얻는다.&lt;/li&gt;
&lt;li&gt;오프셋 값 &lt;code&gt;d&lt;/code&gt;가 세그먼트 길이값 &lt;code&gt;segment-length&lt;/code&gt;보다 작은지 검사한다.&lt;/li&gt;
&lt;li&gt;오프셋 값 &lt;code&gt;d&lt;/code&gt;를 상위(&lt;code&gt;p&lt;/code&gt;), 하위(&lt;code&gt;d&#39;&lt;/code&gt;) 비트로 나눈다. 상위 비트로 페이지 테이블에 접근(&lt;code&gt;page-table base&lt;/code&gt; + &lt;code&gt;p&lt;/code&gt;)하고, 하위 비트로 물리적 메모리의 페이지 내 변위(&lt;code&gt;f&lt;/code&gt; + &lt;code&gt;d&#39;&lt;/code&gt;)로 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 8. 데드락</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-08/</link>
        <pubDate>Thu, 30 Jun 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-08/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;데드락&#34;&gt;데드락&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;교착상태(deadlock)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;둘 이상의 프로세스가 &lt;strong&gt;서로 상대방이 가진 자원을 얻기 위해 무한히 기다리며 block된 상태&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;여기서 자원이란 하드웨어, 소프트웨어 등을 포함하는 개념이다. (예: I/O device, CPU cycle, memory space, semaphore 등)&lt;/li&gt;
&lt;li&gt;프로세스가 자원을 사용하는 절차: Request → Allocate → Use → Release&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;데드락-발생의-4가지-조건&#34;&gt;데드락 발생의 4가지 조건&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;조건&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;상호 배제 &lt;br /&gt; (Mutual exclusion)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;매 순간 하나의 프로세스만 자원을 획득할 수 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;보유 대기 &lt;br /&gt; (Hold and wait)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;자원을 가진 프로세스가 다른 자원을 기다릴 때, &lt;br /&gt; 보유 자원을 놓지 않고 계속 가지고 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;비선점 &lt;br /&gt; (No preemption)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;프로세스의 자원을 강제로 빼앗을 수 없다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;순환 대기 &lt;br /&gt; (Circular wait)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;자원을 기다리는 프로세스 간에 사이클이 형성되어 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;데드락-해결-방법&#34;&gt;데드락 해결 방법&lt;/h2&gt;
&lt;br /&gt;
&lt;h3 id=&#34;데드락-예방-deadlock-prevention&#34;&gt;데드락 예방 (Deadlock Prevention)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;자원 할당 시 &lt;strong&gt;데드락 발생의 4가지 &lt;mark style=&#34;background-color: lightblue&#34;&gt;조건 중 어느 하나가 만족되지 않도록&lt;/mark&gt; 하는 것&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만족되지 않도록 배제 할 수 있는 조건 살펴보기&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;조건&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;상호 배제 &lt;br /&gt; (Mutual exclusion)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;공유하면 안 되는 자원은 이 조건을 반드시 성립해야 해서 &lt;strong&gt;배제 불가능&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;보유 대기 &lt;br /&gt; (Hold and wait)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;자원을 &lt;strong&gt;요청할 때 자원을 가지지 않도록&lt;/strong&gt; 하면 된다. &lt;br /&gt; 방법1. 프로세스 시작 시 모든 필요한 자원을 할당받게 한다. &lt;br /&gt; 방법2. 자원이 필요한 경우 보유 자원을 모두 놓고 다시 요청한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;비선점 &lt;br /&gt; (No preemption)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;다른 자원을 요청할 때 자원을 보유한 자원을 빼앗을 수 있도록 한다. (&lt;strong&gt;선점&lt;/strong&gt;) &lt;br /&gt; 상태를 쉽게 저장하고 복구할 수 있는 자원에서 주로 사용한다. (CPU, memory)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;순환 대기 &lt;br /&gt; (Circular wait)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;모든 자원 유형에 할당 순서를 정해서 &lt;strong&gt;정해진 순서대로만 자원을 할당한다.&lt;/strong&gt; &lt;br /&gt; 예를 들어, 1번, 3번 자원을 획득해야지만 5번 자원을 획득할 수 있는 것이다.  &lt;br /&gt; 자원 A(순서 3)을 보유 중인데 자원 B(순서 1)을 할당받으려면 우선 자원 A를 해제해야한다.  &lt;br /&gt; 하지만, 자원에 대한 이용률(Utilization)이 낮아지고, Throughput 감소, Starvation이 발생할 수 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;데드락-회피-deadlock-avoidance&#34;&gt;데드락 회피 (Deadlock Avoidance)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자원 요청에 대한 부가적인 정보를 이용해서 자원 할당을 하면 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;데드락의 가능성이 없는지를 동적으로 검사해서 안전한 경우에만 자원을 할당&lt;/strong&gt;&lt;/mark&gt;하는 것이다.
&lt;ul&gt;
&lt;li&gt;가장 단순하고 일반적인 모델은, 프로세스들이 시작될 때, &lt;strong&gt;평생 필요로 하는 자원별 최대 사용량을 미리 선언&lt;/strong&gt;하도록 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/08-01-safeUnsafe.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;safe, unsaafe, deadlock&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;safe state&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;데드락이 없는 안전한 상태이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;safe sequence&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;특정한 순서로 자원의 할당, 실행, 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서라고 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsafe state&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;데드락이 있을 가능성이 있는 상태이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;2가지 회피 알고리즘
&lt;ul&gt;
&lt;li&gt;자원의 인스턴스가 1개일 때
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;자원 할당 그래프 알고리즘(Resource Allocation Grapeh algorithm)&lt;/strong&gt; 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;자원의 인스턴스가 여러개 일 때
&lt;ul&gt;
&lt;li&gt;(2) &lt;strong&gt;은행원 알고리즘(Banker&amp;rsquo;s algorithm)&lt;/strong&gt; 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;자원 할당 그래프 알고리즘&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/08-02-resourceAllocGraph.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;자원 할당 그래프&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$P_2$가 $R_2$자원을 할당받으면 사이클이 생기므로, $P_1$이 먼저 할당받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(2) &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;은행원 알고리즘&lt;/strong&gt;&lt;/mark&gt;
&lt;ul&gt;
&lt;li&gt;가정
&lt;ul&gt;
&lt;li&gt;모든 프로세스는 &lt;strong&gt;자원의 최대 사용량&lt;/strong&gt;을 미리 명시한다.&lt;/li&gt;
&lt;li&gt;그리고 자원을 최대 사용량만큼 할당 받은 프로세스는 작업이 끝나면 자원을 반납한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;방법
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;현재 가용 자원(Available)&lt;/strong&gt; 과 각 프로세스들이 &lt;strong&gt;작업을 완료하기 위해 필요한 자원(Need)&lt;/strong&gt; 을 비교하여, &lt;strong&gt;당장 작업을 마칠 수있는 프로세스부터 자원을 할당&lt;/strong&gt;하여, 프로세스가 작업을 완료하고 &lt;strong&gt;반환하는 자원을 다른 프로세스에게 다시 할당&lt;/strong&gt;하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;프로세스명&lt;/th&gt;
&lt;th&gt;Max&lt;/th&gt;
&lt;th&gt;Allocation&lt;/th&gt;
&lt;th&gt;Need&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P0&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;여기서 총 자원의 양이 12라고 한다면, 현재 Allocation은 9이므로, Available은 3이다.
&lt;ul&gt;
&lt;li&gt;이 때, Need가 Available을 넘지 않는 P1이 2만큼 할당 받을 수 있겠다.&lt;/li&gt;
&lt;li&gt;P1의 작업이 끝나고, 자원이 해제되어서 Available이 5가 되면, P0이 할당 받을 수 있다.&lt;/li&gt;
&lt;li&gt;P0의 작업이 끝나고, 자원이 해제되어서 Available이 10이 되면, P2가 할당 받을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;데드락-탐지-및-회복-deadlock-detection-and-recovery&#34;&gt;데드락 탐지 및 회복 (Deadlock Detection and Recovery)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데드락 발생은 허용하되, 그에 대한 detection 루틴을 두어 데드락 발생 시 recover하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;2가지 탐지 및 회복 알고리즘
&lt;ul&gt;
&lt;li&gt;자원의 인스턴스가 1개일 때
&lt;ul&gt;
&lt;li&gt;(1) 자원 할당 그래프의 변형인 &lt;strong&gt;대기 그래프(Wait-for graph)&lt;/strong&gt; 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;자원의 인스턴스가 여러개 일 때
&lt;ul&gt;
&lt;li&gt;(2) 은행원 알고리즘과 유사한 방법 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;대기 그래프(Wait-for graph)&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/08-03-waitForGraph.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;대기 그래프&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자원 타입의 노드를 제거하고 프로세스만으로 노드를 구성해서 사이클이 존재하는지 조사한다. ($n^2$)&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(2) &lt;strong&gt;은행원 알고리즘과 유사한 방법&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;은행원 알고리즘과 다른 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 프로세스가 &lt;strong&gt;실제로 요청한 자원(Request)&lt;/strong&gt; 개수를 사용한다. 이것은 추가적으로 요청할 수 있는 것(Need)과 다르다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;현재&lt;/strong&gt; 상태가 안전 상태(safe state)인지 확인하고, 불안정 상태(unsafe state)라면 데드락이라고 판단한 후 recovery 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;Recovery
&lt;ul&gt;
&lt;li&gt;방법 1. &lt;strong&gt;Process Termination&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;데드락과 연루된 프로세스를 모두 &lt;strong&gt;종료시킨다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;혹은 데드락과 연루된 프로세스를 하나씩 종료시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;방법 2. &lt;strong&gt;Resource Preemption&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;비용을 최소화하는 프로세스 &lt;strong&gt;희생양을 하나 찾아서, 자원을 뺏는다.&lt;/strong&gt; (safe state로 rollback해서 프로세스를 다시 시작한다. )&lt;/li&gt;
&lt;li&gt;동일한 프로세스가 희생양이 되는 starvation 문제가 발생할 수 있다. 따라서 rollback 횟수도 고려해서 선정해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;데드락-무시-deadlock-ignorance&#34;&gt;데드락 무시 (Deadlock Ignorance)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데드락을 시스템이 책임지지 않는 것이다. 데드락이 일어나지 않는다고 생각하고 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;아무런 조취도 취하지 않는다.&lt;/strong&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;만약 데드락이 발생하면, 시스템이 비정상적으로 작동한다는 것을 사람이 느끼고 직접 프로세스를 죽이도록 한다.&lt;/li&gt;
&lt;li&gt;UNIX, Windows 등의 대부분의 운영체제가 채택한 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 7. 프로세스 동기화</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-07/</link>
        <pubDate>Thu, 23 Jun 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-07/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프로세스-동기화-문제&#34;&gt;프로세스 동기화 문제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;데이터 접근 방식
&lt;ul&gt;
&lt;li&gt;한 저장 공간(메모리, 주소 공간)에 있는 데이터를 연산 실행 주체(CPU, 프로세스)가 읽어와서 연산을 한 후, 다시 저장 공간에 연산 결과를 저장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;연산 주체&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;저장 공간&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;컴퓨터&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;하드디스크&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CPU&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;메모리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;프로세스&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;프로세스의 주소 공간&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;하나의 저장 공간을 여러 주체가 접근하려고 할 때 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;경쟁 상태(Race Condition)&lt;/strong&gt;&lt;/mark&gt; 가 생길 가능성이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;운영체제에서&lt;/strong&gt; Race Condition이 발생하는 경우
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;커널 모드 수행 중에 인터럽트&lt;/strong&gt;가 발생해서 인터럽트 처리 루틴을 수행할 때
&lt;ul&gt;
&lt;li&gt;양쪽 모두 커널 코드를 수행하므로 커널 주소 공간을 공유하고 있다.&lt;/li&gt;
&lt;li&gt;해결책: &lt;strong&gt;커널 모드 수행 중일 때는 인터럽트를 비활성화한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;커널 모드 수행 중에 다른 프로세스가 시스템 콜&lt;/strong&gt;을 해서 문맥교환이 일어나고, 다른 프로세스가 커널 모드를 수행할 때
&lt;ul&gt;
&lt;li&gt;두 프로세스는 데이터를 공유하지 않지만, 시스템 콜을 하는 동안에는 커널 주소 공간에 접근할 수 있다.&lt;/li&gt;
&lt;li&gt;해결책: &lt;strong&gt;커널 모드 수행 중일 때는 CPU를 선점하지 않는다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) &lt;strong&gt;멀티 프로세서&lt;/strong&gt;에서 공유 메모리 내의 커널 데이터
&lt;ul&gt;
&lt;li&gt;해결책: 커널 내부의 공유 데이터에 접근할 때마다 그 데이터에 대한 &lt;strong&gt;lock/unlock&lt;/strong&gt;을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스 동기화(procee synchronization) 문제 = 병행 제어(concurrency control) 문제&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;공유 데이터에 여러 프로세서가 동시에 접근하는 상황(race condition)&lt;/strong&gt; 은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관성 유지를 위해서는 동시에 접근하는 프로세스 간에 실행 순서를 정하는 메커니즘이 필요하다. 즉, 동기화가 필요하다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;크리티컬-섹션&#34;&gt;크리티컬 섹션&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;크리티컬 섹션(critical section)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;각 프로세스의 코드 영역에 있는, &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;공유 데이터를 접근하는 코드&lt;/strong&gt;&lt;/mark&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;크릴티컬 섹션 문제의 해결법 충족 조건
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;상호 배제(Mutual Exclusion)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;어떤 프로세스 하나가 &lt;strong&gt;크리티컬 섹션을 수행 중이면 다른 모든 프로세스가 크리티컬 섹션에 들어갈 수 없어야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;진행(Progress)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;아무도 크리티컬 섹션에 없을 때, 어떤 프로세스가 크리티컬 섹션에 들어가고자 한다면, &lt;strong&gt;들어갈 수 있어야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유한 대기(Bounded Waiting)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;어떤 프로세스가 크리티컬 섹션에 들어가려고 &lt;strong&gt;요청하고 기다릴 때, 다른 모든 프로세스가 크리티컬 섹션에 들어갈 수 있는 횟수가 제한&lt;/strong&gt;되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 1&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 내차례(turn == 0)일 때까지 대기한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 다른 프로세스 차례(turn == 1)로 만든다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn&lt;/code&gt;이 내 차례이면 크리티컬 섹션에 들어간다.&lt;/li&gt;
&lt;li&gt;문제점
&lt;ul&gt;
&lt;li&gt;교대로만 들어갈 수 있다. 그래서 어떤 프로세스가 한 번만 크리티컬 섹션에 들어갈 때에는 다른 프로세스가 여러번 들어가길 원한다고 해도 들어갈 수가 없게 된다. (Progress 조건에 부합하지 않게 된다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 2&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;me&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 상대방의 플래그가 false일 때까지 대기한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;me&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// 내 작업이 끝났음을 알린다.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flag&lt;/code&gt;를 만들어서 상대방 값을 확인하고 크리티컬 섹션에 들어간다.&lt;/li&gt;
&lt;li&gt;문제점
&lt;ul&gt;
&lt;li&gt;두 프로세스 모두가 &lt;code&gt;flag[me] = true&lt;/code&gt; 인 상태로 무한정 대기할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 3 (Peterson&amp;rsquo;s Algorithm)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;me&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 크리티컬 섹션에 들어가겠다는 의사표명을 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;               &lt;span class=&#34;c1&#34;&gt;// 상대방의 턴으로 바꾼다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 상대방이 의사를 표명했고, 상대방 턴일 때 대기한다.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;turn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;me&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// 내 작업이 끝났음을 알린다.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;turn&lt;/code&gt;과 &lt;code&gt;flag&lt;/code&gt;를 둘 다 사용한다.
&lt;ul&gt;
&lt;li&gt;세 가지 조건을 모두 충족한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;문제점: &lt;strong&gt;Busy Waiting(= Spin Lock)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while(flag[other] == true &amp;amp;&amp;amp; turn = other)&lt;/code&gt;에서 계속 CPU와 메모리를 쓰면서 기다리게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;이런 과정을 하드웨어적으로 수행할 수 있도록 지원한다면 간단하게 해결 가능하다.
&lt;ul&gt;
&lt;li&gt;(1) &lt;code&gt;lock&lt;/code&gt;의 값을 읽고 (2) &lt;code&gt;lock&lt;/code&gt;의 값을 &lt;code&gt;true&lt;/code&gt;로 설정하는 것을 한 번에 수행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Test_and_set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// lock이 false이면 true로 설정하고 들어간다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;세마포어&#34;&gt;세마포어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;세마포어(Semephores)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;추상 자료형으로써, &lt;code&gt;integer&lt;/code&gt; 값을 가지며 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;자원의 개수&lt;/strong&gt;&lt;/mark&gt;를 나타낸다.&lt;/li&gt;
&lt;li&gt;두 가지 연산으로만 접근이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;세마포어 &lt;code&gt;S&lt;/code&gt;가 있을 때
&lt;ul&gt;
&lt;li&gt;(1) &lt;code&gt;P(S)&lt;/code&gt; 연산: 자원을 가져간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 자원이 없으면 기다린다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;(2) &lt;code&gt;V(S)&lt;/code&gt; 연산: 자원을 내놓는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;busy-waiting-spin-lock-방식&#34;&gt;Busy Waiting(= Spin Lock) 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;크리티컬 섹션 문제를 세마포어로 해결하면&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;section&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;br /&gt;
&lt;h3 id=&#34;block--wakeup-sleep-lock-방식&#34;&gt;Block &amp;amp; Wakeup(= Sleep Lock) 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;세마포어를 다음과 같이 정의한다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; → PCB → PCB → PCB &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 세마포어
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;proces&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 프로세스 대기(wait) 큐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Block()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;그 프로세스를 suspend 시키고 PCB를 세마포어의 대기(wait) 큐에 넣는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Wakeup(P)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;프로세스 P를 wakeup 시키고 PCB를 준비(ready) 큐로 옮긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;code&gt;P(S)&lt;/code&gt; 연산&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// 자원을 가져가기로 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 근데 자원이 없다.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;process&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 대기 큐에 넣고
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 대기한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;(2) &lt;code&gt;V(S)&lt;/code&gt; 연산&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 자원을 내놓기로 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 내놓아도 자원이 없다. 즉 자원이 없어서 잠들어 있는 프로세스가 있다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;remove&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;process&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 대기 큐에서 빼서
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;Wakeup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// 깨운다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;br /&gt;
&lt;h3 id=&#34;두-방식의-비교&#34;&gt;두 방식의 비교&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 Block &amp;amp; Wakeup이 좋다.&lt;/li&gt;
&lt;li&gt;크리티컬 섹션의 길이가 긴 경우, 그동안 기다리지 않는 Block &amp;amp; Wakeup이 더 좋다.&lt;/li&gt;
&lt;li&gt;하지만 크리티컬 섹션의 길이가 짧은 경우에는, block과 wakeup 상태를 바꾸는 데 오버헤드가 들기 때문에 Busy Wait가 더 좋을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;세마포어의-종류&#34;&gt;세마포어의 종류&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;Counting Semaphore&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;도메인이 0이상인 임의의 정수값이다.&lt;/li&gt;
&lt;li&gt;자원을 카운팅하는 데 쓰인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;Binary Semaphore(=mutex)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;0과 1값만 가질 수 있는 세마포어이다.&lt;/li&gt;
&lt;li&gt;주로 상호 배제 (lock/unlock)에 쓰인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;교착상태와-기아&#34;&gt;교착상태와 기아&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;교착상태(Deadlock)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;둘 이상의 프로세스가 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;서로 상대방이 가진 자원을 얻기 위해 무한히 기다리는&lt;/strong&gt;&lt;/mark&gt; 현상이다.&lt;/li&gt;
&lt;li&gt;예: Dining-Philosophers problem&lt;/li&gt;
&lt;li&gt;해결책: 자원을 얻을 수 있는 순서를 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;기아(Starvation)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 suspend 당하고 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;세마포어 큐에서 영원히 나갈 수 없는&lt;/strong&gt;&lt;/mark&gt; 현상을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;고전적인-동기화-문제들&#34;&gt;고전적인 동기화 문제들&lt;/h2&gt;
&lt;br /&gt;
&lt;h3 id=&#34;bounded-buffer-problem-producer-consumer-problem&#34;&gt;Bounded-Buffer problem (Producer-Consumer problem)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;공유되는 메모리의 버퍼 크기가 유한한 환경에서, 자원을 생산하는 Producer와 사용하는 Consumer가 여럿일 때 발생하는 문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;공유 데이터
&lt;ul&gt;
&lt;li&gt;버퍼 및 버퍼 조작 변수(empty/full 버퍼의 시작 위치)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동기화 변수
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutex&lt;/code&gt;: 상호 배제 필요
&lt;ul&gt;
&lt;li&gt;동일 버퍼에 작업하지 않기 위해 Binary Semaphore가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;full&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt;: 가용 자원을 세는 것이 필요
&lt;ul&gt;
&lt;li&gt;한정적인 버퍼가 모두 사용되었을 때를 대비해서 Counting Semaphore가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;full&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Producer 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;produce&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 자원 x를 만든다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 자원을 만들만한 빈 버퍼가 있는지 확인하고 획득한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 해당 버퍼에 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 버퍼에 lock을 푼다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// 생산된 자원의 개수를 늘린다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Consumer 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// 자원이 만들어진 버퍼가 있는지 확인하고 획득한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 해당 버퍼에 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;remove&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 버퍼에 lock을 푼다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 사용한 자원의 개수를 늘린다.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;consume&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;readers-and-writers-problem&#34;&gt;Readers and Writers problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한 프로세스가 공유 데이터 DB를 Write 중일 떄는 다른 모든 프로세스가 접근할 수 없다. 하지만 Read는 여럿이서 동시에 해도 되는 경우에 발생하는 문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;공유 데이터
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DB 자체&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readCount&lt;/code&gt;: 현재 DB에 접근 중인 Reader의 수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동기화 변수
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutex&lt;/code&gt;: 공유 데이터 readCount에 접근 제어를 위해&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db&lt;/code&gt;: Reader와 Writer가 DB에 올바르게 접근하도록 하기 위해&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;DB&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;자체&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Writer 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 공유 데이터를 사용하기 위해 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;writing&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DB&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// lock을 푼다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Reader 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// readCount를 사용하기 위해 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 읽기로 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 최초의 Reader라면 Write를 금하기 위해 공유 데이터에 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// readCount lock을 푼다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;reading&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DB&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;readCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 모든 Reader가 다 읽었으면 Writer가 쓸 수 있게 공유 데이터의 lock을 푼다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기아(Starvation)&lt;/strong&gt; 문제가 발생할 수 있다.
&lt;ul&gt;
&lt;li&gt;Reader가 계속해서 들어오면 Writer는 영영 DB에 접근할 수 없다.&lt;/li&gt;
&lt;li&gt;Reader의 수를 제한해서 해결할 수 있겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;dining-philosophers-problem&#34;&gt;Dining-Philosophers problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;생각하다가 배고프면 밥을 먹는 5명의 철학자들이 원탁에 둘러 앉았다. 젓가락을 양쪽 사람과 하나씩 공유하고 있을 때 발생하는 문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;동기화 변수&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 1로 초기화되어 있다. 즉, 한 번에 한 명만 쓸 수 있다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Philosopher 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 왼쪽 젓가락을 잡는다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 오른쪽 젓가락을 잡는다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chopstick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;think&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;교착상태(Deadlock)&lt;/strong&gt; 문제가 발생할 수 있다.
&lt;ul&gt;
&lt;li&gt;모든 Philosopher가 동시에 배가 고파서 왼쪽 젓가락을 집은 경우. 아무도 식사를 할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;해결 방법
&lt;ul&gt;
&lt;li&gt;(1) 5명 중에 배고픈 4명만 동시에 식탁에 앉을 수 있게 한다.&lt;/li&gt;
&lt;li&gt;(2) 젓가락 2개를 모두 집을 수 있을 때만 젓가락을 집을 수 있게 한다.&lt;/li&gt;
&lt;li&gt;(3) 짝수 Philosopher는 왼쪽, 홀수 Philosopher는 오른쪽 젓가락부터 집을 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;동기화 변수&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thinking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hungry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 젓가락 2개를 모두 집을 수 있는가 (처음은 권한 없음)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;semaphore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Philosopher의 상태를 바꿀 수 있는 권한 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Philosopher 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;pickup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;putdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;think&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pickup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 상태를 변경하기 위해 mutex에 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hungry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 상태 변경을 완료해서 mutex를 unlock 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 젓가락 2개를 집을 수 없다면 기다린다. 가능하면 lock을 건다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;putdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thinking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 왼쪽 철학자에 대해 test를 해서 젓가락을 준다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 오른쪽 철학자에 대해 test를 해서 젓가락을 준다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 젓가락 2개를 모두 집을 수 있는지 테스트한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 왼쪽 철학자가 밥을 먹지 않고
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hungry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// 내가 지금 배고프고
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 오른쪽 철학자가 밥을 먹지 않을 때 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 밥먹는 권한을 갖는다. unlock을 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;모니터&#34;&gt;모니터&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;세마포어의 문제점
&lt;ul&gt;
&lt;li&gt;코딩하기 힘들다.&lt;/li&gt;
&lt;li&gt;한번의 실수가 모든 시스템에 치명적인 영향을 준다.&lt;/li&gt;
&lt;li&gt;정확성을 검증하는 것이 어렵다.&lt;/li&gt;
&lt;li&gt;자발적 협력이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;모니터(Monitor)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;동시 수행중인 프로세스 사이에서 추상 데이터 형식의 안전한 공유를 보장하기 위해 만들어진, high-level synchronization construct이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;monitor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitor_name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 공유 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;shared&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;declaration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 공유 변수에 접근할 수 있는 함수를 구현한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;procedure&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;P1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(...)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;procedure&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;P2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(...)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;procedure&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;P3&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(...)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 초기화 함수 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;initialization&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;모니터 내에서는 한 번에 하나의 프로세스만 활동 가능하다.&lt;/li&gt;
&lt;li&gt;프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없다.&lt;/li&gt;
&lt;li&gt;프로세스가 모니터 안에서 기다릴 수 있게 하기 위해서 &lt;code&gt;condition variable&lt;/code&gt;을 사용한다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;condition variable&lt;/code&gt;은 &lt;code&gt;wait()&lt;/code&gt;과 &lt;code&gt;signal()&lt;/code&gt; 연산으로만 접근 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;signal()&lt;/code&gt;로 빠져나갈 수 있을 때까지 계속 suspend되게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signal()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;suspend된 프로세스 중에 하나의 프로세스가 빠져나갈 수 있게 한다.&lt;/li&gt;
&lt;li&gt;suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;bounded-buffer-problem&#34;&gt;Bounded-Buffer problem&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;monitor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bounded_buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 자신의 큐에 프로세스를 매달아서 wait() 혹은 signal()을 한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;produce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;there&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;no&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 비어 있는 버퍼를 줄서서 기다린다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 혹시 생성된 버퍼가 없어서 기다리는 프로세스가 있는지 알아보고 깨워준다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;consume&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;there&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;no&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;full&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;remove&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;br /&gt;
&lt;h3 id=&#34;dining-philosophers-problem-1&#34;&gt;Dining-Philosophers problem&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;monitor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dining_philosopher&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thinking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hungry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pickup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hungry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 밥 먹을 수 없으면 대기.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;putdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thinking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 왼쪽 철학자에게 젓가락을 준다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 오른쪽 철학자에게 젓가락을 준다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 젓가락 2개를 모두 집을 수 있는지 테스트한다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 왼쪽 철학자가 밥을 먹지 않고
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hungry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// 내가 지금 배고프고
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// 오른쪽 철학자가 밥을 먹지 않을 때 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eating&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 밥을 먹을 수 있게 한다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thinking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Each Philosopher:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;pickup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;putdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;think&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 6. CPU 스케줄링</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-06/</link>
        <pubDate>Thu, 16 Jun 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-06/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu-버스트와-io-버스트&#34;&gt;CPU 버스트와 I/O 버스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로그램 실행과 관련된 기계어 명령들
&lt;ul&gt;
&lt;li&gt;CPU 내에서 수행되는 명령: Add 명령&lt;/li&gt;
&lt;li&gt;메모리 접근을 수행하는 명령: Load, Store 명령&lt;/li&gt;
&lt;li&gt;메모리를 접근하는 명령&lt;/li&gt;
&lt;li&gt;입출력을 동반하는 명령 → 운영체제를 통해서만 가능한 특권명령&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사용자 프로그램이 수행되는 과정은 CPU 작업와 I/O 작업의 반복으로 구성된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU 버스트&lt;/strong&gt;&lt;/mark&gt;: 사용자 프로그램이 &lt;u&gt;CPU를 직접 가지고 빠른 명령을 수행&lt;/u&gt;하는 단계&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;I/O 버스트&lt;/strong&gt;&lt;/mark&gt;: &lt;u&gt;I/O 요청이 발생해서 커널에 의해 입출력 작업을 진행&lt;/u&gt;하는 비교적 느린 단계&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU 바운드 프로세스&lt;/strong&gt;&lt;/mark&gt;: I/O 작업이 거의 없어서 CPU 버스트가 길게 나타나는 프로세스이다.
&lt;ul&gt;
&lt;li&gt;→ 계산 위주의 프로그램&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;I/O 바운드 프로세스&lt;/strong&gt;&lt;/mark&gt;: I/O 요청이 빈번해서 CPU 버스트가 짧게 나타나는 프로세스이다.
&lt;ul&gt;
&lt;li&gt;→ 대화형 프로그램(interactive program)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동일한 시스템 내부에서 &lt;strong&gt;CPU 바운드 프로세스와 I/O 바운드 프로세스가 함께 섞여서 실행되기 때문에&lt;/strong&gt; CPU 스케줄링이 필요하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 프로세스는 짧은 CPU 바운드를 가진다. 따라서 I/O 바운드 프로세스의 우선순위를 높여주면, 대화형 프로세스의 빠른 응답성 제공과 I/O 장치의 이용률을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu-스케줄러&#34;&gt;CPU 스케줄러&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 스케줄러(scheduler)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;준비 상태에 있는 프로세스들 중에서  &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;어떤 프로세스에게 CPU를 할당할지&lt;/strong&gt;&lt;/mark&gt; 결정하는 운영체제의 코드이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;CPU 스케줄러가 호출되는 예시
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;Running → Blocked&lt;/strong&gt; : I/O 요청하는 시스템 콜&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;Running → Ready&lt;/strong&gt; : 타이머 인터럽트&lt;/li&gt;
&lt;li&gt;(3) &lt;strong&gt;Blocked → Ready&lt;/strong&gt; : I/O 완료로 인터럽트 (우선순위가 높아서 바로 CPU를 얻는 경우)&lt;/li&gt;
&lt;li&gt;(4) &lt;strong&gt;Terminate&lt;/strong&gt; : 프로세스 종료&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;비선점형(nonpreemptive) 방식&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 CPU를 스스로 반납하기 전까지는 &lt;u&gt;빼앗기지 않는다.&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;(1), (4)의 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;선점형(preemptive) 방식&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스에게 할당된 CPU를 강제로 &lt;u&gt;빼앗을 수 있다.&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;(2), (3)의 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;디스패처&#34;&gt;디스패처&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;디스패처(dispatcher)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU 스케줄러가 어떤 프로세스에게 CPU를 할당할지 결정하고 나면, 실제로 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU를 이양하기 위해 환경설정&lt;/strong&gt;&lt;/mark&gt;을 하는 운영체제의 코드를 말한다.&lt;/li&gt;
&lt;li&gt;현재 수행 중이던 프로세스의 문맥(context)을 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한다. 그리고 시스템 상태를 사용자 모드로 전환해서 사용자 프로그램에게 CPU의 제어권을 넘긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;디스패치 지연시간(dispatch latency)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;디스패쳐가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 말한다.&lt;/li&gt;
&lt;li&gt;이것은 대부분 &lt;strong&gt;문맥교환의 오버헤드&lt;/strong&gt;에 해당한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;스케줄링의-성능-평가&#34;&gt;스케줄링의 성능 평가&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;시스템 관점
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;CPU 이용률(CPU utilization)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;전체 시간에서 &lt;u&gt;CPU가 일을 한 시간&lt;/u&gt;의 비율&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;처리량(throughput)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;주어진 시간 동안 &lt;u&gt;프로세스 몇 개를 끝마쳤는지&lt;/u&gt; (CPU 버스트를 완료한 프로세스의 개수)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용자 관점
&lt;ul&gt;
&lt;li&gt;(3) &lt;strong&gt;소요 시간(turnaround time)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 &lt;u&gt;CPU를 요청한 시점 ~ CPU 버스트를 완료&lt;/u&gt;하는데까지 걸린 시간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(4) &lt;strong&gt;대기 시간(waiting time)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU 버스트 기간 중 프로세스가 &lt;u&gt;준비 큐에서 CPU를 얻기 위해 기다린 시간의 합&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;시분할 시스템에서는 타이머 인터럽트를 사용하므로, 한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러번 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(5) &lt;strong&gt;응답 시간(response time)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 &lt;u&gt;준비 큐에 들어온 후 ~ 첫 번째 CPU를 획득&lt;/u&gt;하기까지 기다린 시간&lt;/li&gt;
&lt;li&gt;타이머 인터럽트가 빈번히 발생할 수록 처음 CPU를 획득하기까지 걸리는 시간은 줄어들겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;스케줄링-알고리즘&#34;&gt;스케줄링 알고리즘&lt;/h2&gt;
&lt;h3 id=&#34;선입선출fcfs-스케줄링&#34;&gt;선입선출(FCFS) 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;First-Come First-Served&lt;/li&gt;
&lt;li&gt;준비 큐에 도착한 시간 순서대로( &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU를 먼저 요청한 프로세스에게&lt;/strong&gt;&lt;/mark&gt;) CPU를 할당하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;콘보이 현상(Convoy effect)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;CPU 버스트가 긴 작업이 먼저&lt;/u&gt; 들어오면, CPU를 잠깐만 사용하면 준비 큐를 떠나 I/O작업을 수행할 수 있는&lt;u&gt;(CPU 버스트가 짧은) 다수의 프로세스들이 계속 기다려야 하는 상황&lt;/u&gt;이 생긴다.&lt;/li&gt;
&lt;li&gt;먼저 도착한 프로세스의 CPU 버스트 기간에 따라 평균 대기시간이 크게 달라진다.&lt;/li&gt;
&lt;li&gt;평균 대기시간(waiting time)이 길어진다.&lt;/li&gt;
&lt;li&gt;I/O 장치의 이용률이 하락한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;프로세스&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CPU 버스트 시간&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_1$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$12$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_2$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$3$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_3$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$3$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;대기 시간: $P_1 = 0$, $P_2 = 12$, $P_3 = 15$&lt;/li&gt;
&lt;li&gt;평균 대기 시간: $(0 + 12 + 15) / 3 = 9$&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;최단작업-우선sjf-스케줄링&#34;&gt;최단작업 우선(SJF) 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Shortest-Job First&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU 버스트가 가장 짧은 프로세스에게&lt;/strong&gt;&lt;/mark&gt; 제일 먼저 CPU를 할당하는 방식이다.&lt;/li&gt;
&lt;li&gt;선점형(Shortest Remaining Time First; SRTF) 과 비선점형 방식으로 구현할 수 있다.
&lt;ul&gt;
&lt;li&gt;선점형의 경우, 어떤 프로세스가 CPU를 할당받고 수행 중이더라도, CPU 버스트 시간이 더 짧은 프로세스가 도착하면 빼앗기는 방식이다.&lt;/li&gt;
&lt;li&gt;프로세스들이 준비 큐에 도착하는 시간이 불규칙한 환경에서는 선점형 방식이 평균 대기시간을 최소화하는 최적의 알고리즘이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;프로세스&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;도착 시간&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;CPU 버스트 시간&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_1$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$0$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$14$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_2$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$4$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$8$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_3$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$8$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$2$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$P_4$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$10$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$8$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;비선점형 방식 평균 대기시간: $(0 + 12 + 6 + 14) / 4 = 8$&lt;/li&gt;
&lt;li&gt;선점형 방식 평균 대기시간: $(18 + 2 + 0 + 4) / 4 = 6$&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;평균 대기시간을 가장 짧게&lt;/strong&gt; 하는 최적 알고리즘(optimal algorithm)이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기아 현상(starvation)&lt;/strong&gt; 이 발생한다.
&lt;ul&gt;
&lt;li&gt;CPU 버스트가 짧은 프로세스가 계속 도착하면 &lt;u&gt;CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못하는&lt;/u&gt; 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU 버스트 시간을 미리 예측할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;CPU 버스트 시간 예측 방법
&lt;ul&gt;
&lt;li&gt;과거의 CPU 버스트 시간을 통해 계산된다. 더 오래된 과거일 수록 그 영향력이 적어지도록 반영한다.&lt;/li&gt;
&lt;li&gt;$$ T_n+1 = \alpha t_n + (1 - \alpha)T_n$$&lt;/li&gt;
&lt;li&gt;$t_n$은 $n$번째 실제 CPU 버스트 시간이고, $T_n$은 $n$번째 CPU 버스트의 예측시간이다.&lt;/li&gt;
&lt;li&gt;$\alpha$는 $0 ~ 1$ 사이의 상수로 위의 두 요소를 어느 정도씩 반영할지 조절하는 매개변수이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;우선순위-스케줄링&#34;&gt;우선순위 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;우선순위가 가장 높은 프로세스에게&lt;/strong&gt;&lt;/mark&gt; 제일 먼저 CPU를 할당하는 방식이다.&lt;/li&gt;
&lt;li&gt;우선순위 값(priority number)은 그 값이 작을수록 우선순위가 높다.&lt;/li&gt;
&lt;li&gt;SJF 스케줄링은 우선순위 스케줄링의 일종이라고 볼 수 있다.&lt;/li&gt;
&lt;li&gt;선점형과 비선점형 방식으로 구현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;기아 현상이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;해결 방안: &lt;strong&gt;노화(aging) 기법&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;기다리는 &lt;u&gt;시간이 길어지면 우선순위를 조금씩 높여서&lt;/u&gt; 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;라운드-로빈-스케줄링&#34;&gt;라운드 로빈 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Round Robin&lt;/li&gt;
&lt;li&gt;각 프로세스가 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간( &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;할당시간; timequantum&lt;/strong&gt;&lt;/mark&gt;)을 주는 방식이다.
&lt;ul&gt;
&lt;li&gt;할당 시간이 너무 길면, FCFS와 같은 결과를 나타내며,&lt;/li&gt;
&lt;li&gt;할당 시간이 너무 짧으면, 프로세스가 빈번하게 교체되어 문맥교환의 오버헤드가 커진다.&lt;/li&gt;
&lt;li&gt;일반적으로 $10$ ~ $100 ms$(밀리초) 정도로 설정한다.&lt;/li&gt;
&lt;li&gt;타이머 인터럽트를 사용해서 CPU를 회수한다.&lt;/li&gt;
&lt;li&gt;SJF보다 평균 대기 시간은 길지만, 응답시간은 더 짧다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록한다. (공정하다)&lt;/li&gt;
&lt;li&gt;대화형 프로세스의 빠른 응답시간을 보장한다.
&lt;ul&gt;
&lt;li&gt;$n$개의 프로세스가 준비 큐에 있고 할당 시간이 $q$라고 하면, 모든 프로세스는 $(n-1)q$시간 이내에 적어도 한 번은 CPU를 할당 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;다단계-큐&#34;&gt;다단계 큐&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;muti-level queue&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;준비 큐를 여러 개&lt;/strong&gt;&lt;/mark&gt;로 분할해서 관리하는 방식이다.&lt;/li&gt;
&lt;li&gt;일반적으로, 전위 큐(foreground queue)와 후위 큐(background queue)로 분할하여 운영한다.
&lt;ul&gt;
&lt;li&gt;전위 큐: 대화형 작업을 담는다. 라운드 로빈 스케줄링을 사용한다.&lt;/li&gt;
&lt;li&gt;후위 큐: 계산 위주의 작업을 담는다. FCFS 스케줄링을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;어느 큐에게 먼저 CPU를 할당할 것인가?
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;고정 우선순위 방식(fixed priority scheduling)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;큐에 고정적인 우선순위를 적용한다. 항상 전위 큐에 있는 프로세스에게 CPU가 먼저 할당된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;타임 슬라이스(time slice) 방식&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;각 큐에 CPU 시간을 적절한 비율로 할당한다. 예를 들면 전위 큐는 80%, 후위 큐는 20%이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;다단계-피드백-큐&#34;&gt;다단계 피드백 큐&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;multi-level feedback queue&lt;/li&gt;
&lt;li&gt;준비 큐를 여러 개로 둔다는 점은 다단계 큐와 동일하나, 프로세스가  &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;하나의 큐에서 다른 큐로 이동 가능하다&lt;/strong&gt;&lt;/mark&gt;는 점이 다르다.
&lt;ul&gt;
&lt;li&gt;대표적인 방식은, 라운드 로빈을 사용하면서 할당시간이 5, 10인 준비 큐가 있고, 그다음에 FCFS 준비 큐가 있는 것이다.&lt;/li&gt;
&lt;li&gt;프로세스의 CPU 작업시간을 다단계로 분류함으로써, 작업시간이 짧은 프로세스일 수록 더 빠른 서비스가 가능해지며, 작업시간이 긴 프로세스에 대해서는 문맥교환 없이 CPU 작업에만 열중할 수 있는 FCFS 방식을 채택할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;정의 요소들
&lt;ul&gt;
&lt;li&gt;큐의 수&lt;/li&gt;
&lt;li&gt;각 큐의 스케줄링 알고리즘&lt;/li&gt;
&lt;li&gt;프로세스를 상위 큐로 승격시키는 기준&lt;/li&gt;
&lt;li&gt;프로세스를 하위큐로 강등시키는 기준&lt;/li&gt;
&lt;li&gt;프로세스가 도착했을 때 들어갈 큐를 결정하는 기준&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;다중처리기-스케줄링&#34;&gt;다중처리기 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;multi-processor system&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU가 여러 개&lt;/strong&gt;&lt;/mark&gt;인 시스템인 다중처리기 시스템에서 사용하는 스케줄링이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;Homogeneous processor인 경우
&lt;ul&gt;
&lt;li&gt;큐에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;특정 CPU에서 수행되어야 하는 프로세스가 있는 경우
&lt;ul&gt;
&lt;li&gt;각 CPU별로 줄 세우기를 할 수 있겠다.&lt;/li&gt;
&lt;li&gt;하지만 그렇게 되면 특정 CPU에 작업이 편중되는 현상이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;그래서 각 CPU별로 부하가 적절히 분산되도록 하는 &lt;strong&gt;부하균형(load balancing)&lt;/strong&gt; 메커니즘을 필요로 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;대칭형 다중처리(symmetric multi-processing; SMP)
&lt;ul&gt;
&lt;li&gt;각 CPU가 알아서 스케줄링을 결정하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비대칭형 다중처리(asymmetric multi-processing)
&lt;ul&gt;
&lt;li&gt;하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고, 나머지 CPU는 거기에 따라 움직이는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;실시간-스케줄링&#34;&gt;실시간 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작업의 &lt;strong&gt;데드라인&lt;/strong&gt;이 정해져 있어서 그 안에 반드시 처리해야하는 실시간 시스템(real-time system)에 사용하는 방식이다.
&lt;ul&gt;
&lt;li&gt;경성 실시간 시스템(hard real-time system): 데드라인 안에 반드시 끝내야 하는 시스템&lt;/li&gt;
&lt;li&gt;연성 실시간 시스템(soft real-time system): 데드라인을 지키지 못했다고 해서 위험한 상황이 발생하는 건 아닌 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EDF(Earlist Deadline First) 스케줄링&lt;/strong&gt;을 주로 사용한다.
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;데드라인이 얼마 남지 않은 요청을 먼저 처리&lt;/strong&gt;&lt;/mark&gt;하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;스레드-스케줄링&#34;&gt;스레드 스케줄링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Global scheduling&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kernel level thread&lt;/strong&gt;의 경우&lt;/li&gt;
&lt;li&gt;일반적인 프로세스와 마찬가지로 커널의  &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;단기 스케줄러&lt;/strong&gt;&lt;/mark&gt;가 어떤 스레드를 스케줄링할지 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Local scheduling&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;User level thread&lt;/strong&gt;의 경우&lt;/li&gt;
&lt;li&gt;사용자 수준의  &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;스레드 라이브러리&lt;/strong&gt;&lt;/mark&gt;에 의해 어떤 스레드를 스케줄링할지 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;스케줄링-알고리즘의-평가&#34;&gt;스케줄링 알고리즘의 평가&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) 큐잉모델(queueing model)
&lt;ul&gt;
&lt;li&gt;이론가들이 수행하는 방식이다.&lt;/li&gt;
&lt;li&gt;확률 분포로 주어지는 도착률(arrival rate)과 처리율(service rate)을 가지고 수학적 계산을 통해 각종 성능지표를 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) 시뮬레이션(simulation)
&lt;ul&gt;
&lt;li&gt;구현가들이 수행하는 방식이다.&lt;/li&gt;
&lt;li&gt;실제로 코드를 수정해서 커널을 컴파일한 후 수행시켜보고 실행시간을 측정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) 구현 및 실측(implementation &amp;amp; measurement)
&lt;ul&gt;
&lt;li&gt;가상으로 CPU 스케줄링 프로그램(모의 프로그램)을 작성해서 어떤 결과가 나오는지 확인하는 방식이다.&lt;/li&gt;
&lt;li&gt;입력값은 가상일 수도 있고, 실제 시스템에서 추출한 입력값(트레이스; trace)일 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 5. 프로세스 관리</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-05/</link>
        <pubDate>Thu, 09 Jun 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-05/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프로세스&#34;&gt;프로세스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;프로세스(process)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 중인 프로그램(program in execution)을 뜻한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스의 &lt;strong&gt;문맥(context)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 &lt;u&gt;현재 어떤 상태&lt;/u&gt;에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보이다.&lt;/li&gt;
&lt;li&gt;프로세스가 CPU를 다시 획득해서 명령 수행을 재개하려면 문맥이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;종류&lt;/th&gt;
&lt;th&gt;내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;프로세스의 주소 공간&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;코드, 데이터, 스택으로 구성된 자신만의 독자적 주소 공간&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;하드웨어 문맥&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;프로그램 카운터값 &lt;br /&gt;각종 레지스터에 저장하고 있는 값&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;커널 상의 문맥&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;PCB &lt;br /&gt;커널 스택&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;프로세스의-상태&#34;&gt;프로세스의 상태&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로세스는 항상 다음 중 어느 한 상태에 머물러 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;상태&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;준비&lt;br /&gt;(ready)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;메모리를 획득해서, CPU만 보유하면 당장 명령을 실행할 수 있는 상태&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;실행&lt;br /&gt;(running)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CPU를 보유하고 기계어 명령을 실행하고 있는 상태&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;봉쇄&lt;br /&gt;(blocked, wait, sleep)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태 &lt;br /&gt;(예: 입출력 작업 진행 중)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;시작&lt;br /&gt;(new)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;완료&lt;br /&gt;(terminated)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;중지&lt;br /&gt;(suspended, stopped)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;외부적인 이유로 프로세스의 수행이 정지된 상태 &lt;br /&gt;메모리를 조금도 보유하지 않고 디스크에 통째로 스왑 아웃된 상태로 존재한다. &lt;br /&gt;(이어서&amp;hellip;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;프로세스-제어블록&#34;&gt;프로세스 제어블록&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/05-01-pcb.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;PCB의 구조&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스 제어블록(Process Control Block; PCB)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;운영체제가 프로세스들을 관리하기 위해 프로세스의 정보를 담는 커널 내의 자료구조이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;종류&lt;/th&gt;
&lt;th&gt;내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;운영체제가 관리상 사용하는 정보&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;프로세스 번호&lt;/strong&gt; : 프로세스 고유 번호 &lt;br /&gt;&lt;strong&gt;프로세스 상태&lt;/strong&gt; : 준비, 실행, 봉쇄 등의 상태 &lt;br /&gt;&lt;strong&gt;스케줄링 정보, 우선순위&lt;/strong&gt; : CPU 스케줄링을 위해&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU 수행 관련 하드웨어 값&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;프로그램 카운터 값&lt;/strong&gt; : 다음에 수행할 명령의 위치 &lt;br /&gt;&lt;strong&gt;레지스터 값&lt;/strong&gt; : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;메모리 관련&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;코드, 데이터, 스택의 위치 정보&lt;/strong&gt; : 메모리 할당을 위해&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;파일 관련&lt;/td&gt;
&lt;td&gt;프로세스가 오픈한 파일 정보&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;문맥-교환&#34;&gt;문맥 교환&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;문맥 교환(context switch)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 것&lt;/u&gt;이다.&lt;/li&gt;
&lt;li&gt;이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 작업이 이루어진다.&lt;/li&gt;
&lt;li&gt;한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록에 기록되어 있다.&lt;/li&gt;
&lt;li&gt;문맥 교환에 소요되는 시간은 오버헤드이기 때문에 적절한 타이머의 CPU 할당 시간을 정하는 것이 중요하겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;준비 상태에 있는 프로세스가 실행 상태로 되면서 CPU의 제어권이 넘어가는 과정을 &lt;strong&gt;CPU 디스패치(dispatch)&lt;/strong&gt; 라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;문맥교환이 발생하는 경우
&lt;ul&gt;
&lt;li&gt;타이머 인터럽트 발생&lt;/li&gt;
&lt;li&gt;실행 중이던 프로세스의 입출력 요청&lt;/li&gt;
&lt;li&gt;다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;문맥교환이 아닌 경우
&lt;ul&gt;
&lt;li&gt;사용자 프로세스 A의 인터럽트 또는 시스템 콜에 의해 사용자 모드에서 커널 모드로 실행 모드가 바뀐다. 커널 모드에서 인터럽트 처리루틴 또는 시스템 콜 함수를 실행한다. 그리고 다시 문맥 교환 없이 사용자 프로세스 A의 사용자 모드로 되돌아 온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;상태-관리-큐들&#34;&gt;상태 관리 큐들&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;커널의 주소 영역 중 &lt;strong&gt;데이터&lt;/strong&gt; 영역에 다양한 큐(queue)를 두어 프로세스들의 상태를 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;작업 큐&lt;br /&gt;(job queue)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;시스템 내의 모든 프로세스를 관리하기 위한 큐 &lt;br /&gt;가장 넓은 개념이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;준비 큐&lt;br /&gt;(ready queue)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CPU를 할당 받기 위해 준비 상태에 있는 프로세스들을 줄세우기 위한 큐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;장치 큐&lt;br /&gt;(device queue)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 있는 큐 &lt;br /&gt;(예: 디스크 입출력 서비스를 받기 위해 기다리는 프로세스들)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;자원 큐&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;소프트웨어 자원을 기다리는 경우 &lt;br /&gt;(예: 공유 데이터에 대한 접근 제어를 위한 큐)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;스케줄러들&#34;&gt;스케줄러들&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/05-01-processStateDiagram.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;프로세스 상태 변화도&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스케줄러(scheduler)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;스케줄러&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;장기 스케줄러 &lt;br /&gt;= 작업 스케줄러 (job scheduler)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;어떤 프로세스를 &lt;u&gt;준비 큐&lt;/u&gt;에 진입시킬지 결정한다. &lt;br /&gt;즉, 프로세스에게 &lt;u&gt;메모리를 할당하는 문제&lt;/u&gt;에 관여하므로, 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절하는 역할을 한다. &lt;br /&gt;현대의 시분할 시스템에서는 장기 스케줄러가 없고, 실행되면 무조건 ready 상태로 된다. 따라서 degree of multiprogramming은 &lt;u&gt;중기 스케줄러가 대신&lt;/u&gt;한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;단기 스케줄러 &lt;br /&gt;= CPU 스케줄러&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;어떤 프로세스를 &lt;u&gt;실행 상태&lt;/u&gt;로 만들지 결정한다. &lt;br /&gt;즉, 프로세스에게 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;CPU를 할당하는 문제&lt;/strong&gt;&lt;/mark&gt;에 관여한다. &lt;br /&gt;시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;중기 스케줄러 &lt;br /&gt;= swapper&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;여유공간 마련을 위해 &lt;u&gt;프로세스를 통째로 메모리에서 디스크로 쫒아낸다. (스왑 아웃; swap out)&lt;/u&gt; &lt;br /&gt;0순위로 스왑 아웃되는 프로세스는 봉쇄 상태에 있는 프로세스들이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(이어서&amp;hellip;) 중기 스케줄러의 등장으로 프로세스의 상태가 추가된다.&lt;/li&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;중지(suspended, stopped)&lt;/strong&gt;&lt;/mark&gt;
&lt;ul&gt;
&lt;li&gt;외부적인 이유로 프로세스의 수행이 정지된 상태이다.&lt;/li&gt;
&lt;li&gt;메모리를 조금도 보유하지 않고 디스크에 통째로 &lt;u&gt;스왑 아웃된 상태로 존재&lt;/u&gt;한다.&lt;/li&gt;
&lt;li&gt;예: 사용자가 프로그램을 일시 정지한 경우, 메모리에 너무 많은 프로세스가 올라와 있어서 시스템이 프로세스를 잠시 중단시킨 경우&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;중지준비(suspended ready)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;중지봉쇄(suspended block)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;봉쇄와 중지의 차이점
&lt;ul&gt;
&lt;li&gt;봉쇄: 자신이 요청한 event가 만족되면 Ready 상태가 된다.&lt;/li&gt;
&lt;li&gt;중지: 외부에서 resume해주어야 Active 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;스레드&#34;&gt;스레드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스레드(thread; lightweight process)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU를 수행하는 단위&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;스레드가-가지고-있는-것&#34;&gt;스레드가 가지고 있는 것&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구분&lt;/th&gt;
&lt;th&gt;내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;스레드가 독자적으로 갖고 있는 것들 &lt;br /&gt;= CPU 수행을 위한 것들&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;프로그램 카운터 값 &lt;br /&gt;레지스터 값 &lt;br /&gt;스택&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;스레드가 동료 스레드와 공유하는 부분&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;코드 영역&lt;br /&gt;데이터 영역 &lt;br /&gt;운영체제 자원들&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;다중-스레드의-장점&#34;&gt;다중 스레드의 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;응답성(Responsiveness)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;하나의 스레드가 봉쇄 상태인 동안(예: 웹 페이지에서 네트워크를 통해 이미지를 불러온다)에도 동일한 프로세스 내 다른 스레드가 실행(예: 이미지는 나중에 출력하고, 나머지 웹 페이지를 화면에 출력한다)되어 작업을 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자원 공유(Resource sharing)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;하나의 프로세스 내에서 CPU 수행 단위만 여러개(스레드를 여러개)두게 되면 서로 자원을 공유하므로 효율적으로 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;경제성(Economy)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스를 하나 만드는 것보다 스레드를 하나 만드는 것이 오버헤드가 적다.&lt;/li&gt;
&lt;li&gt;프로세스 간 문맥교환보다 스레드 간 문맥 교환이 오버헤드가 적다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티 프로세서 환경에서의 활용(Utilization of Multi Processor Architectures)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU가 여러개인 컴퓨터에서는 병렬성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;스레드의-구현&#34;&gt;스레드의 구현&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;커널의 지원을 받는 스레드(kernel level thread)
&lt;ul&gt;
&lt;li&gt;운영체제 커널이 스레드가 여러개 있다는 사실을 알고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;라이브러리의 지원을 받는 스레드(user level thread)
&lt;ul&gt;
&lt;li&gt;운영체제가 스레드의 존재를 모르고, 사용자의 프로세스가 직접 스레드를 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실시간(real-time) 기능을 지원하는 스레드&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프로세스의-생성&#34;&gt;프로세스의 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로세스의 생성 (process creation)
&lt;ul&gt;
&lt;li&gt;시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음 부터는 이미 존재하는 프로세스가 다른 프로세스를 &lt;u&gt;복제 생성&lt;/u&gt;한다.&lt;/li&gt;
&lt;li&gt;각각을 부모 프로세스, 자식 프로세스라고 하며, 트리와 같은 계층 구조을 형성하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;생성된 프로세스가 자원을 획득하는 방법
&lt;ul&gt;
&lt;li&gt;경우 1. 운영체제로 부터 직접 할당받는다.&lt;/li&gt;
&lt;li&gt;경우 2. 부모 프로세스와 자원을 공유한다. (모든 자원을 or 일부를 or 공유하지 않음)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;생성된 프로세스가 수행(execution)되는 방법
&lt;ul&gt;
&lt;li&gt;경우 1. 부모와 자식이 공존하며 수행된다.&lt;/li&gt;
&lt;li&gt;경우 2. 자식이 종료(terminate)될 때까지 부모 프로세스가 기다린다(wait).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프로세스와-관련된-시스템-콜들&#34;&gt;프로세스와 관련된 시스템 콜들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt; 시스템 콜
&lt;ul&gt;
&lt;li&gt;프로세스 ID를 제외한 부모 프로세스의 모든 내용을 그대로 복제해서 자식 프로세스를 생성한다.&lt;/li&gt;
&lt;li&gt;프로그램 카운터 값도 복제되므로, 부모 프로세스가 실행한 그 다음 위치 부터 실행하게 된다.&lt;/li&gt;
&lt;li&gt;자식 프로세스는 자신만의 &lt;u&gt;독자적인 주소 공간&lt;/u&gt;을 갖지만, 처음에 내용은 부모 프로세스의 내용을 그대로 &lt;u&gt;복사해서 생성&lt;/u&gt;한다.&lt;/li&gt;
&lt;li&gt;구분하는 법: &lt;code&gt;fork()&lt;/code&gt; 함수의 결괏값이 &lt;strong&gt;양수&lt;/strong&gt;이면 &lt;u&gt;부모 프로세스&lt;/u&gt;이고, &lt;strong&gt;0&lt;/strong&gt;이면 복제된 &lt;u&gt;자식 프로세스&lt;/u&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt; 시스템 콜
&lt;ul&gt;
&lt;li&gt;프로세스의 주소 공간을 완전히 &lt;u&gt;새로운 프로그램으로 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행을 시작&lt;/u&gt;하도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt; 시스템 콜
&lt;ul&gt;
&lt;li&gt;자식 프로세스가 종료되기를 기다리며 &lt;u&gt;부모 프로세스가 봉쇄 상태&lt;/u&gt;에 머무르도록 한다.&lt;/li&gt;
&lt;li&gt;부모 프로세스와 자식 프로세스 간의 동기화(synchronization)가 가능해진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 종료되는 방법
&lt;ul&gt;
&lt;li&gt;경우 1. 자발적 종료
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt; 시스템 콜로 운영체제에게 자신이 종료됨을 알린다. 프로그래머가 명시적으로 호출하지 않아도 컴파일러가 자동으로 삽입해서 프로세스의 종료 직전에 호출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;경우 2. 비자발적 종료
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;abort()&lt;/code&gt; 시스템 콜로 부모 프로세스가 자식 프로세스의 수행을 강제로 종료 시킨다.
&lt;ul&gt;
&lt;li&gt;(1) 자식 프로세스가 한계치를 넘어서는 자원을 요구할 때&lt;/li&gt;
&lt;li&gt;(2) 자식 프로세스의 작업이 더 이상 필요하지 않을 때&lt;/li&gt;
&lt;li&gt;(3) 부모 프로세스가 종료될 때. 부모 프로세스가 종료될 경우에는 자식 프로세스들을 연쇄적으로 종료 시킨 후에야 본인이 종료될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용자가 키보드로 kill, break 등을 친 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프로세스-간의-협력&#34;&gt;프로세스 간의 협력&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로세스는 독립적인 주소 공간을 가지기 때문에 각자 독립적인 관계가 된다.&lt;/li&gt;
&lt;li&gt;하지만 경우에 따라서는 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스 간 협력 매커니즘 (Inter-Process Communication; IPC)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1. 메시지 전달 방식(message passing)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;공유 데이터를 일절 사용하지 않고, 메시지를 주고받으면서 통신하는 방식이다.&lt;/li&gt;
&lt;li&gt;메시지는 시스템 콜 방식으로 운영체제의 &lt;u&gt;커널에게 요청&lt;/u&gt;해서 주고받는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(1) 직접 통신(direct communication)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;통신하려는 프로세스의 이름을 명시적으로 표시한다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;send(P, message)&lt;/code&gt;, &lt;code&gt;receive(Q, message)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(2) 간접 통신(indirect communication)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;메일박스(mail box) 또는 포트(port)를 통해 메시지를 간접적으로 전달한다.&lt;/li&gt;
&lt;li&gt;예: &lt;code&gt;send(M, message)&lt;/code&gt;, &lt;code&gt;receive(M, message)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2. 공유 메모리 방식(shared memory)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스들이 주소 공간의 일부를 공유하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 3, 4. 컴퓨터 시스템의 동작 원리</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-03/</link>
        <pubDate>Thu, 02 Jun 2022 02:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-03/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;컴퓨터-시스템의-구조&#34;&gt;컴퓨터 시스템의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pepperedpepper.github.io/post/os/images/03-01-computer-structure.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;컴퓨터 내부장치와 외부장치 구조&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;컴퓨터-내-연산과-io-연산&#34;&gt;컴퓨터 내 연산과 I/O 연산&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;컴퓨터 내에서 수행되는 연산&lt;/strong&gt; : &lt;strong&gt;CPU&lt;/strong&gt; 담당
&lt;ul&gt;
&lt;li&gt;CPU는 매 시점에 &lt;u&gt;메모리에서 명령(instruction) 하나를 읽어서 수행&lt;/u&gt;한다.&lt;/li&gt;
&lt;li&gt;CPU가 &lt;u&gt;어떤 명령을 수행할 지에 대한 주소&lt;/u&gt;는 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;프로그램 카운터(program counter)&lt;/strong&gt;&lt;/mark&gt; 라는 레지스터가 알고 있다.&lt;/li&gt;
&lt;li&gt;CPU는 명령을 수행할 때마다 옆에 있는 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;인터럽트 라인(interrupt line)&lt;/strong&gt;&lt;/mark&gt;에 신호가 들어왔는지를 확인한다. 그리고 신호가 들어오면 하던 일을 멈추고 &lt;u&gt;인터럽트 관련된 일을 먼저 처리&lt;/u&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;입출력 장치들의 I/O 연산&lt;/strong&gt; : &lt;strong&gt;장치 컨트롤러&lt;/strong&gt; 담당
&lt;ul&gt;
&lt;li&gt;장치 컨트롤러는 &lt;u&gt;들어오고 나가는 데이터를 임시로 저장&lt;/u&gt;하기 위해 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;로컬버퍼(local buffer)&lt;/strong&gt;&lt;/mark&gt; 라는 작은 메모리를 가지고 있다.&lt;/li&gt;
&lt;li&gt;예를 들어, 프로그램 A가 디스크에서 데이터를 읽어오라는 명령을 내리면, 장치 컨트롤러가 디스크에서 내용을 읽어서 로컬버퍼에 저장한다. 그리고 장치 컨트롤러는 &lt;u&gt;인터럽트를 발생시켜서 다 했다고 보고&lt;/u&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;인터럽트&#34;&gt;인터럽트&lt;/h2&gt;
&lt;h3 id=&#34;인터럽트의-종류&#34;&gt;인터럽트의 종류&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하드웨어 장치나 소프트웨어는 CPU의 서비스가 필요한 경우 CPU 옆에 있는 인터럽트 라인에 신호를 보내서 인터럽트를 발생시킨다.&lt;/li&gt;
&lt;li&gt;인터럽트가 발생하면, CPU는 하던 일을 멈추고 해당 인터럽트 발생 시 해야하는 코드를 찾아서 수행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;하드웨어 인터럽트&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;장치 컨트롤러와 같은 하드웨어 장치가 CPU의 인터럽트 라인을 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;소프트웨어 인터럽트&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;트랩(trap)&lt;/strong&gt; 이라고 주로 불린다.&lt;/li&gt;
&lt;li&gt;소프트웨어가 CPU의 인터럽트 라인을 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;u&gt;CPU의 제어권이 사용자 프로세스로부터 운영체제로 이양&lt;/u&gt;된다.&lt;/li&gt;
&lt;li&gt;예를 들어, 프로그램이 키보드 입력 등의 입출력 작업이 필요할 때는 인터럽트 라인을 설정해서 CPU 제어권을 운영체제로 넘겨서 수행한다.&lt;/li&gt;
&lt;li&gt;예시 1. &lt;strong&gt;예외 상황(exception)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;비정상적인 작업을 시도(0으로 나누기)하거나 권한이 없는 작업(자신의 메모리 영역을 벗어난 접근)을 시도할 때 이에 대한 처리를 하기 위해 발생시키는 인터럽트이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;예시 2. &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;시스템 콜(system call)&lt;/strong&gt;&lt;/mark&gt;
&lt;ul&gt;
&lt;li&gt;사용자 프로그램이 &lt;u&gt;운영체제 내부에 정의된 코드를 실행하고 싶을 때&lt;/u&gt; 운영체제에 서비스를 요청하기 위해 발생시키는 인터럽트이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;운영체제는 인터럽트가 발생했을 때만 CPU의 제어권을 점유한다. 그 외에는 사용자 프로그램이 항상 CPU를 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;운영체제의-커널이-인터럽트-처리를-위해-갖고-있는-것들&#34;&gt;운영체제의 커널이 인터럽트 처리를 위해 갖고 있는 것들&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;인터럽트 처리루틴(interrupt service routine)&lt;/strong&gt; 혹은 &lt;strong&gt;인터럽트 핸들러(interrupt handler)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;인터럽트가 들어왔을 때 &lt;u&gt;해야 할 일을 프로그래밍 해 놓은 코드&lt;/u&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인터럽트 벡터(interrupt vector)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;인터럽트는 종류마다 번호가 정해져 있고, 인터럽트 발생 시 각각 처리해야 할 코드가 다르다.&lt;/li&gt;
&lt;li&gt;인터럽트 벡터는 &lt;u&gt;인터럽트 번호마다 처리할 코드를 가리키고 있는 자료구조&lt;/u&gt;이다.&lt;/li&gt;
&lt;li&gt;각 인터럽트 종류마다 번호를 정해 놓았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로세스 제어블록(Process Control Block: PCB)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;운영체제가 프로세스들을 관리하기 위해 &lt;u&gt;프로세스의 정보를 담는 커널 내의 자료구조&lt;/u&gt;이다.&lt;/li&gt;
&lt;li&gt;CPU는 새로운 명령을 실행하면 레지스터에 데이터를 읽고 쓰면서 작업을 한다. 인터럽트가 발생하면 현재 실행되던 기존 레지스터 값들이 모두 날아가기 때문에, &lt;u&gt;현재 실행되던 프로세스의 상태를 저장해두어야&lt;/u&gt; 한다. 그래서 프로세스마다 PCB를 갖고 있고, 여기에는 실행 중이던 코드의 메모리 주소와 레지스터 값 등이 담긴다.&lt;/li&gt;
&lt;li&gt;예를 들어, 프로그램 실행 중에 인터럽트가 발생하면 상태를 PCB에 저장하고 CPU의 제어권이 인터럽트 처리루틴으로 넘어간다. 그리고 처리가 끝나면 저장된 상태를 PCB에서 CPU로 복원해서 해당 위치부터 다시 작업을 이어나간다.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pepperedpepper.github.io/p/os-it-principles-05/#%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%a0%9c%ec%96%b4%eb%b8%94%eb%a1%9d&#34; &gt;PCB 구성 요소&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;인터럽트의-우선순위&#34;&gt;인터럽트의 우선순위&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;더 높은 우선순위의 인터럽트가 발생하면 현재 처리 중이던 인터럽트 코드의 수행 지점을 저장하고 우선순위가 높은 인터럽트를 처리히게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;입출력-구조&#34;&gt;입출력 구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;동기식 입출력(synchronous I/O)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;어떤 프로그램이 입출력 요청을 하면, 그 입출력 작업이 &lt;u&gt;완료된 다음에야 다음 후속 작업을 할 수 있는 것&lt;/u&gt;이다.&lt;/li&gt;
&lt;li&gt;이렇게 되면 한 입출력 작업이 끝날 때까지 CPU가 아무일도 하지 않아서 자원이 낭비된다. 그래서 일반적으로는 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해서 CPU가 쉬지 않고 일하도록 한다.&lt;/li&gt;
&lt;li&gt;관리방법
&lt;ul&gt;
&lt;li&gt;운영체제는 프로그램을 몇 가지 상태로 나누고, 입출력 중인 프로그램를 &lt;strong&gt;봉쇄 상태(blocked state)&lt;/strong&gt; 로 전환시킨다.&lt;/li&gt;
&lt;li&gt;그리고 봉쇄 상태인 프로그램에게는 CPU를 할당하지 않고, 다른 프로그램에게 할당해준다.&lt;/li&gt;
&lt;li&gt;만약에 여러 프로그램의 입출력 요청이 여러번 있다면, 그 순서는 어떻게 지킬 것인가?&lt;/li&gt;
&lt;li&gt;장치별로 &lt;strong&gt;큐(queue)를 두어서 요청한 순서대로 처리&lt;/strong&gt;할 수 있도록한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;비동기식 입출력(asynchronous I/O)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;입출력 연산이 끝나기를 기다리지 않고, CPU 제어권을 &lt;u&gt;입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여&lt;/u&gt;하는 것이다.&lt;/li&gt;
&lt;li&gt;그래서 입출력 연산과 무관하게 처리 가능한 작업들을 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;디스크나 키보드에서 데이터를 읽어오는 경우의 동기식 입출력 예시&amp;hellip;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로그램 A를 실행하던 중에, 디스크에서 데이터를 읽어오는 명령을 만나게 되면, 그 프로그램은 &lt;u&gt;시스템 콜(소프트웨어 인터럽트)&lt;/u&gt; 을 통해 CPU에게 인터럽트를 발생시킨다.&lt;/li&gt;
&lt;li&gt;CPU는 인터럽트가 발생하면, 하던 일을 멈추고 현재 실행 중이던 &lt;u&gt;프로그램의 상태를 PCB에 저장&lt;/u&gt;한다. 그리고 &lt;u&gt;CPU의 제어권이 운영체제로 이양&lt;/u&gt;된다.&lt;/li&gt;
&lt;li&gt;운영체제 커널에서 &lt;u&gt;인터럽트 처리루틴을 찾아서 장치 컨트롤러에게 입출력 연산을 요청&lt;/u&gt;한다.&lt;/li&gt;
&lt;li&gt;&lt;u&gt;장치 컨트롤러가 물리적인 장치에서 로컬버퍼로 데이터를 읽어온다.&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;(읽어오는 동안 해당 프로그램은 운영체제에 의해 &lt;u&gt;봉쇄 상태&lt;/u&gt;로 설정되었으므로 CPU를 할당 받지 못한다.)&lt;/li&gt;
&lt;li&gt;(그동안 CPU는 다른 프로그램 B에게 할당된다.)&lt;/li&gt;
&lt;li&gt;그러고 나서, &lt;u&gt;다 읽었다고 인터럽트를 발생&lt;/u&gt;시킨다. (하드웨어 인터럽트)&lt;/li&gt;
&lt;li&gt;&lt;u&gt;인터럽트 처리루틴에 의해서 요청한 데이터를 해당 메모리 영역으로 읽어오고, 봉쇄 상태를 해제&lt;/u&gt;한다. 그리고 다음 차례를 기다린다.&lt;/li&gt;
&lt;li&gt;&lt;u&gt;PCB에 담긴 저장 상태를 레지스터로 복원해서 작업을 이어나간다.&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu-대신-메모리에-접근하는-dma&#34;&gt;CPU 대신 메모리에 접근하는 DMA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;DMA(Direct Memory Access)&lt;/strong&gt;&lt;/mark&gt;
&lt;ul&gt;
&lt;li&gt;CPU만이 메모리에 접근해서 연산을 처리할 수 있다. 하지만 이렇게 되면 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU 업무가 방해를 받게된다.&lt;/li&gt;
&lt;li&gt;따라서 DMA라는 장치를 두어 &lt;u&gt;로컬버퍼에서 메모리로 읽어오는 작업을 대행&lt;/u&gt;할 수 있게 했다.&lt;/li&gt;
&lt;li&gt;DMA는 바이트(byte) 단위가 아니라 &lt;strong&gt;블록(block)&lt;/strong&gt; 이라는 큰 단위로 데이터를 로컬버퍼에서 읽어온다. 그리고 나서 CPU에게 인터럽트를 발생시켜서 작업이 완료되었음을 알린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;저장장치의-구조&#34;&gt;저장장치의 구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;주기억장치
&lt;ul&gt;
&lt;li&gt;휘발성(volatile)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;보조기억장치
&lt;ul&gt;
&lt;li&gt;비휘발성(nonvolatile)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;보조기억장치의 용도&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;파일 시스템(file system)&lt;/strong&gt; 용
&lt;ul&gt;
&lt;li&gt;주기억장치의 내용은 전원이 꺼지면 모두 날아가므로, &lt;u&gt;전원이 나가도 유지할 정보&lt;/u&gt;를 저장하기 위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;스왑 영역(swap area)&lt;/strong&gt; 용
&lt;ul&gt;
&lt;li&gt;주기억장치의 크기가 한정적이기 떄문에, 주기억장치에는 당장 필요한 부분만 올려놓고 나머지는 디스크의 스왑영역에 내려놓는다. 이렇게 &lt;u&gt;메모리의 연장 공간&lt;/u&gt;인 스왑 영역으로 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;당장 필요한 게 아닌 부분은 디스크의 스왑 영역에 내려 놓는데, 이것을 &lt;strong&gt;스왑 아웃(swap out)&lt;/strong&gt; 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;저장장치 빠른 순서
&lt;ul&gt;
&lt;li&gt;레지스터 → 캐시 메모리 → 메인 메모리 → 마그네틱 디스크 → 광디스크 → 마그네틱 테이프&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;캐싱 기법
&lt;ul&gt;
&lt;li&gt;느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장해서, 두 저장장치 사이의 속도를 완충하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;하드웨어-보안&#34;&gt;하드웨어 보안&lt;/h2&gt;
&lt;h3 id=&#34;cpu가-수행하는-명령의-종류&#34;&gt;CPU가 수행하는 명령의 종류&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;일반 명령&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 명령들.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;특권 명령&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;보안&lt;/u&gt;이 필요한 명령들.&lt;/li&gt;
&lt;li&gt;입출력 장치, 타이머 장치 등 각종 장치에 접근하는 명령.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&#34;하드웨어-보안을-위한-운영체제의-모드&#34;&gt;하드웨어 보안을 위한 운영체제의 모드&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;사용자 모드(user mode)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;일반 명령만 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;커널 모드(kernel mode)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;운영체제가 CPU의 제어권을 가지고 운영체제의 코드를 실행하는 모드&lt;/u&gt;이다. 이 모드에서는 모든 명령을 다 실행할 수 있다.&lt;/li&gt;
&lt;li&gt;사용자 프로그램이 이상한 명령으로 다른 프로그램의 메모리 영역이나 파일 시스템에 접근하면 위험한 상황이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행되도록 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;만약에 사용자 프로그램이 CPU의 제어권을 갖고 있을 때 중요한 연산을 실행시켜버리면 어떡할까?
&lt;ul&gt;
&lt;li&gt;CPU 내부에 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;모드 비트(mode bit)&lt;/strong&gt;&lt;/mark&gt; 를 두어서 사용자 프로그램을 감시하도록 했다.&lt;/li&gt;
&lt;li&gt;모드 비트가 1이면 사용자 모드이고, 0이면 커널 모드이다.&lt;/li&gt;
&lt;li&gt;그래서 &lt;u&gt;CPU는 보안과 관련된 명령을 수행하기 전에 모드 비트를 살펴보고 커널 모드일 때만 그 명령을 수행&lt;/u&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;사용자 프로그램이 CPU를 빼앗기는 경우는 (1)입출력 요청을 위해 시스템 콜을 하는 경우와 (2)타이머에 의해 인터럽트가 발생한 경우이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;메모리-보안&#34;&gt;메모리 보안&lt;/h2&gt;
&lt;h3 id=&#34;메모리-보안을-위한-2개의-레지스터&#34;&gt;메모리 보안을 위한 2개의 레지스터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;기준 레지스터(base register)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;해당 프로그램이 합법적으로 접근할 수 있는 메모리 상의 &lt;u&gt;가장 작은 주소&lt;/u&gt;를 보관한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;한계 레지스터(limit register)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;해당 프로그램이 합법적으로 접근할 수 있는 &lt;u&gt;메모리의 범위&lt;/u&gt;를 보관한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;따라서 메모리 접근 연산이 있을 때마다, &lt;code&gt;기준 레지스터 ~ 기준 레지스터 + 한계 레지스터&lt;/code&gt;의 &lt;strong&gt;범위에 있는지를 체크해서 보안&lt;/strong&gt;을 한다.
&lt;ul&gt;
&lt;li&gt;이것은 프로그램이 연속적으로 메모리에 위치한다는 것을 가정한 것이다. 페이징과 같이 여러영역에 나뉘어 위치할 경우에는 다른 메모리 관리 기법이 필요하다. 이것은 다음에 살펴본다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu-보호&#34;&gt;CPU 보호&lt;/h2&gt;
&lt;h3 id=&#34;타이머&#34;&gt;타이머&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPU가 하나의 프로그램에 의해서 독점되는 것을 막기 위해, 운영체제는 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;타이머(timer)&lt;/strong&gt;&lt;/mark&gt;라는 하드웨어를 사용한다.
&lt;ul&gt;
&lt;li&gt;타이머는 &lt;u&gt;정해진 시간이 지나면 인터럽트를 발생&lt;/u&gt;시켜서 &lt;u&gt;운영체제가 CPU의 제어권을 획득할 수 있도록&lt;/u&gt; 한다.&lt;/li&gt;
&lt;li&gt;시분할 시스템에서 현재 시간을 계산하기 위해서도 사용한다.&lt;/li&gt;
&lt;li&gt;타이머의 값을 일정 시간 단위로 세팅하는 명령을 &lt;strong&gt;로드 타이머(load timer)&lt;/strong&gt; 라고 한다. 이것은 특권명령이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;프로그램의-주소-영역&#34;&gt;프로그램의 주소 영역&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로그램이 실행되었을 때, 프로그램의 주소 영역 중에서 &lt;strong&gt;당장 실행에 필요한 부분만 메모리에&lt;/strong&gt; 올려놓고, &lt;strong&gt;나머지 부분&lt;/strong&gt;은 메모리의 연장 공간으로 사용되는 &lt;strong&gt;스왑 영역에&lt;/strong&gt; 내려놓는다.&lt;/li&gt;
&lt;li&gt;프로그램이 각각 독자적으로 가지는 주소 공간을, &lt;strong&gt;가상 메모리(virtual memory)&lt;/strong&gt; 혹은 &lt;strong&gt;논리적 메모리(logical memory)&lt;/strong&gt; 라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;주소영역&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;코드(code)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CPU에서 수행할 수 있는 기계어 명령(machine instruction)을 저장하는 부분.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;데이터(data)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;전역 변수(global variable) 등, 프로그램이 사용할 데이터를 저장하는 부분.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;스택(stack)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 부분.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;커널의-주소-영역&#34;&gt;커널의 주소 영역&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;커널도 주소 공간을 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;주소영역&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;코드(code)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CPU, 메모리 등 &lt;strong&gt;자원을 관리하기 위한 코드&lt;/strong&gt;. &lt;br /&gt;&lt;strong&gt;사용자에게 편리한 서비스를 제공하기 위한 코드&lt;/strong&gt;. &lt;br /&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;시스템 콜, 인터럽트&lt;/mark&gt;를 처리하기 위한 코드&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;데이터(data)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;각종 자원을 관리하기 위한 자료구조&lt;/strong&gt;&lt;/mark&gt;가 저장된다. &lt;br /&gt;CPU나 메모리같은 하드웨어 자원을 관리하기 위한 자료구조(큐 등), PCB.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;스택(stack)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;호출된 함수의 수행을 마치고 복귀할 주소 및 데이터&lt;/strong&gt;&lt;/mark&gt;를 임시로 저장하는 부분. &lt;br /&gt;각 &lt;strong&gt;프로세스 마다 별도의 스택&lt;/strong&gt;을 두어서 관리한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;상황에 따라 복귀 정보가 담기는 곳이 달라진다.
&lt;ul&gt;
&lt;li&gt;프로그램 수행중에 다른 함수 호출이 이루어졌다 → 복귀 정보는 프로그램의 스택에 담긴다.&lt;/li&gt;
&lt;li&gt;인터럽트로 CPU의 수행 주체가 운영체제로 바뀌었다. → 복귀 정보는 PCB에 담긴다.&lt;/li&gt;
&lt;li&gt;커널의 코드가 수행되던 중간에 다른 함수호출이 이루어졌다. → 복귀 정보는 커널의 스택에 담긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[OS] Chapter 2. 운영체제 개요</title>
        <link>https://pepperedpepper.github.io/p/os-it-principles-02/</link>
        <pubDate>Thu, 02 Jun 2022 01:00:00 +0900</pubDate>
        
        <guid>https://pepperedpepper.github.io/p/os-it-principles-02/</guid>
        <description>&lt;div style=&#34;text-align: right&#34;&gt; 
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.yes24.com/Product/Goods/90124877&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;운영체제와 정보기술의 원리&lt;/a&gt; 강의을 듣고 공부한 노트입니다.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;운영체제의-정의&#34;&gt;운영체제의 정의&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;운영체제&lt;/strong&gt;란?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 &lt;u&gt;소프트웨어&lt;/u&gt;이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;운영체제도 하나의 소프트웨어이기 때문에 컴퓨터 전원이 켜짐과 동시에 메모리에 올라간다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모두 다 올라가면 메모리 공간의 낭비가 심하기 때문에 &lt;u&gt;항상 필요한 부분만을 올리고&lt;/u&gt;, 나머지는 필요할 때 메모리로 올린다.&lt;/li&gt;
&lt;li&gt;여기서 항상 필요한 부분을 &lt;strong&gt;커널(kernel)&lt;/strong&gt; 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;운영체제의-기능&#34;&gt;운영체제의 기능&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) 컴퓨터 시스템 내의 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;자원(resource)을 효율적으로 관리&lt;/strong&gt;&lt;/mark&gt;하는 것
&lt;ul&gt;
&lt;li&gt;여기서 자원이란, 하드웨어인 CPU, 메모리, 하드디스크 등과 소프트웨어 자원까지를 통칭하는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) 컴퓨터 시스템을 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;편리하게 사용&lt;/strong&gt;&lt;/mark&gt;할 수 있는 환경을 제공하는 것
&lt;ul&gt;
&lt;li&gt;편리한 인터페이스 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) 사용자와 운영체제 자신을 &lt;mark style=&#34;background-color: lightblue&#34;&gt;&lt;strong&gt;보호&lt;/strong&gt;&lt;/mark&gt;하는 것
&lt;ul&gt;
&lt;li&gt;악의성 프로그램이 사용자의 사적인 파일에 접근하는 것을 막는 등의 일을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;운영체제의-분류&#34;&gt;운영체제의 분류&lt;/h2&gt;
&lt;h3 id=&#34;동시-작업을-지원하는가&#34;&gt;동시 작업을 지원하는가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;단일작업(single tasking)&lt;/strong&gt; 용 운영체제
&lt;ul&gt;
&lt;li&gt;한 번에 하나의 프로그램만 실행시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;다중작업(multi tasking)&lt;/strong&gt; 용 운영체제
&lt;ul&gt;
&lt;li&gt;동시에 2개 이상의 프로그램을 처리할 수 있다. 즉, 인터넷과 문서작성을 동시에 띄워놓고 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;다중작업과 유사한 의미의 용어들&amp;hellip;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;시분할 시스템(time sharing system)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;CPU의 작업 시간을 여러프로그램이 나누어서 쓰는 것이다.&lt;/li&gt;
&lt;li&gt;짧은 시간 규모로 여러 프로그램들이 CPU에서 번갈아 실핼되면 사용자는 동시에 실행되는 것처럼 보인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다중 프로그래밍 시스템(multi-programming system)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;메모리 공간을 분할해서 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;대화형 시스템(interactive system)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;사용자의 키보드 입력 결과를 곧바로 화면에 보여주는 시스템이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;다중작업과 비교되는 용어&amp;hellip;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;다중 처리기 시스템(multi-processor system)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;하나의 컴퓨터 안에 CPU가 여러개 설치된 경우이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;다중-사용자를-지원하는가&#34;&gt;다중 사용자를 지원하는가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;단일 사용자용 운영체제&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;한 번에 한 명의 사용자만이 사용하도록 허용하는 운영체제이다.&lt;/li&gt;
&lt;li&gt;예: Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;다중 사용자용 운영체제&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;여러 사용자가 동시에 접속해 사용할 수 있도록 하는 운영체제이다.&lt;/li&gt;
&lt;li&gt;예: 서버&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;h3 id=&#34;작업을-처리하는-방식에-따라&#34;&gt;작업을 처리하는 방식에 따라&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1) &lt;strong&gt;일괄처리(batch processing)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;작업을 모아서 일정량이 쌓이면 한꺼번에 처리한다.&lt;/li&gt;
&lt;li&gt;예: 초창기 컴퓨터의 펀치 카드(punch card)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) &lt;strong&gt;시분할(time sharing) 방식&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;작업을 짧은 시간 단위로 번갈아가며 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) &lt;strong&gt;실시간(real time) 운영체제&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템에서 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;경성(hard) 실시간 시스템&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;주어진 시간을 지키지 못할 경우 매우 위험한 결과를 초래할 가능성이 있는 경우.&lt;/li&gt;
&lt;li&gt;예: 로켓, 원자로 제어.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;연성(soft) 실시간 시스템&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;정해진 시간 단위로 전달되어야 올바른 기능을 수행할 수 있는 경우.&lt;/li&gt;
&lt;li&gt;예: 멀티미디어 스트리밍 시스템.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;운영체제의-예&#34;&gt;운영체제의 예&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MS Windows
&lt;ul&gt;
&lt;li&gt;GUI 기반&lt;/li&gt;
&lt;li&gt;플러그 앤 플레이(plug and play)
&lt;ul&gt;
&lt;li&gt;새로운 하드웨어를 시스템에 장착하면 운영체제가 자동으로 하드웨어를 감지하여 그에 맞게 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;유닉스
&lt;ul&gt;
&lt;li&gt;대부분의 코드가 C언어로 작성되었다. 이식성(portability)이 좋다.&lt;/li&gt;
&lt;li&gt;운영체제 커널의 크기가 작다.&lt;/li&gt;
&lt;li&gt;소스 코드가 공개된다. 그래서 여러 집단에서 개발한 다양한 종류가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;운영체제의-자원-관리-기능&#34;&gt;운영체제의 자원 관리 기능&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt; 자원 관리 : &lt;strong&gt;CPU 스케줄링(CPU scheduling)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;매 시점 어떤 프로세스에게 CPU를 할당할 것인가?&lt;/li&gt;
&lt;li&gt;선입선출, 라운드 로빈, 우선순위 스케줄링&amp;hellip;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pepperedpepper.github.io/p/os-it-principles-06/#%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98&#34; &gt;CPU 스케줄링 알고리즘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메모리&lt;/strong&gt; 자원 관리
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;고정분할 방식, 가변분할방식, 가상메모리 방식&amp;hellip;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pepperedpepper.github.io/p/os-it-principles-09/#%eb%ac%bc%eb%a6%ac%ec%a0%81-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%9d%98-%ed%95%a0%eb%8b%b9-%eb%b0%a9%ec%8b%9d&#34; &gt;메모리 할당 방식&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pepperedpepper.github.io/p/os-it-principles-10/#%ed%8e%98%ec%9d%b4%ec%a7%80-%ea%b5%90%ec%b2%b4&#34; &gt;가상 메모리 방식의 페이지 교체 알고리즘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;파일&lt;/strong&gt; 관리
&lt;ul&gt;
&lt;li&gt;디스크에 파일이 저장되는 방식 및 접근 권한을 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;주변장치 및 입출력 장치&lt;/strong&gt; 자원 관리
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;인터럽트(interrupt)&lt;/strong&gt; 를 통해 관리가 이루어진다.&lt;/li&gt;
&lt;li&gt;주변장치들은 CPU의 서비스가 필요해지면 신호(인터럽트)를 발생시켜서 서비스를 요청한다. 그러면 CPU가 잠시 하던 일을 멈추고 인터럽트에 의한 요청 서비스를 수행한다.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pepperedpepper.github.io/p/os-it-principles-03/#%ec%9d%b8%ed%84%b0%eb%9f%bd%ed%8a%b8&#34; &gt;인터럽트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
