[{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 53: 컴파일러 경고를 지나치지 말자 컴파일러가 경고 메시지를 내지 않고 컴파일 되는 코드를 만들자. Item 54: TR1을 포함한 표준 라이브러리 구성요소와 편안한 친구가 되자 C++98의 표준 라이브러리 주요 구성요소 표준 템플릿 라이브러리(Standard Template Library: STL) iostream 국제화 지원 수치 처리 지원 예외 클래스 계통 C89의 표준 라이브러리 TR1의 주요 구성요소 TR1(1차 기술 보고서: Technical Report 1)은 C++ 표준의 차기 버전인 C++0x에 추가될 라이브러리다. TR1의 구성요소는 총 14개이며, std::tr1 네임스페이스 안에 들어 있다. 스마트 포인터 tr1::function tr1::bind 해시 테이블(hash table) 정규 표현식(regular expression) 튜플(tuple) tr1::array tr1::mem_fn tr1::reference_wrapper 난수 발생 특수 용도의 수학 함수 C99 호환성 확장 기능 타입 특성정보(type traits) tr1::result_of TR1은 단순히 문서일 뿐이다. TR1의 기능을 사용하기 위해서는 명세를 구현한 코드를 구해야 한다. 그 중에서는 부스트가 가장 좋은 자원이다. Item 55: Boo자유친! 부스트를 늘 여러분 가까이에 부스트의 장점 C++ 표준화 위원회와 밀접하고 영향력 있는 관계를 유지하고 있다. 라이브러리 승인 과정이 동료 심사를 통해 이루어진다. 부스트의 라이브러리 군단 문자열 및 텍스트 처리 컨테이너 함수 객체 및 고차(higher-order) 프로그래밍 일반화 프로그래밍 템플릿 메타프로그래밍(TMP, Item 48 참고) 수학 및 수치 조작 정확성 유지 및 테스트 자료구조 타 언어와의 연동 지원 메모리 CRC 점검, 날짜 및 시간 조작, 파일 시스템 횡단 등 https://www.boost.org/ ","date":"2023-01-09T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-09/","title":"[Effective C++] Chapter 9. 그 밖의 이야기들"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 49: new 처리자의 동작 원리를 제대로 이해하자 new 처리자(new handler) new로 메모리 할당이 제대로 되지 못하면 호출되는 에러 처리 함수이다. 사용자가 직접 지정할 수 있으며, 표준 라이브러리에 있는 set_new_handler 함수를 이용하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 // \u0026lt;new\u0026gt;에 선언되어 있는 함수들 namespace std { typedef void (*new_handler)(); // 매개변수와 반환값이 없는 함수에 대한 포인터이다. new_handler set_new_handler(new_handler p) throw(); // 매개변수 : 새롭게 설치할 new 처리자 // 반환값 : 새롭게 설치하기 전까지 사용하던 new 처리자 // throw() : 이 함수는 어떤 예외도 던지지 않을 것이라는 뜻이다. } new 처리자는 이것들 중 하나는 꼭 처리해야 한다. 사용할 수 있는 메모리를 더 많이 확보한다. 다른 new 처리자를 설치한다. new 처리자의 설치를 제거한다. bad_alloc 혹은 그것에서 파생된 타입의 예외를 던진다. 복귀하지 않는다. (대개 abort 혹은 exit을 호출한다.) new 처리자를 클래스 타입에 따라 다르게 만들기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 자원 관리 객체를 통해 할당에러를 처리한다. class NewHandlerHolder { private: std::new_handler handler; // 복사를 막기 위함 (Item 14) NewHandlerHolder(const NewHandlerHolder\u0026amp;); NewHandlerHolder\u0026amp; operator=(const NewHandlerHolder\u0026amp;); public: // 매개변수로 들어온 처리자를 들고 있다가 explicit NewHandlerHolder(std::new_handler nh) : handler(nh) {} // 객체가 소멸될 때 그 처리자를 설치한다. ~NewHandlerHolder() { std::set_new_handler(handler); } }; class Widget { private: static std::new_handler currentHandler; public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std::new_handler Widget::currentHandler = 0; // 널로 초기화 std::new_handler Widget::set_new_handler(std::new_handler p) throw() { // 매개변수로 들어온 처리자를 들고 있게 한다. std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler; } void * Widget::operator new(std::size_t size) throw(std::bad_alloc) { // 가지고 있는 현재 처리자를 설치하고, // 이전 처리자는 NewHandlerHolder가 가지고 있다가 // 이 함수를 빠져나가면 이전 처리자(전역 처리자)로 재설치한다. NewHandlerHolder h(std::set_new_handler(currentHandler)); // 메모리를 할당하고, 실패하면 예외를 던진다. return ::operator new(size); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void outOfMem(); int main() { // 새로운 처리자 설치 Widget::set_new_handler(outOfMem); // 여기서 new 실패시 outOfMem이 불린다. Widget * pw1 = new Widget; // 여기서 new 실패시 전역 new 처리자가 불린다. std::string * ps = new std::string; // null로 설정 Widget::set_new_handler(0); // 여기서 new 실패시 예외를 바로 던진다. Widget * pw2 = new Widget; } NewHandlerHolder를 템플릿으로 바꿔서 다른 클래스에서도 재사용 할 수 있게 해보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template\u0026lt;typename T\u0026gt; class NewHandlerSupport { private: static std::new_handler currentHandler; public: static std::new_handler set_new_handler(std::new_hanlder p) throw(); static void * operator new(std::size_t size) throw(std::bad_alloc); }; template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::set_new_handler(std::new_hanlder p) throw() { std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler; } template\u0026lt;typename T\u0026gt; void * newHandlerSupport\u0026lt;T\u0026gt;::operator new(std::size_t size) throw(bad_alloc) { NewHandlerSupport h(std::set_new_handler(currentHandler)); return ::operator new(size); } template\u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::currentHandler = 0; 1 2 3 4 5 6 7 8 // 신기하게 반복되는 템플릿 패턴(curiously recurring template pattern: CRTP) // Widget이 필요한건, NewHandlerSupport에 대한 사본이다. // NewHandlerSupport은 마치, 인스턴스화될 때 전달되는 T를 위한 // NewHandlerSupport의 사본을 찍어내는 공장과 같다. class Widget : public NewHandlerSupport\u0026lt;Widget\u0026gt; { // ... }; 예외불가(nothrow) new 현재는 new 실패 시 bad_alloc 예외를 던지도록 되어 있다. 예외불가 new는 예전의 방식대로, 실패 시 null을 반환하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 Widget * pw1 = new Widget; // Widget을 할당하다가 실패하면 bad_alloc 예외를 던진다. if (pw1 == 0) // 이것은 늘 false일 것이다. Widget * pw2 = new (std::nothrow) Widget; // Widget을 할당하다가 실패하면 0(널)을 반환한다. if (pw2 == 0) // 실패하면 널을 반환하므로 점검해보는 것이 가능하다. 참고로 예외불가 new는 operator new에서만 예외가 발생하지 않도록 보장하는 것일 뿐, Widget의 생성자에서 예외가 나오지 않게 막아 준다는 것은 아니다. Item 50: new 및 delete를 언제 바꿔야 좋은 소리를 들을지를 파악해 두자 사용자 정의 new와 delete를 작성해야 하는 때란? 잘못된 힙 사용을 탐지하기 위해 효율을 향상시키기 위해 동적 할당 메모리의 실제 사용에 관한 통계 정보를 수집하기 위해 할당 및 해제 속력을 높이기 위해 기본 메모리 관리자의 공간 오버헤드를 줄이기 위해 적당히 타협한 기본 할당자의 바이트 정렬 동작을 보장하기 위해 임의의 관계를 맺고 있는 객체들을 한 군데에 나란히 모아 놓기 위해 그때그때 원하는 동작을 수행하도록 하기 위해 바이트 정렬(byte alignment) 문제 컴퓨터는 아키텍처 적으로 특정 타입의 데이터가 특정 종류의 메모리 주소를 시작 주소로 하여 저장될 것을 요구사항으로 두고 있다. 예를 들면, 포인터는 4바이트 단위로 정렬되어야 한다거나 double은 8바이트 단위로 정렬되어야 한다는 것이다. 모든 operator new 함수는 어떤 데이터 타입에도 바이트 정렬을 적절히 만족하는 포인터를 반환해야 한다. 이런 바이트 정렬을 어떻게 다루느냐에 따라 사용자 정의 버전을 제공하는 메모리 관리자의 품질이 달라질 것이다. Item 51: new 및 delete를 작성할 때 따라야 할 기존의 관례를 잘 알아 두자 operator new를 구현할 때 지켜야할 요구사항들 (1) 메모리 할당을 반복해서 시도하는 무한 루프를 가져야 한다. (2) 할당 실패 시 new 처리자 함수를 호출해야 한다. (3) 크기가 없는(0바이트) 메모리 요청에 대한 대비책을 마련해야 한다. (4) 기본 형태의 new가 가려지지 않도록 해야한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void * operator new(std::size_t size) throw(std::bad_alloc) { using namespace std; // (3) 0바이트 메모리 요청이 들어오면 1바이트 요구로 간주한다. if (size == 0) size = 1; // (1) opreator new 함수에는 무한 루프가 있다. // 그래서 메모리 할당에 성공하든지, // 아니면 Item 49에서 나왔던 것들 중 하나는 꼭 처리해야 한다. while(true) { size바이트를 할당해 본다. if (할당 성공) return 할당한 메모리의 포인터; // 현재 설정되어 있는 new 처리자를 얻는다. new_handler globalHandler = set_new_handler(0); set_new_hanlder(globalHandler); // (2) new 처리자를 호출한다. if (globalHanlder) (*globalHandler)(); else throw std::bad_alloc(); } } 클래스 전용 버전은 자신이 할당하기로 예정된 크기보다 더 큰(다른) 메모리 블록에 대한 요구도 처리해야 한다. 클래스 X를 위한 operator new는 sizeof(X)인 크기의 객체에 맞추어져 있다. 그래서 Base 클래스에서 선언된 operator new을 Derived가 호출하면 매개변수로 넘어오는 size가 달라지게 된다. (Base와 Derived의 크기는 다르다. ) 따라서 다음과 같은 처리가 필요할 것이다. 1 2 3 4 5 6 void * Base::operator new(std::size_t size) throw(bad_alloc) { if (size != sizeof(Base)) return ::operator new(size); // size가 Base와 다르면 표준 operator new 쪽에서 처리하도록 넘긴다. } operator delete를 구현할 때 지켜야할 요구사항들 널 포인터에 대한 delete 적용이 항상 안전하도록 보장해야 한다. 클래스 전용 버전의 경우에는 new와 똑같이 크기를 점검하는 코드를 넣어준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Base::operator delete(void * rawMemory, std::size_t size) throw() { // 널 포인터의 경우 아무것도 하지 않는다. if (rawMemory == 0) return; // 클래스 전용 버전인 경우 size를 점검한다. if (size != sizeof(Base)) { ::operator delete(rawMemory); // 표준 operator delete가 처리하도록 한다. return; } // ... rawMemory가 가리키는 메모리를 해제한다. } 추가적으로, 가상 소멸자가 없는 기본 클래스로부터 파생된 클래스의 객체를 삭제하려고 할 경우에는, C++이 operator delete로 넘기는 size_t 값이 엉터리일 수 있다. 따라서 기본 클래스는 반드시 가상 소멸자를 두어야 하겠다. Item 52: 위치지정 new를 작성한다면 위치지정 delete도 같이 준비하자 C++가 전역 유효범위에서 제공하는 operator new의 세 가지 표준 형태 1 2 3 4 5 6 7 8 // 기본형 new void * operator new(std::size_t) throw(std::bad_alloc); // 위치지정 new void * operator new(std::size_t, void *) throw(); // 예외불가 new (Item 49) void * operator new(std::size_t, const std::nothrow_t\u0026amp;) throw(); 위치지정(placement) new 추가적인 매개변수를 받는 operator new이다. 이름이 위치지정인 이유는 원조격인 위치지정 new가 추가적인 매개변수로, 할당할 메모리의 위치를 받아서 할당 위치를 정해주었기 때문이다. 런타임 시스템은 operator new가 받아들이는 매개변수의 개수 및 타입이 똑같은 버전의 operator delete를 찾고, 그 녀석을 호출한다. 따라서 위치지정 new를 만들었다면, 그와 똑같은 매개변수를 받아들이는 위치지정 delete를 만들어야 한다. 위치지정 delete가 호출되는 때는, 위치지정 new와 함께 호출된 생성자에서 예외가 발생했을 때뿐이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Widget { public: // 새로운 매개변수 ostream을 받는 operator new (비표준 형태) static void * operator new(std::size_t size, std::ostream\u0026amp; logStream) throw(std::bad_alloc); // 클래스 전용 operator delete (표준 형태) static void operator delete(void * rawMemory, std::size_t size) throw(); }; int main() { Widget * pw = new (std::cerr) Widget; // 여기서 Widget생성자에서 오류가 난다면? // 그럼 delete가 제대로 되겠는가? // 새로운 매개변수 ostream을 받는 new와 짝이 맞는 delete가 없어서 // 결국 아무것도 불리지 않고 메모리는 누수가 된다. // 따라서 새로운 매개변수 ostream을 받는 delete도 있어야 하겠다. } 함수는 이름만 같아도 가려지게 되어있다(Item 33). 따라서 새로 정의한 위치지정 new와 delete 때문에 표준버전들이 가리지 않도록 주의해야한다. 좋은 방법은, 기본 클래스 하나를 만들고, 이 안에 new와 delete의 기본 형태를 전부 넣어두는 것이다. 그 다음 상속과 using 선언을 사용해서 표준 형태를 파생 클래스로 끌어오고, 원하는 사용자 정의 형태를 선언하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class StandardNewDeleteForms { public: // 기본형 static void * operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); } static void operator delete(void * pMemory) throw() { ::operator delete(pMemory); } // 위치지정 static void * operator new(std::size_t size, void *ptr) throw() { return ::operator new(size, ptr); } static void operator delete(void * pMemory, void * ptr) throw() { ::operator delete(pMemory, ptr); } // 예외불가 static void * operator new(std::size_t size, const std::nothrow_t\u0026amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void * pMemory, const std::nothrow_t\u0026amp;) throw() { ::operator delete(pMemory); } }; class Widget : public StandardNewDeleteForms { public: // StandardNewDeleteForms의 표준 형태가 Widget 내부에서 보이도록 만든다. using StandardNewDeleteForms::operator new; using StandardNewDeleteForms::operator delete; // 새롭게 정의한 위치지정 new와 그와 짝이 맞는 위치지정 delete static void * operator new(std::size_t size, std::ostream\u0026amp; logStream) throw(std::bad_alloc); static void operator delete(void *pMemory, std::ostream\u0026amp; logStream) throw(); }; ","date":"2023-01-08T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-08/","title":"[Effective C++] Chapter 8. new와 delete를 내 맘대로"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 41: 템플릿 프로그래밍의 천릿길도 암시적 인터페이스와 컴파일 타임 다형성부터 클래스와 템플릿은 모두 인터페이스와 다형성을 제공한다. 하지만 세부적인 차이점이 있다. 클래스의 인터페이스와 다형성 클래스의 경우, 인터페이스가 명시적(explicit interface) 이어서 함수의 시그니처(함수 이름, 매개변수 타입, 반환 타입 등)를 중심으로 구성되어 있다. 그리고 다형성은 런타임(runtime polimorphism) 에 가상 함수를 통해 나타난다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Widget { public: Widget(); virtual ~Widget(); virtual std::size_t size() const; virtual void normalize(); void swap(Widget\u0026amp; other); }; void doProcessing(Widget\u0026amp; w) // w는 Widget 타입이므로 Widget 인터페이스를 지원해야 한다. // 그리고 이 인터페이스는 Widget 소스 코드를 보면 알 수 있다. (명시적 인터페이스) // Widget 타입 인터페이스를 지원하지 않으면 컴파일이 안된다. { if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastyWidget) { Widget temp(w); temp.normalize(); // Widget의 멤버 함수 중 몇 개는 가상 함수이다. // 그래서 런타임에 w의 동적 타입을 기반으로 해서 // 특정 함수 호출이 이루어진다. (런타임 다형성) temp.swap(w); } } 템플릿의 인터페이스와 다형성 반면 템플릿의 경우, 인터페이스가 임시적(implicit interface) 이어서 유효 표현식(expression)에 기반을 두어 구성된다. 그리고 다형성은 컴파일(complie-time polymorphism) 중에 템플릿 인스턴스화와 함수 오버로딩 모호성 해결을 통해 나타난다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename T\u0026gt; void doProcessing(T\u0026amp; w) { // w는 T 타입이다. // 아래 if문의 결과를 bool로 낼 수 있어야 하며, // normalize, swap 멤버 함수를 지원해야 하는 타입이다. (암시적 인터페이스) // 이것들을 T 타입이 지원하지 않으면 컴파일이 안된다. if (w.size() \u0026gt; 10 \u0026amp;\u0026amp; w != someNastyWidget) // 또한 컴파일 도중에 템플릿이 인스턴스화된다. // 호출되는 함수는 인스턴스화된 함수 템플릿에 어떤 템플릿 매개변수가 들어가느냐에 따라 달라진다. (컴파일 타임 다형성) { T temp(w); temp.normalize(); temp.swap(w); } } Item 42: typename의 두 가지 의미를 제대로 파악하자 템플릿 매개변수를 선언할 때 템플릿 매개변수를 선언할 때 class와 typename은 완전히 똑같은 의미를 가진다. 1 2 template\u0026lt;class T\u0026gt; class Widget; template\u0026lt;typename T\u0026gt; class Widget; 중첩 의존 타입 이름을 식별할 때 의존 이름(dependent name) 템플릿 매개변수에 종속된 템플릿 내의 이름이다. 중첩 의존 이름(nested dependent name) 의존 이름이 어떤 클래스 안에 중첩되어 있는 경우이다. 중첩 의존 타입 이름(nested dependent type name) 중첩 의존 이름인데 타입을 참조한다는 뜻이다. 비의존 이름(non-dependent name) 템플릿 매개변수와 상관 없는 이름이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { if (container.size() \u0026gt;= 2) { // iter는 C::const_iterator 타입이다. // 따라서 템플릿 매개변수인 C에 따라서 iter의 타입이 달라진다. (의존 이름) C::const_iterator iter(container.begin()); // 에러! ++iter; // value는 템플릿 매개변수 C와 상관없이 int인 타입이다. (비의존 이름) int value = *iter; std::cout \u0026lt;\u0026lt; value; } } 중첩 의존 이름은 기본적으로 타입이 아닌 것으로 해석된다. 1 2 3 4 5 6 7 8 9 template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { C::const_iterator * x; // C::const_iterator가 타입이 아니면 어떻게 될까? // 예를 들면 const_iterator라는 이름을 가진 정적 데이터 멤버가 C에 들어있을 수도 있다. // 그러면 위 식은 곱셈이 될 수도 있다. // 그래서 C++은 이 모호성을 해결하기 위해 중접 의존 이름은 기본적으로 타입이 아닌 것으로 본다. } typename을 붙여서 중첩 의존 이름이 타입이라고 알려줄 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename C\u0026gt; void print2nd(const C\u0026amp; container) { if (container.size() \u0026gt;= 2) { // typename을 붙인다. typename C::const_iterator iter(container.begin()); ++iter; int value = *iter; std::cout \u0026lt;\u0026lt; value; } } 예외 기본 클래스 리스트, 멤버 초기화 리스트 내의 기본 클래스 식별자에서는 typename을 붙여주면 안 된다. 1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; class Derived : public Base\u0026lt;T\u0026gt;::Nested // 기본 클래스 리스트 { public: explicit Derived(int x) : Base\u0026lt;T\u0026gt;::Nested(x) // 멤버 초기화 리스트 내의 기본 클래스 식별자 { typename Base\u0026lt;T\u0026gt;::Nested temp; } } 긴 타입 이름을 간편하게 사용하기 위해 typedef를 사용할 수 있다. 1 2 3 4 5 6 7 template\u0026lt;typename IterT\u0026gt; void workWithIterator(IterT iter) { typedef typename std::iterator_traits\u0026lt;IterT\u0026gt;::value_type value_type; // (특성 정보 클래스에 속한 value_type 등의 멤버 이름은 // 그 멤버 이름과 똑같이 typedef 이름을 짓는게 관례이다.) } Item 43: 템플릿으로 만들어진 기본 클래스 안의 이름에 접근하는 방법을 알아 두자 어떤 템플릿으로부터 파생 클래스가 인스턴스화 될 때, 컴파일러는 기본 클래스에 대해 아무것도 모르는 것으로 가정한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class CompanyA { void sendClearText(); void sendEncrypted(); }; template\u0026lt;typename C\u0026gt; class MsgSender { public: void sendClear() { C c; c.sendClearText(); } void sendSecret() { C c; c.sendEncrypted(); } }; template\u0026lt;typename C\u0026gt; class LoggingMsgSender : public MsgSender\u0026lt;C\u0026gt; { public: void sendClearMsg() { sendClear(); // 컴파일 에러! // LoggingMsgSender는 // MsgSender의 어떤 인스턴스에서 파생되었는지를 모른다. // 즉, C가 무엇인지 모르므로 // MsgSender\u0026lt;C\u0026gt;가 어떤 형태인지 알 방법이 없다. } }; class CompanyB { void sendEncrypted(); }; // CompanyB가 LoggingMsgSender의 템플릿 매개변수 C가 되면 어떻게 되겠는가? // sendClear에서는 CompanyB의 sendClearText를 부를텐데 // CompanyB는 sendClearText 함수가 없다. // 따라서 컴파일 에러가 옳은 판단을 한 것이라 볼 수 있겠다. 완전 템플릿 특수화(total template specialization) 1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;\u0026gt; class MsgSender\u0026lt;CompanyB\u0026gt; // MsgSender 템플릿이 CompanyB 타입에 대해 특수화되었고, // 이 템플릿의 매개변수들이 하나도 빠짐없이 구체적인 타입으로 정해진다. { public: void sendSecret() { // ... } }; 템플릿화된 기본 클래스의 함수를 호출하는 법 (1) this-\u0026gt;를 붙인다. 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename C\u0026gt; class LoggingMsgSender : public MsgSender\u0026lt;C\u0026gt; { public: void sendClearMsg() { this-\u0026gt;sendClear(); // sendClear 함수가 상속되는 것으로 가정한다. } }; (2) using 선언을 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename C\u0026gt; class LoggingMsgSender : public MsgSender\u0026lt;C\u0026gt; { public: using MegSender\u0026lt;C\u0026gt;::sendClear; // 컴파일러에게 sendClear 함수가 기본 클래스에 있다고 // 가정하라고 알려준다. void sendClearMsg() { sendClear(); } }; (3) 기본 클래스의 함수라는 점을 명시적으로 지정한다. 하지만 이런식으로 명시적 한정을 하면, 가상 함수 바인딩이 무시될 수 있다. 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename C\u0026gt; class LoggingMsgSender : public MsgSender\u0026lt;C\u0026gt; { public: void sendClearMsg() { MsgSender\u0026lt;C\u0026gt;::sendClear(); // sendClear 함수가 상속되는 것으로 가정한다. } }; Item 44: 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자 템플릿을 사용하면 비슷비슷한 클래스와 함수가 여러 벌 만들어지고, 템플릿 매개변수에 종속되지 않은 템플릿 코드는 코드 비대화(code bloat) 의 원인이 된다. 비타입 템플릿 매개변수로 생기는 코드 비대화의 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template\u0026lt;typename T, std::size_t n\u0026gt; // 비타입 템플릿 매개변수인 n이 있다. class SquareMatrix { public: void invert(); }; int main() { SquareMatrix\u0026lt;double, 5\u0026gt; sm1; // n이 5인 SquareMatrix 인스턴스가 만들어진다. sm1.invert(); SquareMatrix\u0026lt;double, 10\u0026gt; sm2; // n이 10인 SquareMatrix 인스턴스가 만들어진다. sm2.invert(); } 해결 방법 공통적인 부분을 기본 클래스로 만들고, 그것을 호출한다. 데이터는 클래스의 멤버로 만들어서 관리하면 되겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 독립적인 기본 클래스를 만들어 둔다. template\u0026lt;typename T\u0026gt; class SquareMatrixBase { private: std::size_t size; T * pData; // 데이터를 포인터로 가리킨다. protected: SquareMatrixBase(std::size_t n, T * pMem) : size(n), pData(pMem) {} void setDataPtr(T * ptr) { pData = ptr; } void invert(std::size_t matrixsize); }; template\u0026lt;typename T, std::size_t n\u0026gt; class SquareMatrix: private SquareMatrixBase\u0026lt;T\u0026gt; { private: using SquareMatrixBase\u0026lt;T\u0026gt;::invert; T data[n * n]; // 실제 데이터 public: SquareMatrix : SquareMatrixBase\u0026lt;T\u0026gt;(n, data) {} // 기본 클래스에 데이터에 대한 포인터를 보낸다. void invert() { this-\u0026gt;invert(n); } // 기본 클래스를 호출한다. // 이렇게 하면 n이 달라도 오직 한 가지의 SquareMatrixBase 클래스를 공유하게 된다. }; 타입 매개변수로 생기는 코드 비대화의 경우 예를 들어, vector\u0026lt;int\u0026gt;와 vector\u0026lt;long\u0026gt;의 경우\n대부분의 플랫폼에서 int, long의 이진 표현구조가 동일하므로, 두 멤버 함수는 똑같게 나올 것이다. 해결 방법\n동일한 이진 표현구조를 가지고 인스턴스화되는 타입들은 한 가지 함수 구현을 공유하게 만듦으로써 비대화를 감소시킬 수 있다. 예를 들어, 포인터 타입의 경우 타입미정(untyped) 포인터(void 포인터)로 동작하는 버전을 호출하는 식으로 만들 수 있겠다. vector, deque, list 등이 이렇게 구현되어 있다. Item 45: \u0026ldquo;호환되는 모든 타입\u0026quot;을 받아들이는 데는 멤버 함수 템플릿이 직방! 포인터는 암시적 변환(implicit conversion)을 지원한다. 이런 식의 타입 변환을 사용자 정의 스마트 포인터로 흉내 내려면 어떻게 해야할까? 1 2 3 4 5 6 7 8 9 10 11 class Top {}; class Middle : public Top {}; class Bottom : public Middle {}; int main() { // 이렇게 호환되는 모든 타입끼지 변환되도록 하고 싶다. Top * pt1 = new Middle; // Middle* -\u0026gt; Top* Top * pt2 = new Bottom; // Bottom* -\u0026gt; Top* const Top * pct = pt1; // Top* -\u0026gt; const Top* } 변환 가능한 모든 타입의 개수만큼 생성자를 만들기에는 무리다. 무제한으로 늘어날 것이다. 그렇다면 템플릿을 써서 일반화 복사 생성자(generalized copy constructor) 를 만들어보자. 하지만 어떤 타입이든 다 변환이 되면 안 되고 호환되는 타입들끼리만 변환이 되야 할 것이다. 따라서 shared_ptr에서 쓰는 방법을 따라서 get 멤버 함수를 가지고 포인터를 반환하게 만든 후, 생성자에서 이것을 이용해 변환에 제약을 줘볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template\u0026lt;typename T\u0026gt; class SmartPtr { private: T * heldPtr; public: // 이렇게 같은 템플릿을 써서 인스턴스화되지만 // 타입이 다른 객체로부터 원하는 객체를 만들어주는 생성자를 // (SmartPtr\u0026lt;U\u0026gt;로 부터 SmartPtr\u0026lt;T\u0026gt;를 만들어내는) // 일반화 복사 생성자라고 한다. template\u0026lt;typename U\u0026gt; SmartPtr(const SmartPtr\u0026lt;U\u0026gt;\u0026amp; other) : heldPtr(other.get()) {} // other의 포인터로 이 포인터를 초기화한다. // 따라서 U*에서 T*로 암시적 변환이 가능할 때만 컴파일 에러가 나지 않는다. T * get() const { return heldPtr; } }; int main() { SmartPtr\u0026lt;Top\u0026gt; pt1 = SmartPtr\u0026lt;Middle\u0026gt;(new Middle); SmartPtr\u0026lt;Top\u0026gt; pt2 = SmartPtr\u0026lt;Bottom\u0026gt;(new Bottom); SmartPtr\u0026lt;const Top\u0026gt; pct = pt1; } shared_ptr은 어떻게 복사 생성 연산과 대입 연산을 하고 있을까? 주의할 점은 일반화 복사 생성자와 일반화 복사 대입 연산자는 보통의 복사 생성자와 보통의 복사 대입 연산자가 아니므로, 보통의 복사 생성자와 보통의 복사 대입 연산자도 선언해 줘야 한다는 점이다. 안 그러면 shared_ptr으로부터 shared_ptr로 생성될 때 컴파일러는 자동으로 보통의 복사 생성자를 하나 만들어버린다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template\u0026lt;class T\u0026gt; class shared_ptr { public: // 보통의 복사 생성자 shared_ptr(shared_ptr const \u0026amp; r); // shared_ptr로부터 shared_ptr 생성자 호출이 가능하다. template\u0026lt;class Y\u0026gt; shared_ptr(shared_ptr\u0026lt;Y\u0026gt; const \u0026amp; r); // 모든 기본 제공 포인터로부터 shared_ptr 생성자 호출이 가능하다. template\u0026lt;class Y\u0026gt; explicit shared_ptr(Y * p); // 암시적 변환을 허용하지 않기 위해 explicit이 붙었다. // weak_ptr로부터 shared_ptr 생성자 호출이 가능하다. template\u0026lt;class Y\u0026gt; explicit shared_ptr(weak_ptr\u0026lt;Y\u0026gt; const \u0026amp; r); // auto_ptr로부터 shared_ptr 생성자 호출이 가능하다. template\u0026lt;class Y\u0026gt; explicit shared_ptr(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); // auto_ptr은 const가 없다. // 왜냐하면 복사연산으로 객체가 수정되면 복사된 쪽 하나만 유효해야 되기 때문이다. // 보통의 복사 대입 연산자 shared_ptr\u0026amp; operator=(shared_ptr cosnt \u0026amp; r); // shared_ptr에서 shared_ptr로 대입이 가능하다. template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(shared_ptr\u0026lt;Y\u0026gt; const \u0026amp; r); // auto_ptr에서 shared_ptr로 대입이 가능하다. template\u0026lt;class Y\u0026gt; shared_ptr\u0026amp; operator=(auto_ptr\u0026lt;Y\u0026gt;\u0026amp; r); }; Item 46: 타입 변환이 바람직할 경우 비멤버 함수를 클래스 템플릿 안에 정의해 두자 모든 매개변수에 대해 암시적으로 타입 변환이 되도록 하기 위해서는? 비멤버 함수를 사용해야 했다 (Item 24) 하지만 템플릿인 경우에는 어떻게 될까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template\u0026lt;typename T\u0026gt; class Rational { public: Rational(const T \u0026amp; numerator = 0, const T \u0026amp; denominator = 1); const T numerator() const; const T denominator() const; }; template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { // ... } int main() { Rational\u0026lt;int\u0026gt; oneHalf(1, 2); Rational\u0026lt;int\u0026gt; result = oneHalf * 2; // 컴파일 에러! // 컴파일러는 2의 T가 무엇인지 알 방도가 없다. // 왜냐하면 템플릿 인자 추론과정에서는 // 암시적 타입 변환이 고려되지 않기 때문이다. } 해결 방법 프렌드 함수를 이용해서 템플릿으로의 성격을 주지 않고 함수를 만들 수 있겠다. Rational\u0026lt;T\u0026gt;가 인스턴스화 될 때 T의 정확한 정보를 알 수 있으므로 프렌드 선언이 가능하다. 프렌드 함수는 일반 함수이므로, 컴파일러는 암시적 변환 함수를 적용시킬 수 있게 된다. 1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;typename T\u0026gt; class Rational { public: // 프렌드 함수 friend const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); // 클래스 안에서 정의가 되었으므로 암시적으로 인라인 함수가 된다. } }; 참고로 클래스 템플릿 내부에서는 템플릿의 이름을 그 템플릿 및 매개변수의 줄임말로 쓸 수 있다. 즉, Rational\u0026lt;T\u0026gt; 안에서는 Rational이라고만 써도 Rational\u0026lt;T\u0026gt;로 먹힌다. 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; class Rational { public: // 위 코드와 같은 코드이다. friend const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } }; 인라인 함수에 의한 영향력을 최소화하려면, 클래스 바깥에서 정의된 도우미 함수만 호출하는 식으로 바꿀 수도 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u0026lt;typename T\u0026gt; class Rational; // 전방 선언 // 도우미 함수 템플릿 선언 template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs); template\u0026lt;typename T\u0026gt; class Rational { public: friend const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return doMultiply(lhs, rhs); // 도우미 함수만 호출한다. } }; // 도우미 함수 템플릿 정의 template\u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; doMultiply(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) { return Rational\u0026lt;T\u0026gt;(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } Item 47: 타입에 대한 정보가 필요하다면 특성정보 클래스를 사용하자 반복자의 종류 종류 설명 입력 반복자\n(input iterator) 전진만 가능, 딱 한 번 읽기만 가능 출력 반복자\n(output iterator) 전진만 가능, 딱 한 번 쓰기만 가능 순방향 반복자\n(forward iterator) 전진만 가능, 여러번 읽기 쓰기 가능 양방향 반복자\n(bidirectional iterator) 순방향 반복자 + 뒤로 가기 가능 임의 접근 반복자\n(random access iterator) 양방향 반복자 + 임의의 거리만큼 앞뒤로 이동을 상수 시간 안에 가능 C++ 표준 라이브러리에는 이 다섯 개의 반복자 범주를 식별하는 데 쓰이는 태그(tag) 구조체가 정의되어 있다. 1 2 3 4 5 struct input_iterator_tag(); struct output_iterator_tag(); struct forward_iterator_tag() : public input_iterator_tag; struct bidirectional_iterator_tag() : public forward_iterator_tag; struct random_access_iterator_tag() : public bidirectional_iterator_tag; STL은 컨테이너(container), 반복자(iterator), 알고리즘(algorithm) 외에 유틸리티(utility)라고 불리는 템플릿도 몇 개 들어있다. 유틸리티 안에 있는 템플릿 중 하나가 advance 라는 것인데, 이것은 지정된 반복자를 지정된 거리만큼 이동시킨다. 반복자의 종류에 따라 구현할 수 있는 방법이 다르겠다. 왜냐하면 임의 접근 반복자는 상수 시간 안에 지정된 거리로 바로 이동 가능하지만, 나머지 반복자는 한 칸씩 이동해서 선형 시간 안에 지정된 거리로 이동이 가능하기에. 그렇다면 반복자 타입을 어떻게 판별해서 분기할 수 있을까? 특성정보(traits) 컴파일 도중에 어떤 주어진 타입의 정보를 얻을 수 있게 하는 객체를 지칭하는 개념이다. 특성정보가 되기 위해서는 기본제공 타입과 사용자 정의 타입에서 모두 돌아가야 한다. 기본제공 타입에 대해서 쓸 수 있어야 한다는 말은, 그 안에 정보를 넣을 수 없으므로, 즉 특성정보는 그 타입 외부에 존재해야 한다는 결론이 나온다. 표준적인 방법은 템플릿과 템플릿의 특수화버전에 특성정보를 넣어서 제공하는 것이다. 관례적으로 struct로 구현한다. 그리고 특성정보 클래스라고 부른다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u0026lt; ... \u0026gt; class deque { public: // deque의 이터레이터는 임의 접근 반복자이다. class iterator { public: // (1) 사용하는 반복자 타입을 iterator_category라는 이름의 typedef로 한다. typedef random_access_iterator_tag iterator_category; } }; // 특성정보 클래스 template\u0026lt;typename IterT\u0026gt; struct iterator_traits { // (1) 그리고 똑같이 재생한다. typedef typename IterT::iterator_category iterator_category; } // (2)포인터 타입을 따로 처리하기위해 // 부분 템플릿 특수화 버전을 제공한다. template\u0026lt;typename IterT*\u0026gt; struct iterator_traits\u0026lt;IterT*\u0026gt; { typedef random_access_iterator_tag iterator_category; } 그렇다면 advance의 코드는 어떻게 구현하면 될까? 그 안에서 런타임에 typeid를 사용해서 타입을 비교하는 건 컴파일 에러가 발생한다. (Item 48) 그리고 애초에 컴파일 타임에 알 수 있는 타입 정보를 굳이 런타임에 비교해야 할까? 오버로딩을 사용해서 타입에 대한 평가를 컴파일 도중에 실시하고 조건 처리를 할 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 임의 접근 반복자의 경우 사용하는 doAdvance 구현 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::random_access_iterator_tag) { iter += d; } // 양방향 반복자의 경우 사용하는 doAdvance 구현 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::bidirectional_iterator_tag) { if (d \u0026gt;= 0) { while(d--) ++iter; } else { while(d++) --iter; } } // 입력 반복자의 경우 사용하는 doAdvance 구현 template\u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::input_iterator_tag) { if (d \u0026lt; 0) { throw std::out_of_range(\u0026#34;Negative distance\u0026#34;); } while(d--) ++iter; } // 그러면 advance는 위의 오버로딩 함수들을 사용하면 된다. template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { doAdvance(iter, d, typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category()); // iter의 반복자 범위에 적합한 doAdvance의 오버로딩 버전을 호출한다. } Item 48: 템플릿 메타프로그래밍, 하지 않겠는가? 템플릿 메타프로그래밍(template metaprogramming: TMP) 템플릿에 기반한 프로그래밍을 함으로써 컴파일 타임에 작업을 하는 것이다. 런타임이 아니라 컴파일 타임에 이루어지므로, 선행 에러 탐지와 높은 런타임 효율을 거머쥘 수 있다. Item 47의 advance에서 typeid를 사용해서 타입을 런타임에 비교할 경우 컴파일 에러가 났다. 특성정보를 활용해서 TMP를 사용하면 훨씬 효율적으로 구현할 수 있었다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d) { if (typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iteratortag)) { iter += d; // 컴파일 에러! // iter가 std::list\u0026lt;int\u0026gt;::iterator 이라면 // list는 std::bidirectional_iterator_tag이므로 // 애초에 +=를 지원하지 않아서 컴파일 자체가 안 된다. } else { if (d \u0026gt;= 0) { while(d--) ++iter; } else { while(d++) --iter; } } } int main() { std::list\u0026lt;int\u0026gt;::iterator iter; advance(iter, 10); } 또한 TMP을 사용한 루프는 재귀식 템플릿 인스턴스화(recursive template instantiation) 를 사용한다. 꼬리에 꼬리를 물고 만들어지는 템플릿 인스턴스화 버전마다 자체적으로 value의 사본을 갖게 되고, 각각의 value에는 값이 담긴다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;unsigned n\u0026gt; struct Factorial { enum { value = n * Factorial\u0026lt;n-1\u0026gt;::value }; }; template\u0026lt;0\u0026gt; struct Factorial { enum { value = 1 }; }; int main() { std::cout \u0026lt;\u0026lt; Factorial\u0026lt;5\u0026gt;::value; // 120을 런타임 계산 없이 출력 } TMP가 C++ 프로그래밍에서 실력 발휘하는 예 (1) 치수 단위(dimensional unit)의 정확성 확인 과학 기술 분야의 응용프로그램을 만들 때, 컴파일 도중에 치수 단위(예를 들면 질량, 거리, 시간 등)가 똑바로 쓰였는지 알 수 있다. (2) 행렬 연산의 최적화 행렬 연산의 경우 예를 들어, 네 개의 행렬을 곱하면 네 개의 임시행렬과 네 번의 루프가 순차적으로 이루어진다. TMP을 사용하면 컴파일 시간에 계산이 가능하겠다. (3) 맞춤식 디자인 패턴 구현의 생성 따로따로 정책(policy)들을 나타내는 템플릿을 만들어 놓고, 임의대로 조합해서 사용자 취향에 맞는 동작을 하는 패턴으로 구현할 수 있다. ","date":"2023-01-07T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-07/","title":"[Effective C++] Chapter 7. 템플릿과 일반화 프로그래밍"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 32: public 상속 모형은 반드시 \u0026ldquo;is-a\u0026quot;를 따르도록 하자 반드시 기억하자! public 상속은 \u0026ldquo;is-a\u0026quot;를 의미한다!\n이것은 기본 클래스는 더 일반적인 개념을 나타내며 파생 클래스는 더 특수한 개념을 나타낸다는 의미이다. public 상속은 Base 클래스가 가진 모든 것들이 파생 클래스 객체에도 그대로 적용된다고 단정하는 상속이다. Item 33: 상속된 이름을 숨기는 일은 피하자 이름을 숨긴다는 것은 유효범위(scope) 와 관계가 있다. 1 2 3 4 5 6 7 8 9 10 int x; // 전역 변수 void someFunc() { double x; // 지역 변수 // someFunc의 유효범위 안쪽에 있으므로 // int x를 가린다 std::cout \u0026lt;\u0026lt; x; } 파생 클래스의 이름은 기본 클래스의 이름을 가린다. 매개변수가 다르거나 말거나 상관이 없다. 비가상이건 가상이건 상관이 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Base { private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); }; class Derived : public Base { public: virtual void mf1(); // Base의 mf1을 다 가려버린다 void mf3(); // Base의 mf3을 다 가려버린다 void mf4(); }; // 클래스 유효범위에 대한 예시 void Derived::mf4() { mf2(); // 지역 유효범위(mf4)에 mf2를 찾는다. // 없다면 Derived 클래스 유효범위에서... // 없다면 Base 클래스 유효범위에서... // 없다면 Base를 둘러싼 네임스페이스를... // ... } int main() { Derived d; int x; d.mf1(); // Derived::mf1 호출 d.mf1(x); // 에러! d.mf2(); // Base::mf2 호출 d.mf3(); // Derived::mf3 호출 d.mf3(x); // 에러! } 가려진 이름을 다시 볼 수 있게 하는 방법 (1) using 선언 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Derived : public Base { public: // using 선언으로 // Base에 있는 것들 중 mf1, mf3 이름을 가진 것들을 // Derived에서 볼 수 있도록 (public 멤버로) 만든다. using Base::mf1; using Base::mf3; virtual void mf1(); void mf3(); void mf4(); }; int main() { Derived d; int x; // 모두 다 잘 된다. d.mf1(); d.mf1(x); // Base::mf1 호출 d.mf2(); d.mf3(); d.mf3(x); // Base::mf3 호출 } (2) 전달 함수 private 상속이라면, 그리고 mf1는 매개변수가 없는 버전만 상속하고 싶다면? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Derived : private Base { public: // 전달 함수 virtual void mf1() { Base::mf1(); } }; int main() { Derived d; int x; d.mf1(); // Derived::mf1 호출 d.mf1(x); // 에러! } Item 34: 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자 인터페이스 상속과 구현 상속은 다르다. 예시를 통해 살펴보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 추상 클래스 class Shape { public: // 순수 가상 함수 virtual void draw() = 0; // 비순수 가상 함수 virtual void error(const std::string\u0026amp; msg); // 비가상 함수 int objectID() const; }; class Rectangle : public Shape {}; class Ellipse : public Shape {}; public 상속이다. 인터페이스는 항상 상속하게 되어 있다. 순수 가상 함수 물려받은 구체 클래스가 순수 가상 함수를 다시 선언해야 한다. 전형적으로 추상 클래스 안에서 정의를 갖지 않는다. 함수의 인터페이스만을 물려준다.\n순수 가상 함수를 추상 클래스 안에서 정의할 수도 있다. 단, 호출하려면 반드시 클래스 이름을 한정자로 붙여 주어야만 한다. 1 2 3 4 5 6 7 Shape *ps = new Shape; Shape *ps1 = new Rectangle; Shape *ps2 = new Ellipse; // Shape::draw를 호출한다. ps1-\u0026gt;Shape::draw(); ps2-\u0026gt;Shape::draw(); 비순수 가상 함수 \u0026ldquo;이 함수는 여러분이 지원해야 합니다. 하지만 굳이 새로 만들 생각이 없다면 기본 버전을 그냥 써도 무방합니다.\u0026rdquo; 함수의 인터페이스뿐만 아니라 그 함수의 기본 구현도 물려준다.\n때로는 함수 인터페이스와 기본 구현을 한꺼번에 지정하는 것은 위험할 수도 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Airplane { public: virtual void fly(const Airport\u0026amp; destination); }; void Airplane::fly(const Airport\u0026amp; destination) { // 기본 날기 동작 } class ModelA : public Airplane {}; class ModelB : public Airplane {}; class ModelC : public Airplane {}; // fly와 다른 날기 동작을 해야 하는 ModelC가 추가되었는데, // 까먹고 fly를 재정의 하지 않았다면? int main() { Airport PDX; Airplane *pa = new ModelC; pa-\u0026gt;fly(PDX); // Airplane::fly가 호출되고 말았다! } 해결 방법 가상 함수의 인터페이스와 그것의 기본 구현을 분리한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Airplane { public: virtual void fly(const Airport\u0026amp; destination) = 0; protected: void defaultFly(const Airport \u0026amp; destination); // 파생 클래스에서 재정의하면 안되므로 비가상 함수이다. // protected로 비행기류만 알고 있도록 한다. }; void Airplane::defaultFly(const Airport \u0026amp; destination) { // 기본 날기 동작 } class ModelA : public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { defaultFly(desination); // 기본 날기 동작 } }; // ModelB도 동일 class ModelC : public Airplane { public: virtual void fly(const Airport\u0026amp; destination) { // 새로운 날기 동작 } }; 비가상 함수 클래스 파생에 상관없이 변하지 않는 동작을 지정하는 데 쓰인다. 함수 인터페이스와 더불어 그 함수의 필수적인 구현(mandatory implementation)을 물려받게 한다.\nItem 35: 가상 함수 대신 쓸 것들도 생각해 두는 자세를 시시때때로 길러 두자 가상 함수 대신 쓸 수 있는 방법들은 없을까? 비가상 함수 인터페이스 관용구 사용하기 비가상 함수 인터페이스(non-virtual interface: NVI) 관용구 public 비가상 멤버 함수를 만들어서 private 가상 함수를 간접적으로 호출하게 만드는 방법이다. 템플릿 메서드(Template Method) 패턴이다. public 비가상 함수를 랩퍼(Wrapper)라고 부른다. 사전 작업과 사후 작업을 앞 뒤로 삽입할 수 있는 좋은 방법이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class GameCharacter { private: // 파생 클래스가 이 가상 함수를 재정의 할 수 있다. virtual int doHealthValue() const; public: // 비가상 함수 인터페이스 int healthValue() const { // ... 사전 작업 int retVal = doHealthValue(); // ... 사후 작업 return retVal; } }; 함수 포인터 사용하기 전략(Strategy) 패턴이다. 실행 도중에 계산 함수를 바꿀 수 있으며, 객체 마다 다른 함수를 실행하도록 할 수 있다. 계산 함수가 클래스 외부에 있기 때문에 클래스의 public 부분만을 사용해서 계산할 수 있다. 따라서 public이 아닌 데이터에도 접근해야만 계산할 수 있게 된다면, 프렌드로 하던지 public으로 접근하게 할 수 밖엔 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class GameCharacter; // 전방선언 // 계산 함수 int defaultHealthCalc(const GameCharacter\u0026amp; gc); class GameCharacter { private: // 계산 함수를 포인터로 가지고 있다. HealthCalcFunc healthFunc; public: // HealthCalcFunc은 // 반환타입이 int, 매개변수는 const GameCharacter\u0026amp;형인 함수에 대한 포인터를 나타낸다. typedef int (*HealthCalcFunc)(const GameCharacter\u0026amp;); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {} int healthValue() const { return healthFunc(*this); } }; class EvilBadGuy : public GameCharacter {}; // 다른 계산 함수들 int loseHealthQuickly(const GameCharacter\u0026amp;); int loseHealthSlowly(const GameCharacter\u0026amp;); int main() { // 객체 마다 다르게 함수를 지정할 수 있다. // 런다임에 함수를 바꿀 수 있다. EvilBadGuy ebg1(loseHealthQuickly); EvilBadGuy ebg1(loseHealthSlowly); } tr1::function 사용하기 함수 포인터 대신 tr1::function을 사용하면 함수호출성 개체(callable entity: 함수 포인터, 함수 객체, 멤버 함수 포인터)를 모두 다룰 수 있다. 즉, 좀 더 일반화된 함수 포인터를 물게 되는 셈이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class GameCharacter { public: // HealthCalcFunc은 // 반환타입이 int, 매개변수는 const GameCharacter\u0026amp;형인 함수에 대한 tr1::function 을 나타낸다. typedef std::tr1::function\u0026lt;int (const GameCharacter\u0026amp;)\u0026gt; HealthCalcFunc; }; // (1) 반환타입이 short인 함수이다. short calcHeatlh(const GameCharacter\u0026amp;); // (2) 함수 객체를 만들기 위한 클래스이다. stuct HealthCalculator { int operator()(const GameCharacter\u0026amp;) const {} }; class GameLevel { public: // (3) 반환타입이 float인 멤버 함수이다. float health(const GameCharacter\u0026amp;) const; } int main() { // (1) EvilBadGuy ebg1(calcHealth); // (2) EvilBadGuy ebg2(HealthCalculator()); // (3) GameLevel currentLevel; EvilBadGuy ebg3(std::tr1::bind(\u0026amp;GameLevel::health, currentLevel, _1)); // GameLevel::health 함수를 사용하는데, // GameLevel::health는 암시적으로 GameLevel 객체가 있어야 한다. // 하지만 GameLevel::health의 매개변수는 GameCharacter 하나 뿐이다. // 그래서 currentLevel를 계산할 때 함께 사용하도록 묶어주고 있다. // _1은 첫 번째 자리의 매개변수가 자유 매개변수(free parameter)임을 나타내는 것이다. } 다른 클래스의 가상 함수로 만들기 고전적인 전략 패턴이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class GameCharacter; // 전방 선언 // 계산하는 함수를 나타내는 클래스를 따로 둔다. class HealthCalcFunc { public: // 그 안에 가상 함수로 계산을 한다. virtual int calc(const GameCharacter\u0026amp; gc) const {} }; HealthCalcFunc defaultHealthCalc; class GameCharacter { private: // 계산하는 클래스에 대한 포인터를 가지고 있다. HealthCalcFunc *pHealthCalc; public: explicit GameCharcter(HealthCalcFunc *phcf = \u0026amp;defaultHealthCalc) : pHealthCalc(phcf) {} int healthValue() const { return pHealthCalc-\u0026gt;calc(*this); } }; Item 36: 상속받은 비가상 함수를 파생 클래스에서 재정의하는 것은 절대 금물! 상속받은 비가상 함수를 파생 클래스에서 재정의 하면 이상한 일이 발생한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Base { public: // 비가상 함수 void mf(); }; class Derived : public Base { public: // 기본 클래스의 비가상 함수를 재정의 해버렸다. // Base::mf를 가려버린다. void mf(); }; int main() { Derived d; // 포인터 형만 다를 뿐 // 똑같이 d를 가리킨다. Base *pB = \u0026amp;d; Derived *pD = \u0026amp;d; pB-\u0026gt;mf(); // Base::mf 호출 pD-\u0026gt;mf(); // Derived::mf 호출 // 일관성 없는 이상한 동작이다! } 이렇게 되는 이유는 비가상 함수는 정적 바인딩(static binding) 으로 묶이기 때문이다. pB는 Base에 대한 포인터 형으로 선언되었기 때문에 pB를 통해 호출되는 비가상 함수는 항상 Base 클래스에 정의되어 있을 것이라고 결정해 버린다. 반면 가상 함수는 동적 바인딩(dynamically binding) 으로 묶인다. pB가 진짜로 가리키는 대상이 Derived 이므로 Derived::mf가 호출된다. Item 37: 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 절대로 재정의하지 말자 가상 함수로부터 상속받은 기본 매개변수는 절대 재정의 하면 안 된다. 가상 함수는 동적으로 바인딩되어 있지만 매개변수는 정적으로 바인딩되기 때문에 아래와 같은 일이 생긴다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Shape { public: enum ShapeColor { Red, Green, Blue }; // 기본 클래스의 가상 함수. // 기본 매개변수가 있으며 Red이다. virtual void draw(ShapeColor color = Red) const = 0; }; class Rectangle : public Shape { public: // 기본 매개변수가 Green이다. virtual void draw(ShapeColor color = Green) const; }; int main() { Shape * pr = new Rectangle; pr-\u0026gt;draw(); // Rectangle::draw(Shape::Red) 를 호출해 버린다! } 따라서 기본 클래스와 파생 클래스의 기본 매개변수는 같아야 한다. 그렇다고 기본 매개변수를 똑같이 설정해 버리면? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Shape { public: virtual void draw(ShapeColor color = Red) const = 0; }; class Rectangle : public Shape { public: virtual void draw(ShapeColor color = Red) const; // 코드 중복이다. // 게다가 Shape 클래스의 기본 매개변수가 변하면 // 파생 클래스에서 일일히 다 바꿔줘야 한다. }; 이럴 때는 비가상 인터페이스 관용구(NVI 관용구) 를 쓰면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Shape { private: virtual void doDraw(ShapeColor color) const = 0; public: // 비가상 함수 void draw(ShapeColor color = Red) const { doDraw(color); } }; class Rectangle : public Shape { private: virtual void doDraw(ShapeColor color) const; } Item 38: \u0026ldquo;has-a\u0026rdquo; 혹은 \u0026ldquo;is-implemented-in-terms-of\u0026quot;를 모형화할 때는 객체 합성을 사용하자 합성(composition) layering, containment, aggregation, embedding 등으로도 불린다. 어떤 객체가 그와 다른 타입의 객체들을 포함함으로써 생기는 관계를 일컫는 말이다. 객체 합성의 두 가지 뜻 (1) has-a 사물을 본 뜬 객체들은 소프트웨어의 응용 영역(application domain)에 속한다. 객체 합성이 응용 영역의 객체들 사이에서 일어나면 has-a 관계이다. (2) is-implemented-in-terms-of 응용 영역에 속하지 않는, 순수하게 시스템 구현만을 위한 객체들은 소프트웨어의 구현 영역(implementation domain)에 속한다. 객체 합성이 구현 영역의 객체들 사이에서 일어나면 is-implemented-in-terms-of 관계이다. has-a 예제 1 2 3 4 5 6 7 8 9 class Person { private: // Person과 has-a 관계이다. std::string name; Address address; PhoneNumber voiceNumber; PhoneNumber faxNumber; }; is-implemented-in-terms-of 예제 표준 C++ 라이브러리에 list 템플릿을 가지고 새로운 Set 템플릿을 만들고 싶다면? 1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;class T\u0026gt; class Set { private: // Set은 list 객체를 써서 구현된다.(is implemented in terms of) std::list\u0026lt;T\u0026gt; rep; public: bool member(const T\u0026amp; item) const; void insert(const T\u0026amp; item); void remove(const T\u0026amp; item); std::size_t size() const; }; Item 39: private 상속은 삼사숙고해서 구사하자 private 상속의 특징 is-implemented-in-terms-of 관계이다. 컴파일러는 파생 클래스 객체를 기본 클래스 객체로 변환하지 않는다. 기본 클래스로부터 물려받은 멤버는 모조리 private 멤버가 된다. 즉, 기본 클래스는 단지 구현 세부사항일 뿐이라는 것이다. 구현만 물려받을 수 있고, 인터페이스는 국물도 없다! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Person {}; class Student : private Person {}; void eat(const Person\u0026amp; p); int main() { Person p; Student s; eat(p); eat(s); // 에러! Stduent는 Person이 아니다. } 그럼 객체 합성을 해야할까 private 상속을 해야할까? private 상속은 반드시 필요할 때만 하자. (1) 비공개 멤버에 접근해야 할 때 (2) 가상 함수를 재정의 해야할 때 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Timer { public: explicit Timer(int tickFrequency); // 이것을 재정의 해서 Widget 전용 타이머로 사용하고 싶다. virtual void onTick() const; }; class Widget : private Timer // private 상속 { private: // Widget 전용 기능들을 추가해서 재정의한다. virtual void onTick() const; }; public 상속 + 객체 합성 private 상속 대신에 public 상속 + 객체 합성 조합으로 만들 수도 있다. 장점 파생 클래스에서 onTick을 재정의 할 수 없도록 막을 수 있다. 컴파일 의존성을 최소화할 수 있다. Widget 입장에서는 Timer와 관련된 어느 것도 include 할 필요가 없다. (아래 코드에서 WidgetTimer 정의를 밖으로 빼낸다면) 1 2 3 4 5 6 7 8 9 10 11 class Widget { private: class WidgetTimer : public Timer { public: virtual void onTick() const; }; WidgetTimer timer; }; private 상속은 EBO가 적용된다 반면, 객체 합성과 달리 private 상속은 EBO를 활성화 시킬 수 있다. 공백 기본 클래스 최적화(empty base optimization: EBO) C++은 크기가 0인 독립 구조의 객체가 생기는 것을 금지한다. 그래서 비정적 데이터 멤버가 없더라도 컴파일러가 슬그머니 char 한 개를 끼워넣는다. 하지만 private 상속을 하면 단일 상속인 경우에만에 한해서 크기가 0이 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Empty {}; class HoldsAnInt { private: int n; Empty e; // 크기가 0이 아니다. }; class HoldsAnInt : private Empty // 크기가 0이다. { private: int n; }; Item 40: 다중 상속은 심사숙고해서 사용하자 모호한 다중 상속 다중 상속(multiple inheritance: MI) 은 모호하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class BorrowableItem { public: void checkOut(); }; class ElectronicGadget { private: void checkOut(); }; class MP3Player : public BorrowableItem, public ElectronicGadget {}; int main() { MP3Player mp; mp.checkOut(); // 에러! // BorrowableItem의 함수인가? // ElectronicGadget의 함수인가? // ElectronicGadget::checkOut 은 private이므로 // BorrowableItem::checkOut 이 불릴 것 같지만 아니다. // 컴파일러는 최적 일치 함수를 찾은 후에 비로소 함수의 접근 가능성을 점검한다. // 그래서 이 경우에는 먼저 최적 일치 함수를 결정할 수 없어서 에러가 난다. // 이 모호성을 피하려면 아래와 같이 함수를 손수 지정해 주어야한다. mp.BorrowableItem::checkOut(); // 하지만 private 멤버에 접근하려고 한다는 에러가 나올 뿐이다. // 근본적으로 막을 수가 없다. } 죽음의 다이아몬드(deadly MI diamond) 문제 1 2 3 4 5 6 7 8 9 10 11 class File { private: std::string fileName; }; class InputFile : public File {}; class OutputFile : public File {}; class IOFile : public InputFile, public OutputFile {}; // IOFile 클래스는 fileName이 두 개인가? 하나인가? 가상 상속 File을 가상 기본 클래스(virtual base class) 로 만들면, 중복이 없어진다. 1 2 3 4 5 6 class File {}; class InputFile : virtual public File {}; class OutputFile : virtual public File {}; class IOFile : public InputFile, public OutputFile {}; 하지만 단점이 있다. 가상 상속 때문에 객체의 크기가 커진다. 그리고 데이터 멤버에 접근하는 속도도 느려진다. 또한 파생 클래스로 하여금 기본 클래스를 초기화시키도록 한다. 따라서 가상 클래스는 되도록 사용하지 말고, 혹시라도 꼭 사용해야 한다면 기본 클래스에는 데이터를 넣지 않는 쪽으로 하자. (자바와 닷넷에는 데이터를 못가지는 Interface라는 개념이 있다. ) 다중 상속을 잘 사용하는 법 인터페이스 클래스를 public으로 상속하고, 구현을 돕는 클래스를 private 상속하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 인터페이스를 갖고 있다. class IPerson { public: virtual ~IPerson(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; }; // 사용하면 유용한 함수들이 있다. class PersonInfo { public: explicit PersonInfo(DatabaseID pid); virtual ~PersonInfo(); virtual const char * theName() const; virtual const char * theBirthDate() const; virtual const char * valueDelimOpen() const; virtual const char * valueDelimClose() const; }; // 다중 상속을 한다. class CPerson : public IPerson, private PersonInfo { private: const char * valueDelimOpen() const { return \u0026#34;\u0026#34;; } const char * valueDelimClose() const { return \u0026#34;\u0026#34;; } public: explicit CPerson(DatabaseID pid) : PersonInfo(pid) {} virtual std::string name() const { return PersonInfo::theName(); } virtual std::string brithDate() const { return PersonInfo::theBirthDate(); } }; ","date":"2023-01-06T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-06/","title":"[Effective C++] Chapter 6. 상속, 그리고 객체 지향 설계"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 26: 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자 변수의 정의는 꼭 필요해지기 전까지 늦춘다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std::string encryptPassword(const std::string\u0026amp; password) { using namespace std; // 이 변수는 string encrypted; // 여기서 에러가 발생하면 전혀 쓰이지 않고, 괜히 생성자와 소멸자만 더 불린다. if (password.length() \u0026lt; MinimumPasswordLength) throw logic_error(\u0026#34;Password is too short\u0026#34;); // 따라서 실제로 쓰일 때까지 늦춰서, 이곳에 선언하는 게 좋겠다. // ... encrypted 변수를 설정한다 ... return encrypted; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void encrypt(std::string\u0026amp; s); std::string encryptPassword(const std::string\u0026amp; password) { // (BAD) std::string encrypted; // 쓸데없이 기본 생성자가 불린다. encrypted = password; // 그리고 대입한다. // (GOOD) 정의를 최대한 늦춰서, 정의와 동시에 초기화한다. std::string encrypted(password); encrypt(encrypted); return encrypted; } 루프에서 변수 정의의 위치는 어디가 좋을까? 대입이 생성자, 소멸자 쌍보다 비용이 덜 들고, 전체 코드에서 성능에 민감한 부분을 건드리지 않는다면 (1)이 좋겠다. 1 2 3 4 5 6 7 8 // (1) 루프 바깥쪽에 정의한다. // 생성자 1번 + 소멸자 1번 + 대입 n번 Widget w; // w의 접근 범위가 (2)보다 넓다. for (int i = 0; i \u0026lt; n; i++) { w = i에 따라 달라지는 값; } 1 2 3 4 5 6 7 // (2) 루프 안쪽에 정의한다. // 생성자 n번 + 소멸자 n번 for (int i = 0; i \u0026lt; n; i++) { Widget w(i에 따라 달라지는 값); } Item 27: 캐스팅은 절약, 또 절약! 잊지 말자 구형 스타일의 캐스트 보다는 C++ 스타일의 캐스트를 사용하자 C 스타일 캐스트 (구형 스타일의 캐스트) 표현 설명 (T) 표현식 표현식 부분을 T 타입으로 캐스팅한다. T (표현식) 표현식 부분을 T 타입으로 캐스팅한다. C++ 스타일 캐스트 구형 스타일 보다는 가시성이 좋아서 나중에 찾기 편리하다. 또한 캐스트의 목적을 좁혀서 지정하기 때문에 컴파일러쪽에서 사용 에러를 진단할 수 있다. 표현 설명 const_cast 객체의 상수성(constness)을 없앤다. 즉 상수 객체를 비상수 객체로 만든다. dynamic_cast 안전한 다운캐스팅(safe downcasting) 을 한다. 즉 해당 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지를 결정한다. 런타임 비용이 매우 높다. reinterpret_cast 하부 수준 캐스팅을 한다. (예를 들면, 포인터를 int로 바꾸는 등) 구현 환경에 의존적이어서 이식성이 없다. static_cast 암시적 변환을 강제로 진행한다. (예를 들면, 비상수 객체를 상수 객체로 바꾸거나, int를 double로 바꾸거나, void*를 일반 타입으로 바꾸거나, 기본 클래스의 포인터를 파생 클래스의 포인터로 바꾸는 등. 참고로 상수 객체를 비상수 객체로 만드는 건 const_cast 뿐이다. 캐스팅의 비용은 적지 않다. 캐스팅으로 명시적으로 바꾸든, 컴파일러가 암시적으로 바꾸든 간에 일단 타입 변환이 있으면 런타임에 실행되는 코드가 만들어진다. 1 2 3 4 5 int x, y; double d = static_cast\u0026lt;double\u0026gt;(x) / y; // 대부분의 컴퓨터 아키텍쳐에서 int와 double의 표현구조가 아예 다르기 때문에 // int 타입을 double 타입으로 캐스팅한 부분에서 코드가 만들어진다. 1 2 3 4 5 6 7 8 9 10 class Base {}; class Derived {}; Derived d; // Derived* -\u0026gt; Base* 의 암시적 변환이 이루어진다. Base * pb = \u0026amp;d; // 두 포인터의 값이 같지 않을 때도 있는데, 이럴 때는 // 포인터의 변위(offset)를 Derived* 포인터에 적용하여 Base* 포인터 값을 구하게 된다. // 이런 과정이 런타임에 일어난다! 파생 클래스에서 기본 클래스의 virtual 함수를 호출하는 법 캐스팅을 쓰지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Window { public: virtual void onResize(); }; class SpecialWindow : public Window { public: virtual void onResize() { // 기본 클래스의 onResize를 먼저 호출해야 한다면? // 이 코드는 *this의 사본을 생성하고 그 사본의 함수를 호출하게 된다. static_cast\u0026lt;Window\u0026gt;(*this).onResize(); // 이렇게 해야 *this의 기본 클래스의 함수를 호출하는 것이다. Window::onResize(); } } dynamic_cast를 되도록이면 피하자. dynamic_cast는 정말 느리게 구현되어 있으므로, 왠만하면 피하는 것이 좋다. 피하는 방법은\u0026hellip; (1) 파생 클래스 객체에 대한 포인터를 컨테이너에 담아둔다. 1 2 3 4 5 6 7 8 9 10 11 12 // 기본 클래스 객체에 대한 포인터를 가지고 있다. typedef std::vector\u0026lt;std::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; int main() { VPW winPtrs; for (VPW::iterator iter = windPtrs.begin(); iter != winPTrs.end(); ++iter) if (SpecialWindow *psw = dynamic_cast\u0026lt;SpecialWindow*\u0026gt;(iter-\u0026gt;get())) // 런타임에 dynamic_cast로 캐스팅해서 파생클래스의 함수를 호출한다. psw-\u0026gt;blink(); } 1 2 3 4 5 6 7 8 9 10 11 // 애초에 파생 클래스 객체에 대한 포인터를 가지고 있다면 // 런타임에 캐스팅이 필요없다. typedef std::vector\u0026lt;std::shared_ptr\u0026lt;SpecialWindow\u0026gt;\u0026gt; VPSW; int main() { VPSW winPtrs; for (VPSW::iterator iter = windPtrs.begin(); iter != winPTrs.end(); ++iter) (*iter)-\u0026gt;blink(); } (2) 아무것도 안 하는 virtual 함수를 기본 클래스에서 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Window { public: // 빈 가상 함수 제공 virtual void blick() {} } class SpecialWindow { public: virtual void blick() { // ... } } typedef std::vector\u0026lt;std::shared_ptr\u0026lt;Window\u0026gt;\u0026gt; VPW; int main() { VPW winPtrs; for (VPW::iterator iter = windPtrs.begin(); iter != winPTrs.end(); ++iter) (*iter)-\u0026gt;blink(); } 폭포식(cascading) dynamic_cast는 반드시 피하자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 이런 코드는 어떤 방식으로든지 바꿔놓아야 할 것이다. for (VPW::iterator iter = windPtrs.begin(); iter != winPTrs.end(); ++iter) { if (SpecialWindow1 * psw1 = dynamic_cast\u0026lt;SpecialWindow1*\u0026gt;(iter-\u0026gt;get())) { // ... } else if (SpecialWindow2 * psw2 = dynamic_cast\u0026lt;SpecialWindow1*\u0026gt;(iter-\u0026gt;get())) { // ... } else if (SpecialWindow3 * psw3 = dynamic_cast\u0026lt;SpecialWindow1*\u0026gt;(iter-\u0026gt;get())) { // ... } } Item 28: 객체 내부에 대한 \u0026ldquo;핸들\u0026quot;을 반환하는 코드는 되도록 피하자 객체 내부에 대한 핸들을 반환하면, 마음대로 내부 데이터를 수정할 수 있게 되어 위험하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Point { public: Point(int x, int y); void setX(int x); void setY(int y); }; struct RectData { Point ulhc; // upper left-hand corner Point lrhc; // lower right-hand corner }; class Rectangle { private: // 메모리 부담을 줄이려고 포인터로 사각형을 표현한다. std::shared_ptr\u0026lt;RectData\u0026gt; pData; public: // 객체 내부의 데이터에 대한 참조자를 리턴하고 있다. Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } }; int main() { Point coord1(0, 0); Point coord2(100, 100); // 상수 Rectangle 객체의 const Rectangle rec(coord1, coord2); // 내부 데이터에 접근해서 값을 바꿀 수 있게 되어버렸다! rec.upperLeft().setX(50); } 반환 타입이 const라면 안전할까? 핸들을 따라갔을 때 실제 객체의 데이터가 없는 무효참조 핸들(dangling handle) 이 될 수 있다는 문제가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Rectangle { public: // const를 붙였으므로 위와 같이 값을 바꾸는 것은 허용되지 않는다. const Point\u0026amp; upperLeft() const { return pData-\u0026gt;ulhc; } const Point\u0026amp; lowerRight() const { return pData-\u0026gt;lrhc; } }; class GUIObject {}; // GUIObject를 Rectangle로 바꾼다. const Rectangle boundingBox(const GUIObject\u0026amp; obj); int main() { GUIObject * pgo; // ... // 하지만 무효참조 핸들이 될 문제가 있다. const Point * pUpperLeft = \u0026amp;(boundingBox(pgo).upperLeft()); // boundingBox를 호출해서 Rectangle 임시 객체가 만들어진다. // 이것에 대해 upperLeft가 호출된다. // 이 문장이 끝나면 boundingBox의 반환값이 소멸된다. // 그 안에 있던 Point 객체들도 소멸된다. // 따라서 pUpperLeft 포인터가 가리키는 객체는 이제 날아가고 없다. } Item 29: 예외 안전성이 확보되는 그날을 위해 싸우고 또 싸우자! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class PrettyMenu { private: Mutex mutex; Image * bgImage; int imageChanges; public: void changeBackground(std::istream\u0026amp; imgSrc); }; // 위험천만한 함수 void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { lock(\u0026amp;mutex); delete bgImage; ++imageChanges; // (2) 자료구조가 이상해진다. bgImage = new Image(imgSrc); // 여기서 예외가 발생하면 unlock(\u0026amp;mutex); // (1) 자원이 새어나가고 } 예외 안정성을 갖춘 함수는 아래 보장들 중 하나를 제공한다. 명칭 설명 기본적인 보장\n(basic guarantee) 예외가 발생하면 실행 중인 프로그램에 관련된 모든 것들을 유효한 상태로 유지하겠다는 것이다. 즉 일관성(불변속성)이 유지되는 것이다. 강력한 보장\n(strong guarantee) 예외가 발생하면 프로그램의 상태를 절대로 변경하지 않겠다는 것이다. 즉 함수 호출이 없었던 것처럼 프로그램의 상태가 되돌아간다. 예외불가 보장\n(nothrow guarantee) 예외를 절대로 발생시키지 않겠다는 것이다. 위 함수가 강력한 보장을 제공하도록 해보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class PrettyMenu { private: // 자원관리 전담 포인터를 사용 -\u0026gt; 알아서 delete 되도록 한다 (Item 13) std::shared_ptr\u0026lt;Image\u0026gt; bgImage; }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { // 자원관리 전담 포인터를 사용 -\u0026gt; 알아서 unlock 되도록 한다 (Item 14) Lock m1(\u0026amp;mutex); bgImage.reset(new Image(imgSrc)); // 진짜 그림이 바뀌면 증가시키기로 한다. ++imageChanges; } 복사-후-맞바꾸기 전략 복사-후-맞바꾸기(copy-and-swap) 전략이란, 어떤 객체를 수정하고 싶으면 그 객체의 사본을 하나 만들어 놓고 그 사본을 수정하는 것이다. 그리고 수정이 예외 없이 완료되었을 때 수정된 객체를 원본 객체와 맞바꾼다. 이 전략은 \u0026lsquo;전부 바꾸거나 혹은 안 바꾸거나(all-or-nothing)\u0026rsquo; 방식으로 유지하려는 경우에 좋다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 이 전략은 보통 데이터를 모두 별도의 구현 객체에 넣어두고 struct PrettyMenuImpl { std::shared_ptr\u0026lt;Image\u0026gt; bgImage; int imageChanges; }; class PrettyMenu { private: // 그 구현 객체를 가리키는 포인터를 진짜 객체가 물고 있게 한다. (Item 31) // 이런 패턴을 pimpl 관용구라고 한다. std::shared_ptr\u0026lt;PrettyMenuImpl\u0026gt; pImpl; }; void PrettyMenu::changeBackground(std::istream\u0026amp; imgSrc) { using std::swap; Lock m1(\u0026amp;mutex); // 사본을 생성한다. std::shared_ptr\u0026lt;PrettyMenuImpl\u0026gt; pNew(new PrettyMenuImpl(*pImpl); // 사본을 수정한다. pNew-\u0026gt;bgImage.reset(new Image(imgSrc)); ++pNew-\u0026gt;imageChanges; // 사본과 진짜 객체를 맞바꾼다. swap(pImpl, pNew); } 하지만 강력한 예외 안전성을 함수 전체가 보장하지는 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void someFunc() { // ... 사본을 만든다. f1(); f2(); // f1, f2에서 강력한 예외 안전성을 보장하지 않는다면? // someFunc 역시 강력한 예외 안전성을 보장할 수 없다. // 특히 f1, f2에서 자신에만 국한되는 것들의 상태를 바꾸는게 아니라, // 비지역 데이터(ex. 데이터베이스 변경)에 대해 부수효과(side effect)를 준다면, // someFunc쪽에서는 어쩔 도리가 없다. // ... 사본과 진짜 객체를 맞바꾼다. } 일부만 안전성을 갖춘 시스템이라는 것은 존재하지 않는다. 일부가 예외에 취약하다면 전체가 위험한 것이다. 앞으로는 함수를 만들 때 예외 안전성을 갖추기 위해 진지하게 고민하는 버릇을 들이자. Item 30: 인라인 함수는 미주알고주알 따져서 이해해 두자 인라인 함수란?\n호출될 때 일반적인 함수의 호출 과정을 거치지 않고, 함수의 본문을 그대로 호출된 자리에 끼워넣는 함수이다. 장점\n함수 호출 비용이 면제 된다. 컴파일러가 함수 본문에 대해 문맥별(context-specific) 최적화를 걸기가 용이해진다. 인라인 요청 방법 암시적인 방법 1 2 3 4 5 6 7 8 9 10 11 12 class Person { private: int theAge; public: // 클래스 정의 안에 함수를 바로 정의한다. int age() const { return theAge; } } 명시적인 방법 1 2 3 4 5 6 7 // 함수 정의 앞에 inline 키워드를 붙인다. // (표준 라이브러리의 max 템플릿) template\u0026lt;typename T\u0026gt; inline const T\u0026amp; std::max(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? b : a; } 헤더 파일에 들어간다는 것만 생각하고 인라인화하면 안 된다. 인라인 함수와 템플릿은 대개 헤더 파일 안에 정의한다. 그렇다고 템플릿이 모두 인라인 함수여야 한다는 건 아니다. 템플릿 인스턴스화와 인라인은 완전히 별개의 개념으로 하등의 관련이 없다. 인라인 함수의 경우, 본문으로 바꿔치려면 컴파일러가 그 함수가 어떤 형태인지 알고 있어야 한다. 이렇듯 컴파일 도중에 인라인을 처리하기 때문에 대체적으로 헤더 파일에 들어 있다. 템플릿의 경우, 해당 템플릿을 사용하는 부분에서 인스턴스로 만들러면 컴파일러가 그것이 어떤 형태인지 알고 있어야 한다. 따라서 대체적으로 헤더 파일에 들어있다. 인라인 여부는 컴파일러가 판단한다. 인라인은 컴파일러 선에서 무시할 수 있는 요청이다. 아무리 인라인 함수로 선언되어 있어도 자신이 보기에 복잡한 함수(루프, 재귀 등)는 절대로 인라인 확장의 대상에 넣지 않는다. 혹은 가상 함수 호출 같은 것은 절대로 인라인해 주지 않는다. 인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우도 대개 인라인화 되지 않는다. 1 2 3 4 5 6 7 8 inline void f() {} // 인라인 요청 void (*pf)() = f; // 함수 포인터 f(); // 인라인화 될 것이다. // 있지도 않은 함수에 대한 포인터를 가져올 수 없으므로.. pf(); // 인라인되지 않을 것이다. 생성자와 소멸자는 인라인하기 좋은 함수가 아니다. 아무 코드도 들어 있지 않은 빈 생성자라 할지라도, 컴파일러 구현자에 따라 여러가지 코드가 포함될 수 있다. 그러면 코드가 엄청나게 비대해질 것이다. 그외 단점 코드가 비대해진다. 이에 따라 페이징 횟수가 늘어나고 명령어 캐시 적중률이 떨어져서 성능에 영향을 미칠 수 있다. 라이브러리의 바이너리 업그레이드 시 죄다 소스를 컴파일 해야한다. 반면 보통의 함수라면 사용자가 링크만 다시 해주면 되겠다. 디버깅이 어렵다. 있지도 않은 함수에 중단점을 걸 수 없기 때문이다. 우선, 아무것도 인라인하지 말아라. 아니면 꼭 인라인해야 하는 함수(Item 46)나 정말 단순한 함수(Person::age)만 인라인 함수로 선언하자. Item 31: 파일 사이의 컴파일 의존성을 최대로 줄이자 C++의 클래스 정의는 클래스 인터페이스만 지정하는 것이 아니라 구현 세부사항까지 상당히 많이 지정하고 있다. 그래서 다른 헤더 파일을 포함시키면 컴파일 의존성(compilation dependency) 이 생긴다. 헤더 파일들 중에 하나라도 바뀌거나 혹은 그들과 엮여 있는 헤더 파일들이 바뀌면 다시 컴파일 해야하는 번거로움이 생긴다. 이런 꼬리에 꼬리를 무는 컴파일 의존성이 있으면 프로젝트가 고통스러워진다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Person의 구현 세부사항에 속하는 std::string, Date, Address가 // 어떻게 정의됐는지 알아야 컴파일이 가능하므로 // 아래 헤더 파일들을 포함시켜야만 한다. #include \u0026lt;string\u0026gt; #include \u0026#34;date.h\u0026#34; #include \u0026#34;address.h\u0026#34; class Person { private: std::string theName; // std::string 구현 세부사항을 알아야 한다. Date theBirthDate; // Date 구현 세부사항을 알아야 한다. Address theAddress; // Address 구현 세부사항을 알아야 한다. public: Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; }; 해결 방법은? 인터페이스(선언부) 와 구현(정의부) 을 별로의 헤더파일로 나눈 후, 인터페이스(선언부)에만 의존하도록 만들면 되겠다. 즉, 정의부에 대한 의존성(dependencies on definitions)을 선언부에 대한 의존성(dependencies on declarations)으로 바꾸어 놓는 것이다. 방법 (1) 핸들 클래스 주 클래스에는 구현 클래스에 대한 포인터만 두는 것을 pimpl 관용구(pointer to implementation) 라고 한다. 그리고 포인터만 가지는 주 클래스를 핸들 클래스(handle class) 라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Person.h // 헤더 파일이 줄었다. #include \u0026lt;string\u0026gt; // 표준 라이브러리는 전방선언을 하면 안된다. #include \u0026lt;memory\u0026gt; // 이렇게 되면 Person을 사용하는 사용자 입장에서는 // Date, Address가 바뀌었다고 해서 컴파일을 다시할 필요가 없어진다. // 전방 선언 class PersonImpl; class Dat; class Address; class Person { private: // 주 클래스에서는 구현 클래스인 PersonImpl에 대한 포인터만 가지고 있다. // 그래서 세부 구현 사항을 몰라도 된다. std::shared_ptr\u0026lt;PersonImpl\u0026gt; pImpl; public: Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Person.cpp #include \u0026#34;Person.h\u0026#34; #include \u0026#34;PersonImpl.h\u0026#34; Person::Person(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : pImpl(new PersonImpl(name, birthday, addr) // 핸들 클래스 Person에 대응되는 구현 클래스 PersonImpl 쪽으로 함수 호출을 전달한다. // 실제 작업은 PersonImpl이 수행한다. {} std::string Person::name() const { return pImpl-\u0026gt;name(); } 어떤 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의를 가져오지 않아도 된다. 1 2 3 4 5 6 // 클래스 선언 class Date; // 굳이 정의를 몰라도 된다. // 함수 선언 -\u0026gt; 가능 Date today(); void clearAppointments(Date d); 방법 (2) 인터페이스 클래스 추상 기본 클래스를 통해서 인터페이스 클래스를 만들어 놓고, 이 클래스로부터 파생 클래스를 만들 수 있게 하는 방식이다. (Item 34) 순수 가상 함수를 포함한 클래스는 인스턴스를 만들 수 없다. 따라서 객체를 만들기 위해 팩토리 함수(가상 생성자) 를 사용할 수 있다. 즉, 인터페이스 클래스의 객체를 동적으로 할당한 후에 그 포인터를 반환하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 // 추상 기본 클래스 class Person { public: virtual ~Person(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; virtual std::string address() const = 0; // 객체를 생성하는 팩토리 함수 static std::shared_ptr\u0026lt;Person\u0026gt; create(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 인터페이스 클래스 Person으로부터 인터페이스를 물려받은 다음, // 가상 함수들을 구현한다. // (혹은 다중 상속을 사용할 수도 있다 - Item 40) class RealPerson : public Person { private: std::string theName; Date theBirthDate; Address theAddress; public: RealPerson(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) {} virtual ~RealPerson() {} std::string name() const; std::string birthDate() const; std::string address() const; }; // 팩토리 함수는 이렇게 구현할 수 있겠다. std::shared_ptr\u0026lt;Person\u0026gt; Person::create(const std::string\u0026amp; name, const Date\u0026amp; birthday, const Address\u0026amp; addr) { return shared_ptr\u0026lt;Person\u0026gt;(new RealPerson(name, birthday, addr)); } 1 2 3 4 5 6 7 8 9 // 사용자는 이렇게 사용하면 되겠다. std::string name; Date dateOfBirth; Address address; std::shared_ptr\u0026lt;Person\u0026gt; pp(Person::create(name, dateOfBirth, address)); std::cout \u0026lt;\u0026lt; pp-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pp-\u0026gt;birthDate() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pp-\u0026gt;address() \u0026lt;\u0026lt; endl; 단점 핸들 클래스 포인터를 타야 접근할 수 있으므로 간접화 연산이 한 단계 더 증가한다. 객체 하나마다 구현부 포인터의 크기가 더해진다. 핸들 클래스의 생성자 안에서 구현부 포인터의 초기화가 어디선가 일어나야 한다. 이에 따르는 동적 메모리 할당의 연산 오버헤드, bad_alloc 예외의 가능성이 더해진다. 인라인 함수의 도움을 제대로 끌어내기 힘들다. 인터페이스 클래스 호출되는 함수가 전부 가상 함수이므로, 함수 호출 시마다 가상 테이블 점프에 따르는 비용이 소모된다. (Item 7) 또한 파생된 객체는 모두 가상 테이블 포인터를 지니고 있어야 한다. (Item 7) 인라인 함수의 도움을 제대로 끌어내기 힘들다. 하지만 이런 단점에도 불구하고, 구현부가 바뀌었을 때 사용자에게 미칠 파급효과를 최소화하기 위해서는 사용되어야 좋겠다. 핸들 클래스와 인터페이스 클래스로 인해서 실행 속력이나 파일 크기에서 손해를 많이 봐서 클래스 사이에 결합도를 높이는 방법밖에 없다면 그때 사용하지 않으면 된다. ","date":"2023-01-05T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-05/","title":"[Effective C++] Chapter 5. 구현"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자 사용자가 실수할 만한 것들을 생각해보고 인터페이스를 설계하자 1 2 3 4 5 6 7 8 9 10 class Date { public: Date(int month, int day, int year); }; int main() { Date d(1, 30, 2023); // 저런, month와 day를 잘못 넣었다! } Wrapper 타입을 만들어본다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct Day { int val explicit Day(int v) : val(v) }; // ... Month, Year ... class Date { public: Date(const Month\u0026amp; m, const Day\u0026amp; d, const Year\u0026amp; y); }; int main() { Date d(1, 30, 2023); // 컴파일 에러 Date d(Month(1), Day(30), Year(2023); // 컴파일 에러 Date d(Day(30), Month(1), Year(2023); // Okay Date d(Day(1), Month(30), Year(2023); // 악 안돼! } 적절한 값들을 미리 준비해놓고 그것만 쓰도록 한다. enum 은 타입 안정성이 좋지 못하므로 (int로도 쓰일 수 있다) 유효한 Month의 집합을 미리 정의해 두면 좋겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Month { public: // 객체가 아닌, 함수를 사용하였다. // 객체가 초기화 되기 전에 사용되면 위험하기 때문이다 (Item 4) static Month Jan() { return Month(1); } static Month Feb() { return Month(1); } //... private: // Month 값이 새로 생성되지 않도록 // 명시호출 생성자가 private 멤버이다. explicit Month(int m); }; int main() { Data d(Month::Jan(), Day(30), Year(2023)); // Good } 사용자가 사용법을 제대로 외워야 사용할 수 있는 인터페이스는 잘못 사용하기 쉽다. 1 2 3 4 5 6 7 8 Investment * createInvestment(); // 사용자가 자원을 만들어 놓고 삭제하는 걸 까먹으면 어떻하지? // Investment를 스마트 포인터로 관리해야겠다. // 스마트 포인터 사용을 까먹으면 어떻하지? // 차라리 스마트 포인터를 리턴하는 것이 좋겠다. std::shared_ptr\u0026lt;Investment\u0026gt; createInvestment(); // 이렇게 만약에 스마트 포인터의 삭제자가 따로 있어서 미리 지정해 주어야 한다면? 그리고 스마트 포인터를 생성하는 시점에 실제 데이터를 알 수 없어서, 일단 널 포인터를 가리키는 스마트 포인터를 생성하고 싶다면? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 삭제자 void getRidOfInvestment(Investment * inv); std::shared_ptr\u0026lt;Investment\u0026gt; createInvestment() { // 삭제가가 묶인 스마트 포인터를 리턴하므로 // 이제 삭제 걱정도 안 해도 된다. std::shared_ptr\u0026lt;Investment\u0026gt; retVal(0, getRidOfInvestment); // (X) 이것은 널을 가리키는 스마트 포인터가 아니다. // 0은 int이지 Investment* 타입이 아니다. std::shared_ptr\u0026lt;Investment\u0026gt; retVal(static_cast\u0026lt;Investment *\u0026gt;(0), getRidOfInvestment); // 캐스트를 활용해서(Item 27 참고) 널 포인트를 가진 스마트 포인터를 생성한다. // 그리고 나중에 실제 데이터를 가리키도록 한다. // retVal = ... // 만약에 스마트 포인터를 생성하는 시점에 실제 데이터를 알 수 있다면, 생성자에 바로 넘겨주는게 좋겠다. return retVal; } 교차 DLL 문제(cross-DLL problem) 객체 생성할 때 사용한 동적 링크 라이브러리(dynamically linked library: DLL)의 new와, 그 객체를 삭제할 때 사용한 delete의 DLL이 다른 경우에 발생한다. shared_ptr는 가 교차 DLL 문제가 발생하지 않아서 좋다. 1 2 3 4 5 6 7 8 9 class Investment {}; class Stock : public Investment {}; std::shared_ptr\u0026lt;Investment\u0026gt; createInvestment() { return std::shared_ptr\u0026lt;Investment\u0026gt;(new Stock()); // Investment형 shared_ptr이어도, // Stock으로 생성한 걸 잊지 않고 그 DLL의 delete를 호출해준다. } Item 19: 클래스 설계는 타입 설계와 똑같이 취급하자 클래스를 설계한다는 것은, 타입을 설계하는 것과 같다. 따라서 마치 언어 설계자가 그 언어의 기본제공 타입을 설계하면서 쏟는 정성과 보살핌이 필요하다. 생성과 소멸은 어떻게 이루어져야 하는가? 초기화와 대입이 어떻게 달라야 하는가? 값에 의해 객체가 전달되는 경우에 어떤 의미를 줄 것인가? 새로운 타입이 가질 수 있는 값을 어떻게 제한할 것인가? 기존의 클래스 상속 계통망(inheritance graph) 에 맞출 것인가? 어떤 종류의 타입 변환을 허용할 것인가? (암시적, 명시적) 어떤 연산자와 함수를 두어야 할까? 표준 함수들 중 어떤 것을 허용하지 말 것인가? 멤버에 대한 접근권한을 어느쪽에 줄 것인가? \u0026lsquo;선언되지 않은 인터페이스\u0026lsquo;로 무엇을 둘 것인가? 새로 만드는 타입이 얼마나 일반적인가? (템플릿) 정말로 꼭 필요한 타입인가? Item 20: \u0026lsquo;값에 의한 전달\u0026rsquo;보다는 \u0026lsquo;상수객체 참조자에 의한 전달\u0026rsquo; 방식을 택하는 편이 대개 낫다 값에 의한 전달(pass-by-value)은 복사 생성자에 의해 사본을 만든다. 그래서 고비용 연산이 되기도 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Person {}; class Student : public Person {}; bool validateStudent(Student s); int main() { Student plato; validateStudent(plato); // Student의 복사 생성자가 호출된다. // Person 객체가 먼저 만들어진다. // 만약에 멤버로 string 객체가 있다면? // 그에 따른 생성자가 또 불릴 것이다. // 삭제할 때는 생성한 만큼 더 불린다. // 값에 의한 전달은 어마어마한 비용이 들게 되었다. } 따라서 참조자로 전달하면 좋겠다. 1 2 bool validateStudent(const Student \u0026amp; s); // const를 사용하므로써 변경을 방지한다. 참조자는 복사손실 문제(slicing problem) 를 막을 수도 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Window { public: virtual void display() const; }; class WindowWithScrollBars : public Window { public: virtual void display() const; }; void displayWindow(Window w) // WindowWithScrollBars 객체가 Window 객체로 복사되면서 // WindowWithScrollBars의 부분이 싹둑 잘려나간다. { w.display(); // 이것은 Window::display()만 부를 것이다. // 해결하려면 참조로 전달하면 된다. } int main() { WindowWithScrollBars wwsb; displayWindow(wwsb); } Item 21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자 그렇다고 모든 코드를 참조에 의한 전달로 하는 것은 옳지 않다. 함수에서 객체를 반환해야 할 때를 살펴보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 class Rational { private: int n, d; // 두 유리수를 곱한다. friend const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); // 값으로 반환하게 되어 있다. 그럼 객체의 생성과 소멸에 대한 비용이 들겠다. // 이것을 참조로 반환하면 비용이 덜 들지 않을까? public: Rational(int numerator = 0, int denominator = 1); }; 객체에 대한 참조자를 반환할 수 있으려면, 그 전에 객체를 생성해야 하는 건 마찬가지이다. 객체는 스택이나 혹은 힙에 만들 수 있다. 그럼 스택에 만들어보자. 1 2 3 4 5 6 7 8 const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { // 이것은 지역객체이다. Rational result(lhs.n * rhs.n, lhs.d * rhs.d); return result; } // 블록이 끝나면 사라져버린다. // 따라서 반환된 참조는 필요없는 메모리 뭉치가 된다. 그럼 힙에 만들어보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { Rational * result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d); return *result; // 근데 이 객체는 누가 delete 해주지? } int main() { Rational w, x, y, z; w = x * y * z; // operator* 호출이 두 번 일어나므로 new에 맞춰서 delete도 두 번 해줘야 한다. // 하지만 반환되는 참조자에 대한 포인터를 알 수 있는 방법이 없다. } 정적 객체로 만들어 놓고 그것의 참조자를 반환하면 어떨까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const Rational\u0026amp; operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { static Rational result; // 정적 객체를 반환한다. // result = ...; return result; } bool operator==(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); int main() { Rational a, b, c, d; if ((a * b) == (c * d)) // 이것은 늘 true가 되버린다. // ... } 따라서 함수에서 객체를 반환할 때는, 새로운 객체를 만들어서 값으로 반환해야하겠다. 1 2 3 4 const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.n * rhs.n, lhs.d * rhs.d); } Item 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자 데이터 멤버는 private로 하자. 그 이유는\u0026hellip; 일관성 있는 인터페이스를 제공할 수 있다. 필요에 따라 접근 제어가 세밀하게 가능하다. 캡슐화(encapsulation) 를 함으로써, 클래스의 불변속성을 강화할 수 있고, 내부 구현을 융통성 있게 바꿀 수 있다. protected는 어떨까? 어떤 데이터 멤버를 protected로 했다가 제거한다고 치자.. 그러면 그 멤버를 사용하던 파생 클래스에 해당하는 코드를 전부 고쳐야 할 것이다. protected는 public보다 더 많이 보호 받고 있다는 것이 절대 아니다. Item 23: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class WebBrowser { public: void clearCache(); void clearHistory(); void removeCookies(); // 위의 세가지를 한 번에 하는 함수를 만들고 싶다. // 이것을 멤버 함수로 제공할 것인가? void clearEverything(); }; // 아니면 비멤버 비프렌드 함수로 제공할 것인가? void clearBrowser(WebBrowser\u0026amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } 멤버 함수 말고 비멤버 비프렌드 함수를 쓰도록 하자. 비멤버 비프렌드 함수는 private 멤버에 접근할 수 없다. 따라서 캡슐화 정도가 더 높다고 볼 수 있다. 컴파일 의존성을 줄일 수 있다. 멤버 함수는 반드시 하나의 클래스가 통으로 정의되어야 한다. 하지만 비멤버 비프렌드 함수들은 같은 네임스페이스 안에 둔 다음, 쓰임새에 따라 각기 다른 헤더파일에 몰어서 선언할 수 있다. 그러면 사용자는 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려할 수 있게 된다. 또한 확장도 쉬워진다. 새로운 함수를 만들 때는 헤더 파일을 하나 더 만들어서 정의를 추가하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u0026#34;webbrowser.h\u0026#34; namespace WebBrowserStuff // 같은 네임스페이스 안에 둔다. { // 핵심 관련 기능들... class WebBrowser {}; void clearBrowser(WebBrowser\u0026amp; wb); } // \u0026#34;webbrowserbookmarks.h\u0026#34; namespace WebBrowserStuff { // 즐겨 찾기 관련 편의 함수들... } // \u0026#34;webbroswercookies.h\u0026#34; namespace WebBrowserStuff { // 쿠기 관련 평의 함수들... } Item 24: 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자 유리수 클래스를 만들었는데, int 형 등과 함께 혼합형(mixed-mode) 수치 연산이 가능하게 하고 싶다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Rational { public: // 생성자를 explicit(명시 호출)로 선언하지 않았다. // 따라서 암시적 타입 변환이 가능해진다. Rational(int numerator = 0, int denominator = 1); int numerator(); int denominator(); // operator*를 멤버 함수로 두었다. const Rational operator*(const Rational\u0026amp; rhs) const; }; int main() { Rational oneEighth(1, 8); Rational oneHalf(1, 2); Rational result = oneHalf * oneEighth; // 암시적 타입 변환으로 2가 Rational 객체가 되었기에 가능하다 result = oneHalf * 2; // oneHalf.operator*(2) // 컴파일 에러! result = 2 * oneHalf; // 2.operator*(oneHalf) } 컴파일러는 암시적 타입 변환(implicit type conversion)을 했다. Rational 생성자에 int를 넘겨서 int를 Rational 클래스로 둔갑시켰다. 이것은 생성자에 explicit 선언이 되지 않았기에 가능하다. 컴파일 에러 부분을 해결하기 위해 operator*를 비멤버 함수로 만들면 어떨까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Rational {}; // 비멤버 함수로 두었다. const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } int main() { Rational oneHalf(1, 2); Rational result; result = oneHalf * 2; // OK result = 2 * oneHalf; // OK! } 멤버 함수의 반대는 비멤버 함수이다. friend 함수가 아니다. 위 operator*는 Rational의 public 인터페이스만 써서 구현할 수 있으므로, friend일 필요가 없다. Item 25: 예외를 던지지 않는 swap에 대한 지원도 생각해 보자 표준에서 제공하는 swap()은 복사만 제대로 지원하는(복사 생성자, 복사 대입 연산자를 통해) 타입이기만 하면 어떤 타입의 객체이든 맞바꾸기 동작을 수행해 준다. 1 2 3 4 5 6 7 8 9 10 namespace std { template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp(a); a = b; b = temp; } } 클래스를 위한 std::swap()의 특수화 포인터가 주성분인 객체는 굳이 데이터까지 복사하지 않고 포인터만 맞바꾸는게 비용이 적게 들 것이다. 이 때, std::swap을 특수화(specialize) 하면 되겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class WidgetImpl { private: int a, b, c; std::vector\u0026lt;double\u0026gt; v; // 복사 비용이 높겠다. }; class Widget { private: // 포인터가 주성분이다. WidgetImpl * pImpl; public: // 복사 생성자와 복사 대입 연산자를 제공한다. Widget(const Widget\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { *pImpl = *(rhs.pImpl); // ... } void swap(Widget\u0026amp; other) { using std::swap; // 객제가 아니라 포인터를 맞바꾼다. swap(pImpl, other.pImpl); } }; namespace std { // 명시적 특수화 : // 다른 swap 템플릿을 사용하지 말고, 주어진 형에 맞게 특별히 명시적으로 정의된 이 함수 정의를 사용해라. template\u0026lt;\u0026gt; void swap\u0026lt;Widget\u0026gt;(Widget\u0026amp; a, Widget\u0026amp; b) { // Widget에서 swap()을 제공한다. // 굳이 freind로 해서 pImpl에 직접 접근할 필요가 없다. a.swap(b); } } 클래스 템플릿을 위한 비멤버 swap() 만약 Widget과 WidgetImpl이 클래스 템플릿으로 되어있다면? std::swap을 부분적인 특수화(partial specialization) 해야 하겠다. 하지만 C++은 클래스 템플릿에 대해서는 부분적 특수화를 허용하지만, 함수 템플릿(std::swap)에 대해서는 허용하지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 클래스 템플릿 -\u0026gt; std::swap의 부분 특수화가 필요해졌다. template\u0026lt;typename T\u0026gt; class WidgetImpl {}; template\u0026lt;typename T\u0026gt; class Widget {}; namespace std { // (X) C++은 함수 템플릿의 부분 특수화는 허용하지 않는다. template\u0026lt;typename T\u0026gt; void swap\u0026lt;Widget\u0026lt;T\u0026gt;\u0026gt;(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) { a.swap(b); } } 함수 템플릿을 부분 특수화하고 싶을 때는 보통 오버로드 버전을 하나 추가한다. 하지만 std 네임스페이스의 경우 조금 특별해서, 이 안에서 완전 특수화는 OK지만, 새로운 템플릿을 추가하는 건 NOT OK이다. 따라서 비멤버 swap을 선언하되, std::swap의 특수화 버전이나 오버로딩 버전으로 선언하지 않으면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 namespace WidgetStuff // std가 아니므로 오버로딩 버전이 아니다. { template\u0026lt;typename T\u0026gt; class Widget {}; // 비멤버 swap template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) // swap 뒤에 \u0026lt;...\u0026gt;가 없으므로 특수화 버전이 아니다. { a.swap(b); } } 사용자 입장에서 swap 사용하는 법 위에서 본 것처럼 swap을 만들 었다면, 사용자는 어떻게 사용해야 좋을까? 1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void doSomething(T\u0026amp; obj1, T\u0026amp; obj2) { swap(obj1, obj2); // 어떤 버전의 swap을 호출해야 할까? // (1) T 타입 전용 버전 // (2) std::swap을 특수화한 버전 // (3) std::swap } 순서대로 살펴보기를 원한다면 함수 내 using 선언을 포함시켜서 해당 함수가 std::swap을 볼 수 있게 한다. 1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; void doSomething(T\u0026amp; obj1, T\u0026amp; obj2) { using std::swap; // std::swap을 이 함수 안으로 끌어온다. swap(obj1, obj2); } 그러면 C++의 이름 탐색 규칙(인자 기반 탐색: argument-dependent lookup 혹은 쾨니그 탐색: Koenig lookup) 에 따라서, (1) 전역 유효범위 or 타입 T와 동일함 네임스페이스 안에, T 전용의 swap이 있는지 찾는다. (2) 없다면 std::swap의 특수화 버전을 찾는다. (3) 없다면 std::swap을 사용한다. ","date":"2023-01-04T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-04/","title":"[Effective C++] Chapter 4. 설계 및 선언"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 13: 자원 관리에는 객체가 그만! 프로그래밍 분야에서, 자원(resource) 이란? 사용을 일단 마치고 난 후엔 시스템에 돌려주어야 하는 모든 것이다. 동적 할당 메모리, 파일 서술자(file descriptor), 뮤텍스 잠금(mutex lock), GUI에서 쓰이는 폰트나 브러시, 데이터베이스 연결, 네트워크 소켓 등 어떻게 하면 팩토리 함수로 얻은 자원이 항상 해제되도록 할 수 있을까? 1 2 3 4 5 6 7 8 9 10 11 12 13 class Investment {}; Investment * createInvestment(); // 팩토리 함수 void f() { Investment * pInv = createInvestment(); // Investment를 생성한다. // ... // 도중하차되어 여기까지 코드가 도달하지 않으면 어떡할 것인가? delete pInv; } 자원 관리 객체 객체를 써서 자원을 관리하는 게 최고다. 자원을 객체에 넣음으로써 C++이 자동으로 호출해 주는 소멸자 덕분에 자원이 저절로 해제되도록 할 수 있다. 자원 관리 객체의 사용 방법 (1) 자원을 획득한 후에 자원 관리 객체에게 넘긴다. (Resource Acquisition Is Initialization; RAII) (2) 자원 관리 객체는 자신의 소멸자를 사용해서 자원이 확실히 해제되도록 한다. 스마트 포인터 이런 객체 중에 하나가 바로 스마트 포인터(smart pointer) 이다. auto_ptr은 블록을 벗어나면 소멸자가 자동으로 delete를 불러주도록 설계되어 있다. 1 2 3 4 5 void f() { std::auto_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); // ... } // auto_ptr이 소멸자를 통해 delete pInv를 한다. auto_ptr은 객체를 복사하면 원본 객체는 null로 바뀐다. 1 2 3 4 5 6 7 std::auto_ptr\u0026lt;Investment\u0026gt; pInv1(createInvestment()); // pInv2가 Investment를 가리키고, pInv1은 null이다. std::auto_ptr\u0026lt;Investment\u0026gt; pInv2(pInv1); // pInv1이 Investment를 가리키고, pInv2는 null이다. pInv1 = pInv2; 참조 카운팅 방식 스마트 포인터(reference-counting smart pointer: RCDP) 인 shared_ptr를 사용하면 여러 포인터가 객체를 가리키도록 할 수 있다. shared_ptr은 가리키는 외부 객체의 수가 0이 되면 해당 자원을 자동으로 삭제한다. 1 2 3 4 5 std::shared_ptr\u0026lt;Investment\u0026gt; pInv1(createInvestment()); // pInv1와 pInv2 모두 Investment를 가리킨다. std::shared_ptr\u0026lt;Investment\u0026gt; pInv2(pInv1); pInv1 = pInv2; 스마트 포인터에서 주의할 점 delete를 부르는 것이지 delete []를 부르는 것이 아니다. 따라서 아래와 같은 코드는 문제가 발생한다. 배열을 위한 부스트(boost::scoped_array, boost::shared_array)는 Item 55를 참고하자. 1 2 3 std::auto_ptr\u0026lt;std::string\u0026gt; aps(new std::string[10]); std::shared_ptr\u0026lt;int\u0026gt; apt(new int[1024]); Item 14: 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자 모든 자원은 힙에 생기지 않으므로, delete를 알아서 해주는 스마트 포인터로는 다른 자원 관리가 불가능하다. 그렇다면 직접 RAII 법칙에 맞는 자원 관리 클래스를 만들어볼 수 있겠다. 예를 들어, 뮤텍스 잠금을 관리하는 클래스를 만든다고 하자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Lock { private: Mutex * mutexPtr; public: explicit Lock(Mutex * pm) : mutexPtr(pm) { lock(mutexPtr); // 잠금 } ~Lock() { unlock(mutexPtr); // 해제 } }; // 사용자는 이렇게 사용하면 되겠다. int main() { Mutex m; { Lock lock(\u0026amp;m); // 잠금을 건다. // ... 임계 영역에서 연산을 수행한다. } // 블록의 끝이므로 ~Lock()소멸자가 자동으로 불려서 잠금이 해제된다. } 자원 관리 객체의 복사 처리 하지만 Lock 객체가 복사된다면 어떻게 해야 할까? (1) 복사를 금지한다. 1 class Lock : private Uncopyable {}; // Item 6 참고 (2) 참조 카운팅을 수행한다. shared_ptr은 삭제자(delete) 지정을 허용한다. 그래서 소멸자에서 delete를 대신해 불릴 함수를 지정할 수 있다. auto_ptr은 이런 기능이 없다. 1 2 3 4 5 6 7 8 9 10 11 12 class Lock { private: std::shared_ptr\u0026lt;Mutex\u0026gt; mutexPtr; public: explicit Lock(Mutex * pm) : mutexPtr(pm, unlock) // 삭제자를 unlock으로 지정한다. { lock(mutexPtr.get()); // 잠금 } }; (3) 자원을 진짜로 복사한다. 깊은 복사(deep copy)를 수행해야 하겠다. (4) 자원의 소유권을 옮긴다. auto_ptr의 복사 동작과 같다. Item 15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자 외부에서 자원 관리 클래스의 자원에 접근할 수 있도록 해야할 경우가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Item 13에서 가져온 예제 // 투자금이 유입된 이후로 경과한 날수를 계산한다. int daysHeld(const Investment * pi); void f() { std::shared_ptr\u0026lt;Investment\u0026gt; pInv(createInvestment()); int days = daysHeld(pInv); // 이렇게 사용하고 싶지만 // pInv는 std::shared_ptr\u0026lt;Investment\u0026gt; 이고 // 매개변수 형식은 Investment * 이다. // shared_ptr의 자원에 접근할 수 있어야 하겠다. } RAII 클래스를 자원으로 변환하는 방법 명시적 혹은 암시적 변환 함수를 제공한다. 어떤 함수를 사용할지는 사용 용도 및 환경에 따라 달라지겠다. 늘 그렇지는 않지만 명시적 변환 함수를 제공하는 쪽이 나을 때가 많다. RAII 클래스는 애초에 데이터 은닉이 목적이 아니므로, 자원을 공개한다고 해서 캡슐화에 위배되는 것은 아니다. (1) 명시적 변환(explicit conversion) shared_ptr과 auto_ptr은 get()이라는 멤버 함수를 제공한다. 이것으로 실제 자원을 가리키는 포인터의 사본을 얻을 수 있다. 1 int days = daysHeld(pInv.get()); // 동작한다. (2) 암시적 변환(implicit conversion) shared_ptr과 auto_ptr은 포인터 역참조 연산자(operator-\u0026gt;, operator*)를 오버로딩하고 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Investment { public: bool isTaxFree() const; }; Investment * createInvestment(); int main() { std::shared_ptr\u0026lt;Investment\u0026gt; pi1(createInvestment()); bool isTaxFree1 = pi1-\u0026gt;isTaxFree(); // operator-\u0026gt; std::auto_ptr\u0026lt;Investment\u0026gt; pi2(createInvestment()); bool isTaxFree2 = (*pi2).isTaxFree(); // operator* } 두 변환의 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class FontHandle {}; class Font { private: FontHandle f; public: FontHandle get const // 명시적 변환 함수 { return f; } operator FontHandle() const // 암시적 변환 함수 { return f; } }; FontHandle getFont(); void changeFontSize(FontHandle f, int newSize); int main() { Font f(getFont()); // (1) 명시적 변환 changeFontSize(f.get(), 13); // (2) 암시적 변환 changeFontSize(f, 13); // Font 형식인 f가 FontHandler로 변환된다. // 원치 않는 경우가 발생할 수도 있다. FontHandle fh = f; // Font를 복사하고 싶었는데 // f가 FontHandle로 바뀐 후 복사된다. } Item 16: new 및 delete를 사용할 때는 형태를 반드시 맞추자 new 연산자를 사용하면 벌어지는 일들 (1) 메모리가 할당된다. (operator new 함수가 사용된다) (2) 생성자가 호출된다. delete 연산자를 사용하면 벌어지는 일들 (1) 소멸자가 호출된다. (2) 메모리가 해제된다. (operator delete 함수가 사용된다) new를 사용해서 힙에 만들어진 단일 객체의 메모리 배치구조는, 객체 배열에 대한 메모리 배치구조와 다르다. 힙의 맨 앞에 배열원소의 개수가 박혀 들어간다. 이걸로 delete는 소멸자를 몇 번 부를지를 알 수 있다. 따라서 new [] 표현식을 썼으면, delete [] 표현식을 맞춰 써야한다. 1 2 3 4 5 std::string * sPtr1 = new std::string; std::string * sPtr2 = new std::string[100]; delete sPtr1; delete [] sPtr2; 왠만하면 배열 타입을 typedef 타입으로 만들지 말자. delete []를 써야 하는지 헷갈린다. vector 타입으로 만드는게 낫겠다. 1 2 3 4 5 6 7 8 9 typedef std::string AddressLines[4]; int main() { std::string * pal = new AddressLines; // new string[4]; delete pal; // 이거 아니다. delete [] pal; // 이거 써야되는데 헷갈리지 않는가? } Item 17: new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Widget {}; int getPriority(); void processWidget(std::shared_ptr\u0026lt;Widget\u0026gt; pw, int priority); int main() { // 컴파일 에러 : // shared_ptr의 생성자는 explicit이라서 암시적 변환이 안 된다. processWidget(new Widget, getPriority()); // 이것은 위험하다 : // new Widget으로 만들어진 자원이 shared_ptr에 저장되기 전, 그 사이에 // getPriority()가 불리고 예외가 발생했다면 // 만들어진 자원은 유실되고 만다. processWidget(std::shared_ptr\u0026lt;Widget\u0026gt;(new Widget), getPriority()); } 따라서,new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 문장으로 만들어야 하겠다. 1 2 3 std::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget); processWidget(pw, getPriority()); ","date":"2023-01-03T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-03/","title":"[Effective C++] Chapter 3. 자원 관리"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자 컴파일러는 필요하다고 생각하면 다음의 함수들을 자동으로 만들어 낸다. 모두 public 멤버이며, inline 함수이다. (1) 기본 생성자 (2) 복사 생성자 (3) 소멸자 (비가상으로 만들어진다.) (4) 복사 대입 연산자 1 2 3 4 5 6 7 8 9 10 11 12 // 이것은 class Empty {}; // 다음과 같다. class Empty { public: Empty() { ... } // 기본 생성자 Empty(const Empty\u0026amp; e) { ... } // 복사 생성자 ~Empty() { ... } // 소멸자 Empty\u0026amp; operator=(const Empty\u0026amp; e) { ... } // 복사 대입 연산자 }; 만약, 멤버 변수가 참조자 이거나, const 이면, 반드시 복사 대입 연산자를 정의해 주어야한다. 그렇지 않으면 컴파일 에러가 발생한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template\u0026lt;class T\u0026gt; class NamedObject { private: std::string\u0026amp; namedValue; // 참조자 const T objectValue; // const public: NamedObject(std::string\u0026amp; name, const T\u0026amp; value); }; int main() { std::string newDog(\u0026#34;Persephone\u0026#34;); std::string oldDog(\u0026#34;Satch\u0026#34;); NamedObject\u0026lt;int\u0026gt; p(newDog, 2); NamedObject\u0026lt;int\u0026gt; s(oldDog, 36); p = s; // 컴파일 에러! 복사 대입 연산자 정의 필요! } Item 6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자 객체의 사본이 만들어지면 안되는 경우에 어떻게 해야할까? 복사 생성자와 복사 대입 연산자를 선언하지 않으면 컴파일러가 마음대로 만들어버린다. 따라서 private으로 선언하면 되겠다! 하지만 클래스의 멤버 함수, friend 함수에서 호출할 수 있다는 허점이 있다. 그럼 선언만 하고, 정의를 빼먹자! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Uncopyable { protected: Uncopyable() {} ~Uncopyable() {} // 선언만 하고 정의는 하지 않는다. private: Uncopyable(const Uncopyable\u0026amp;); Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); }; // 복사 생성자도, 복사 대입 생성자도 선언되지 않는다. class HomeForSale : private Uncopyable { }; Item 7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자 비가상 소멸자의 경우, 기본 클래스의 소멸자만 호출하고 파생 클래스의 소멸자는 호출하지 않는다. 따라서, 다형성을 가진 기본 클래스의 소멸자는 반드시 가상 소멸자여야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class TimeKeeper { public: TimeKeeper(); virtual ~TimeKeeper(); // 가상 소멸자 }; class AtomicClock: public TimeKeeper { ... }; class WaterClock: public TimeKeeper { ... }; class WristClock: public TimeKeeper { ... }; int main() { TimeKeeper* t = getTimeKeeper(); // 생성된 파생 클래스의 기본 클래스 포인터를 반환하는 팩토리 함수이다. delete t; // 파생 클래스의 소멸자 -\u0026gt; TimeKeeper의 소멸자 } 기본 클래스가 아닌 클래스거나, 다형성을 갖도록 설계되지 않은 클래스에 가상 소멸자를 선언하는 것도 옳지 않다. 가상 함수를 구현하려면 C++에서는 클래스에 vptr (가상함수 테이블 포인터; virtual table pointer) 가 클래스에 별도로 들어간다. 이것은 vtbl (가상함수 테이블; virtual table) 을 가리키고 있다. 따라서 예를들어, 64비트 시스템에서는 포인터의 크기가 64비트이므로, 클래스의 크기에 64비트가 추가되는 셈이다. 또한 vtpr을 따로 만들기는 어렵기 때문에 C 등의 다른 언어로 호환성이 없어진다. 가상 소멸자가 없는 타입은 상속해서 사용하면 안 된다. string STL의 모든 컨테이너 기본 클래스를 추상 클래스로 만들고 싶은 데 마땅한 순수 가상 함수가 없는 경우에는? 순수 가상 소멸자를 두면 편리하다. 주의할 점은, 순수 가상 소멸자의 정의를 꼭 두어야 한다는 점이다. 1 2 3 4 5 6 7 class AbstractWithVirtual { public: virtual ~AbstractWithVirtual() = 0; // 순수 가상 소멸자 }; AbstractWithVirtual::~AbstractWithVirtual() {}; // 꼭 정의를 두어야 한다. Item 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자 소멸자에서 예외가 발생하면? 프로그램이 불완전 종료되거나, 미정의 동작의 위험을 내포하고 있다. 따라서 예외가 발생될만한 코드는 소멸자가 아닌 다른 함수에 존재해야 할 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class DBConnection() { public: static DBConnection Create(); // 연결을 닫을 때 실패하면 예외를 던진다. // 소멸자가 아닌 다른 함수에서 예외가 발생하도록 했다. void Close(); }; class DBHandler { private: DBConnection db; public: // 데이터베이스 연결이 항상 닫히도록 소멸자에서 Close해준다. ~DBHandler() { db.Close(); // 하지만 여기서 예외가 발생했을 때 어떤 조취를 취해야 할까? // (1) 프로그램을 바로 종료하거나 (2) 아무일 없었던 듯 무시한다 // 단순히 위와같은 조치를 바로 취하는 건 좋지 않겠다. // 그렇다면 사용자가 직접 예외에 대처할 수 있게 하는 것이 좋겠다. } }; // 유저가 이렇게 사용할 수 있겠다. int main() { DBHandler h(DBConnection::Create()); } 해결법: 사용자가 직접 예외를 처리할 기회를 갖도록 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class DBHandler { private: DBConnection db; bool closed; public: // 사용자가 처리할 수 있도록 책임을 전가한다. void Close() { db.Close(); closed = true; } ~DBHandler() { // 만약 사용자가 Close를 안 했을 때만 여기서 Close해본다. if (closed == false) { try { db.Close(); } catch (...) { // Close 호출이 실패했다는 로그를 작성한다. // (1) 프로그램을 바로 종료하거나 (2) 아무일 없었던 듯 무시한다 } } } }; Item 9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자 생성자나 소멸자에서 가상 함수를 호출하면 절대 안 된다. 기본 클래스의 생성자가 호출될 때, 파생 클래스의 멤버들은 아직 초기화가 안 되었으므로 객체는 기본 클래스 타입으로 작동된다. 기본 클래스의 소멸자가 호출될 때, 파생 클래스의 소멸자가 호출된 후이므로 객체는 기본 클래스 타입으로 작동된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Transaction { public: Transaction() { // 생성자에서 가상 함수를 호출해버렸다. LogTransaction(); // 하지만 파생 클래스의 멤버들은 아직 초기화가 안 되었으므로 // 이 시점에서 b의 타입은 Transaction이다. // (2) 따라서 Transaction의 LogTransaction()이 호출된다. } virtual void LogTransaction() const = 0; }; class Buy : public Transaction { public: virual void LogTransaction() const; }; class Sell : public Transaction { public: virual void LogTransaction() const; }; int main() { // 이 코드가 실행되면 어떻게 될까? Buy b; // 가장 먼저 Buy의 기본 클래스인 (1) Transaction의 생성자가 호출될 것이다. } 해결법: 함수를 비가상으로 바꾸고, 생성자의 매개변수로 필요한 정보를 넘기도록 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Transaction { public: explicit Transaction(const str::string logInfo) { LogTransaction(logInfo); } // 비가상 함수이다. // 매개변수로 필요한 정보를 받는다. void LogTransaction(const str::string logInfo) const; }; class Buy : public Transaction { public: // 매개변수로 필요한 정보를 넘긴다. Buy() : Transaction(createLogString()) { // ... } private: static std::string createLogString(); }; Item 10: 대입 연산자는 *this의 참조자를 반환하게 하자 C++의 대입 연산은 사슬처럼 엮일 수 있다. 따라서 대입연산자는 좌변 인자에 대한 참조자를 반환해야 한다는 일종의 관례(convention)가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Widget { public: // 단순 대입 연산자 Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { // ... return *this; // 참조자를 반환한다. } // 다른 대입 연산자도 마찬가지이다. Widget\u0026amp; operator+=(const Widget\u0026amp; rhs) { // ... return *this; } }; int main() { Widget a, b, c; // 대입이 사슬처럼 이루어진다. a = b = c; // 이것은 다음과 같이 우측 연관 연산(right-associative)으로 진행된다. // (a = (b = c)) } Item 11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자 자기대입(self assignment)이란? 자기 자신에 대해 대입 연산자를 적용하는 것을 말한다. 하나의 객체를 여러 곳에서 참조할 수 있기(중복참조; aliasing) 때문에 자기대입이 발생한다. 1 2 3 4 class Widget {}; Widget w; w = w; // 자기 자신에 대해 대입 연산자를 적용하는 것을 말한다. 자기대입은 위험성을 내포한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Bitmap {}; class Widget { private: Bitmap * pb; public: Widget\u0026amp; operator=(const Widget\u0026amp; rhs); }; Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) // 만약 rhs가 자기 자신이라면? { delete pb; // 자기자신의 데이터를 지웠기 때문에 pb = new Bitmap(*rhs.pb); // rhs.pb는 이미 삭제된 상태가 된다. 아뿔싸! return *this; } 해결법 (1) 첫머리에 일치성 검사(identify test) 를 한다. 이것은 공짜가 아니다. 일치성 검사 코드가 들어가면 그만큼 코드가 커지는데다가, 처리 흐름에 분기를 만들게 되므로 실행 시간 속력이 줄어들 수 있다. 1 2 3 4 5 6 7 8 9 Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { // 객체가 같은지 확인해서 같으면 아무것도 하지 않는다. if (this == \u0026amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this; } (2) 객체를 복사하고 삭제한다. 1 2 3 4 5 6 7 8 Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Bitmap * pOrig = pb; // 원래의 pb를 복사한다. pb = new Bitmap(*rhs.pb); // 새로운 값을 대입한다. delete pOrig; // 원래의 pb를 삭제한다. return *this; } (3) 복사 후 맞바꾸기(copy and swap) 를 한다. Item 29에서 자세히 설명한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Widget { private: Bitmap * pb; void swap(Widget\u0026amp; rhs); // *this와 rhs의 데이터를 맞바꾼다. Item 28에서 자세히 설명한다. public: Widget\u0026amp; operator=(const Widget\u0026amp; rhs); }; Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) { Widget temp(rhs); // rhs의 사본을 만든다. swap(temp); // *this와 사본을 맞바꾼다. return *this; } 이것은 사본을 매개변수로 넘겨서 좀 더 간소화할 수 있다. 1 2 3 4 5 6 Widget\u0026amp; Widget::operator=(Widget rhs) // 사본이 전달된다. { swap(rhs); // *this와 사본을 맞바꾼다. return *this; } Item 12: 객체의 모든 부분을 빠짐없이 복사하자 복사 함수(copying function)에서는 모든 부분을 복사해야 한다. 복사 생성자와 복사 대입 연산자가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void logCall(const std::string\u0026amp; funcName); class Customer { private: std::string name; public: // 복사 생성자 Customer(const Customer\u0026amp; rhs) : name(rhs.name) { logCall(\u0026#34;Customer copy constructor\u0026#34;); } // 복사 대입 연산자 Customer\u0026amp; operator=(const Customer\u0026amp; rhs) { logCall(\u0026#34;Customer copy assignment operator\u0026#34;); name = rhs.name; return *this; } }; class PriorityCustomer : public Customer { private: int priority; public: PriorityCustomer(const PriorityCustomer\u0026amp; rhs); PriorityCustomer\u0026amp; operator=(const PriorityCustomer\u0026amp; rhs); }; // 파생 클래스의 복사 생성자에서 // 기본 클래스의 멤버 데이터를 복사하지 않고 있다! PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : priority(rhs.priority) { logCall(\u0026#34;PriorityCustomer copy constructor\u0026#34;); } // 파생 클래스의 복사 대입 연산자에서도 마찬가지다! PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { logCall(\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); priority = rhs.priority; return *this; } 복사 함수를 작성할 때는 다음의 두 가지를 꼭 확인하자 (1) 해당 클래스의 데이터 멤버를 모두 복사했는가? (2) 이 클래스가 상속한 기본 클래스의 복사 함수를 호출했는가? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026amp; rhs) : Customer(rhs), // 기본 클래스의 복사 생성자를 호출한다. priority(rhs.priority) { logCall(\u0026#34;PriorityCustomer copy constructor\u0026#34;); } PriorityCustomer\u0026amp; PriorityCustomer::operator=(const PriorityCustomer\u0026amp; rhs) { logCall(\u0026#34;PriorityCustomer copy assignment operator\u0026#34;); priority = rhs.priority; Customer::operator=(rhs); // 기본 클래스 부분을 대입한다. return *this; } 코드 간소화를 위해 두 복사함수에서 겹치는 내용을 init() 멤버 함수를 따로 두고 호출할 수도 있겠다. ","date":"2023-01-02T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-02/","title":"[Effective C++] Chapter 2. 생성자, 소멸자 및 대입 연산자"},{"content":" 이펙티브 C++ 책을 읽고 공부한 노트입니다.\nItem 1: C++를 언어들의 연합체로 바라보는 안목은 필수 C++은 다중 패러다임 프로그래밍 언어(multiparadigm programming language)라고 불린다. C++을 단일 언어로 바라보는 눈을 넓혀서, 상관 관계가 있는 여러 언어들의 연합체(federation)로 보아야 한다. 특징 설명 C C++은 절차적(procedual) 프로그래밍 언어인 C를 기본으로 하고 있다. 객체 지향(object-oriented) 개념의 C++ 클래스를 쓰는 C라고 볼 수 있다. 클래스, 캡슐화, 상속, 다형성, 가상 함수 등이 포함된다. 템플릿 C++ 일반화(generic) 프로그래밍 부분이다. STL C++의 어떤 부분을 사용하느냐에 따라 효과적인 프로그래밍 규칙이 달라진다.\nItem 2: #define을 쓰려거든 const, enum, inline을 떠올리자 상수를 쓰는 경우 #define ASPECT_RATIO 1.653 #define은 컴파일 이전에 처리된다. 따라서 이미 숫자 상수로 대치된 코드에서 컴파일 에러라도 발생하면, 꽤나 헷갈릴 것이다. 해결법: 상수를 쓴다. const double AspectRatio = 1.653; 하지만 두 가지는 주의하자. (1) 상수 포인터의 경우 const를 두 번 사용하게 되겠다. const char * const authorName = \u0026quot;Scott Meyers\u0026quot;; (2) 클래스 멤버로 상수를 정의하는 경우. 사본 개수를 하나만 하고 싶다면 static 멤버로 만든다. 구식 컴파일러는 클래스 내에서 정적 클래스 상수를 초기화하는 것을 금지하기 때문에 구현 파일에서 정의를 해주어야 하겠다. 배열 크기 등, 컴파일 하는 도중에 클래스 상수의 값이 필요한데 구식 컴파일러라서 초기화가 안 된다면, enum을 사용해보자. 이것을 나열자 둔갑술(enum hack)이라고 한다. 만약 우리가 선언한 정수 상수의 주소를 얻는다던지, 참조를 하는 게 싫으면, 나열자 둔갑술이 좋은 선택이 될 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // 헤더 파일 class CostEstimate { private: // static const 멤버의 선언과 초기화 static const double FudgeFactor = 1.35; }; // 구현 파일 // 구식 컴파일러의 경우 정의에서 초기값을 준다. const double CostEstimate::FudgeFactor = 1.35; 1 2 3 4 5 6 class GamePlayer { private: enum { NumTurns = 5; } // 나열자 둔갑술 int scores[NumTurns]; // (O) }; 매크로 함수의 경우 #define CALL_WITH_MAX(a, b) f((a) \u0026gt; (b) ? (a) : (b)) 매크로 함수는 단점이 한 두개가 아니다. 괄호를 인자마다 쓰는 것은 물론이며, 다음과 같은 괴현상이 발생한다. 1 2 3 4 int a = 5, b = 0; CALL_WITH_MAX(++a, b); // a가 두 번 증가힌다. CALL_WITH_MAX(++a, b + 10); // a가 한 번 증가힌다. 해결법: 인라인 함수에 대한 템플릿을 만든다. 기존 매크로의 효율은 그대로 유지하면서 함수의 동작 방식 및 타입 안정성까지 완벽히 취한다. 1 2 3 4 5 template\u0026lt;typename T\u0026gt; inline void callWithMax(const T\u0026amp; a, const T\u0026amp; b) { f(a \u0026gt; b ? a : b); } 단순한 상수를 쓸 때는, #define보다 const객체 혹은 enum을 우선 생각하자.\n함수처럼 쓰이는 매크로를 만들려면, #define보다 inline 함수를 우선 생각하자.\nItem 3: 낌새만 보이면 const를 들이대 보자! const를 붙여서 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. 포인터의 경우 1 2 3 4 5 6 7 8 9 10 char greeting[] = \u0026#34;Hello\u0026#34;; char *p = greeting; // 비상수 const char *p = greeting; // 상수 데이터 char const *p = greeting; // (이렇게 쓸 수도 있다) char * const p = greeting; // 상수 포인터 const char * const p = greeting; // 상수 포인터, 상수 데이터 STL 반복자의 경우 1 2 3 4 5 6 7 8 9 std::vector\u0026lt;int\u0026gt; vec; // T * const와 같다. (상수 포인터) const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin(); *iter = 10; // const T * 와 같다. (상수 데이터) std::vector\u0026lt;int\u0026gt;::const_iterator iter = vec.begin(); ++iter; 함수 선언의 경우 1 2 3 4 5 6 7 8 class Rational {}; const Rational operator*(const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); // 맨앞에 const는 Rational a, b, c; (a * b) = c; // (X) // 이런 말도 안되는 상황을 막는다. 멤버 함수의 경우 멤버 함수에 const를 쓰는 이유 (1) 인터페이스 이 함수에서 객체를 변경할 수 없다는 것을 알린다. (2) 상수 객체를 사용할 수 있게 한다. 보통 상수 객체가 생기는 경우는 포인터 혹은 참조자로 객체가 전달되는 경우이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class TextBlock { private: char* text; public: // 비상수 객체에 대한 operator[] char\u0026amp; operator[](std::size_t position) { return text[position]; } // 상수 객체에 대한 operator[] // 맨뒤의 const로 상수 객체에서 이 함수를 호출할 수 있게된다. // 또한 이 함수 내에서 객체를 변경할 수 없다. // 맨앞의 const로 대입이 불가능하게 된다. // ctb[0] = \u0026#39;x\u0026#39;; 가 안 된다. const char\u0026amp; operator[](std::size_t position) const { return text[position]; } }; void print(const TextBlock\u0026amp; ctb) { cout \u0026lt;\u0026lt; ctb[0]; // 상수 객체이므로, const 버전으로 호출한다. } 멤버 함수가 const라는 의미 (1) 비트 수준 상수성(bitwise constness), 물리적 상수성(physical constness) 그 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안 된다는 것이다. (2) 논리적 상수성(logical constness) 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하게만 하면 상수 멤버 자격이 있다는 것이다. 하지만, 비트 수준 상수성을 갖추지 않으면 컴파일 되지 않는다. 따라서 const함수에서도 데이터 멤버를 수정하기 위해 mutable이라는 키워드가 등장했다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TextBlock { private: char* text; mutable std::size_t textLength; mutable bool lengthIsValid; public: std::size_t length() const // const 멤버 함수지만 { if (!lengthIsValid) { // mutable로 선언된 데이터 멤버들은 수정할 수 있다. textLength = std::strlen(text); lengthIsValid = true; } return textLength; } } 상수 멤버와 비상수 멤버에서 코드 중복 피하기 비상수 버전이 상수 버전을 호출하도록 만든다. const를 붙이는 것은 안전한 타입 변환이므로 static_cast\u0026lt;\u0026gt;로 하고, const를 떼어내는 것은 const_cast\u0026lt;\u0026gt;밖에 없으므로 선택의 여지는 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TextBlock { private: char* text; public: char\u0026amp; operator[](std::size_t position) { // const 버전을 호출한다. return const_cast\u0026lt;char\u0026amp;\u0026gt;( static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this)[position] ); } const char\u0026amp; operator[](std::size_t position) const { // 여러가지 잡다한 작업들 // ... return text[position]; } }; const를 사용하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다.\n컴파일러는 비트수준 상수성을 지켜야 하지만, 우리는 논리적인 상수성을 사용해서 프로그래밍해야한다.\n상수 멤버와 비상수 멤버가 기능적으로 서로 똑같게 구현되어 있을 경우에는, 비상수 버전이 상수 버전을 호출하도록 한다.\nItem 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자 C++은 어떤 규칙들에 의해서 초기화가 되고 안 되고가 달라진다. 이런 규칙을 모두 새겨두기 보다는, 모든 객체를 사용하기 전에 항상 초기화하자. 대입과 초기화를 헷갈리지는 말자. 생성자에서 멤버 초기화 생성자 안에서 대입을 하는 것은 기본 생성자를 호출해서 초기화를 한 후, 또 대입을 하는 것이다. 대신 멤버 초기화 리스트를 사용하면 초기화 리스트에 들어가는 인자를 사용해서 복사 생성자를 한번 호출한다. C++의 규칙에 의하면 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화되어야 한다고 되어 있다. 멤버 초기화 리스트를 사용하면 객체 생성 전에 초기화되는 것이다. 따라서 대부분의 경우 멤버 초기화 리스트가 효율적이다. 물론, 기본 제공 타입의 객체는 그 차이가 없지만, 초기화를 빠트리는 실수를 방지하기 위해서라도 멤버 초기화 리스트를 사용하자. 상수이거나 참조자인 데이터 멤버의 경우에는 반드시 초기화해야 하겠다. 순서는 데이터 멤버가 클래스 내부에서 선언된 순서이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class PhoneNumber {}; class ABEntry { private: // 여기에 선언된 순서로 초기화된다. std::string theName; std::string theAddress; std::list\u0026lt;PhoneNumber\u0026gt; thePhones; int numTimesConsulted; public: ABEntry(const std::string\u0026amp; name, const std::string address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones); }; // 이것은 대입이다. 초기화가 아니다. ABEntry::ABEntry(const std::string\u0026amp; name, const std::string address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; } // 멤버 초기화 리스트를 사용해서 초기화한다. ABEntry::ABEntry(const std::string\u0026amp; name, const std::string address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) { } 비지역 정적 객체의 초기화 정적 객체(static object)의 종류 분류 포함되는 사항 지역 정적 객체\n(local) 함수 안에서 static으로 선언된 객체 비지역 정적 객체\n(non-local) 전역 객체 네임스페이스 유효범위에서 정의된 객체 클래스 안에서 static으로 선언된 객체 파일 유효범위에서 static으로 선언된 객체 번역 단위(translation unit)란? 컴파일을 통해 하나의 목적 파일을 만드는 바탕이 되는 소스 코드이다. 기본적으로 소스 파일 하나가 되는데, #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다. 별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는 정해져 있지 않다. 이 사실 때문에 여러 번역 단위에 비지역 정적 객체들이 있을 때 초기화 문제가 생긴다. 1 2 3 4 5 6 7 8 class FileSystem { public: std::size_t numDisks() const; }; // 사용자가 쓰게 될 객체이다. extern FileSystem tfs; 1 2 3 4 5 6 7 8 9 10 11 class Directory { public: Directory(); }; Directory::Directory() { // tfs 객체를 사용한다. std::size_t disks = tfs.numDisks(); } 1 2 Directory tempDir(); // 만약 tfs가 먼저 초기화되지 않는다면 큰 문제가 발생할 것이다! 해결 방법 비지역 정적 객체를 지역 정적 객체로 바꾼다. 즉, 정적 객체 자체를 직접 사용하지 않고, 그 객체에 대한 참조를 반환하는 함수를 사용하는 것이다. 싱글톤 패턴(Singleton pattern)의 전형적인 구현 양식이다. 1 2 3 4 5 6 7 8 9 10 11 12 class FileSystem { public: std::size_t numDisks() const; }; FileSystem\u0026amp; tfs() // 클래스 안에 정적 멤버로 들어가도 된다. { // 지역 정적 객체를 정의한다. static FileSystem fs; return fs; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Directory { public: Directory(); }; Directory::Directory() { // tfs가 tfs()로 바뀌었다. std::size_t disks = tfs().numDisks(); } Directory\u0026amp; tempDir() { static Directory td; return td; } 다중 스레드 환경에서는\u0026hellip; 비상수 정적 객체는 지역 객체이든 비지역 객체이든 온갖 골치덩이가 된다. 따라서 경쟁 생태(race condition)를 없애주는 방법들을 사용해야 한다. (여기서는 다루지 않는다) 기본 제공 타입의 객체는 직접 손으로 초기화한다.\n생성자에서는 멤버 초기화 리스트를 즐겨 사용하자. 그리고 멤버가 선언된 순서와 똑같이 나열하자.\n여러 번역 단위에 비지역 정적 객체들이 있을 때는, 지역 정적 객체로 바꾸어 주자.\n","date":"2023-01-01T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/effective-cpp-01/","title":"[Effective C++] Chapter 1. C++에 왔으면 C++의 법을 따릅시다"},{"content":" 1부터 n까지의 합 $n$이 짝수일 경우 $a+b$가 $n/2$번 반복된다. $(n+1) * (n/2)$ 쌍 $a$ $b$ $a+b$ $1$ $1$ $n$ $n+1$ $2$ $2$ $n-1$ $n+1$ \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; $n/2$ $n/2$ $n/2+1$ $n+1$ $n$이 홀수일 경우 $a+b$가 $(n+1)/2$번 반복된다. $n * (n+1)/2$ 쌍 $a$ $b$ $a+b$ $1$ $0$ $n$ $n$ $2$ $1$ $n-1$ $n$ \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; $(n+1)/2$ $n/2-1$ $n/2$ $n$ 두 경우 모두 정리하면\u0026hellip; $1$부터 $n$까지의 합은? $$ \\frac{n(n+1)}{2} $$ 2의 승수의 합 $ 2^0 + 2^1 + 2^2 + \u0026hellip; + 2^n $의 결과는? 2진수로 생각해보자! 승수 2진수 $2^0$ 00001 $2^1$ 00010 $2^2$ 00100 $2^3$ 01000 $2^4$ 10000 $2^0 + 2^1 + 2^2 + 2^3 + 2^4 = 2^5 - 1$ 11111 즉, 2의 승수의 합은 다음 공식과 같다. $$2^{n+1} - 1$$ 로그의 밑 $\\log_2 k$를 $\\log_{10} k$로 어떻게 바꿀 수 있을까? $y = \\log_x k$이고, $a = \\log_b k$일 때, $a = \\log_b k$ 이것을 풀면, $b^a = k$ 이다. 이것을 두번째 식에 대입하면, $$\\log_x k = \\log_x b^a$$ $$\\log_x k = a \\log_x b$$ $$a = \\frac{\\log_x k}{\\log_x b} = \\log_b k$$ 따라서 다음과 같이 구할 수 있겠다. $$ \\log_{10} k = \\frac{\\log_2 k}{\\log_2 10} $$ 순열과 조합 $n$개 중에 $r$개를 선택하는 경우의 수는? 순열 조합 설명 배치하기. 순서가 다르면 다른 경우이다. 뽑기. 순서가 달라도 같은 경우이다. 중복불가 공식 $$_n P_r = \\frac{n!}{(n-k)!} $$ $$ _n C_r = \\frac{n!}{(n-k)!r!} $$ 중복가능 공식 $$_n \\pi _r = n^r $$ $$_n H _r = _{n+r-1} C _r $$ 순열 중복 불가 순열 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void Permutation(vector\u0026lt;int\u0026gt;\u0026amp; vec, int n, int r, vector\u0026lt;bool\u0026gt;\u0026amp; selected, vector\u0026lt;int\u0026gt;\u0026amp; print, int cnt) { if (cnt == r) { for (int i = 0; i \u0026lt; r; i++) cout \u0026lt;\u0026lt; print[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } // 늘 처음부터 살펴본다. // 순서가 중요하므로 이전 경우에 뽑았던 숫자를 또 선택할 수 있기 때문이다. for (int i = 0; i \u0026lt; n; i++) { // 이미 선택한 건 쳐다보지도 않는다. if (selected[i]) continue; selected[i] = true; // 같은 수들을 선택해도 순서가 중요하므로, 선택해온 순서대로 배열을 출력하기 위해서 cnt위치에 저장해서 출력한다. print[cnt] = vec[i]; Permutation(vec, n, r, selected, print, cnt + 1); // 끝까지 다 선택한 후 돌아왔다면, 다시 선택할 수 있는 상태로 바꾼다. selected[i] = false; } } 중복 가능 순열 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void PermutationWithRepetition(vector\u0026lt;int\u0026gt;\u0026amp; vec, int n, int r, vector\u0026lt;int\u0026gt;\u0026amp; print, int cnt) { // selected가 사라졌다. if (cnt == r) { for (int i = 0; i \u0026lt; r; i++) cout \u0026lt;\u0026lt; print[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } for (int i = 0; i \u0026lt; n; i++) { print[cnt] = vec[i]; PermutationWithRepetition(vec, n, r, print, cnt + 1); } } 조합 중복 불가 조합 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void Combination(vector\u0026lt;int\u0026gt;\u0026amp; vec, int n, int r, vector\u0026lt;bool\u0026gt;\u0026amp; selected, int start, int cnt) { // 선택한 개수가 맞으면 출력한다. if (cnt == r) { for (int i = 0; i \u0026lt; n; i++) if (selected[i]) cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } // 현재 선택한 수의 위치 이후(start)로 살펴보면서 추가로 선택한다. // 그래서 늘 현재 선택한 수 뒤로만 검사한다. // 순서가 중요하지 않으므로 이전 경우에 선택했던 숫자를 또 선택하면 안되기 때문이다. for (int i = start; i \u0026lt; n; i++) { // 이미 선택한 건 쳐다보지도 않는다. if (selected[i]) continue; selected[i] = true; Combination(vec, n, r, selected, i + 1, cnt + 1); // 끝까지 다 선택한 후 돌아왔다면, 다시 선택할 수 있는 상태로 바꾼다. selected[i] = false; } } 중복 가능 조합 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void CombinationWithRepetition(vector\u0026lt;int\u0026gt;\u0026amp; vec, int n, int r, vector\u0026lt;int\u0026gt;\u0026amp; print, int start, int cnt) { // selected가 사라졌다. if (cnt == r) { for (int i = 0; i \u0026lt; r; i++) cout \u0026lt;\u0026lt; print[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } for (int i = start; i \u0026lt; n; i++) { print[cnt] = vec[i]; CombinationWithRepetition(vec, n, r, print, i, cnt + 1); } } Rabin-Karp 부분 문자열 탐색 알고리즘 해싱(Hashing) 을 사용해서 문자열에서 특정 패턴과 일치하는지를 찾아주는 알고리즘이다. 예를 들어, 각 문자의 아스키 코드와 자릿수를 곱해주는 해시 함수를 사용한다면\u0026hellip; ear → $101 \\times 2^2 + 97 \\times 2^1 + 114 \\times 2^0$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void Rabin_Karp(string str, string pattern) { int strLen = str.length(); int patLen = pattern.length(); int i, j; int strHash = 0, patHash = 0, base = 1; // 첫 해시 값 for (i = patLen - 1; i \u0026gt;= 0; i--) { strHash = strHash + str[i] * base; patHash = patHash + pattern[i] * base; if (i \u0026gt; 0) base *= 2; } for (i = 0; i \u0026lt; strLen - patLen + 1; i++) { if (patHash == strHash) { for (j = 0; j \u0026lt; patLen; j++) if(str[i + j] != pattern[j]) break; if (j == patLen) cout \u0026lt;\u0026lt; \u0026#34;Pattern is found at index: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } // 다음 해시 값 // 첫번째 문자 제거, 한 칸씩 앞으로 이동(2곱하기), 마지막 새 문자 추가 strHash = (strHash - str[i] * base) * 2 + str[i + patLen]; } } References 코딩 인터뷰 완전 분석 ","date":"2022-11-19T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/algorithm-06/","title":"[Algorithm] 유용한 수학"},{"content":" 정렬 알고리즘 정렬 알고리즘과 시간 복잡도 정렬 알고리즘 Best Avg Worst 삽입 정렬 $n$ $n^2$ $n^2$ 선택 정렬 $n^2$ $n^2$ $n^2$ 버블 정렬 $n^2$ $n^2$ $n^2$ 셸 정렬 $n$ $n^{1.5}$ $n^2$ 퀵 정렬 $n \\log n$ $n \\log n$ $n^2$ 힙 정렬 $n \\log n$ $n \\log n$ $n \\log n$ 병합 정렬 $n \\log n$ $n \\log n$ $n \\log n$ 계수 정렬 $n + k$ $n + k$ $n + k$ 기수 정렬 $dn$ $dn$ $dn$ (오름 차순 정렬 기준) 삽입 정렬(Insertion sort) 정렬되지 않은 첫 번째 데이터를 선정한다. 정렬된 부분의 제일 오른쪽 데이터부터 선정한 데이터와 비교해서, 선정한 데이터가 더 작으면 교환을 반복해 나간다. 시간 복잡도 이미 정렬된 상태라면? 한번씩 밖에 비교를 안하므로 최선의 경우 $n$가 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 void InsertionSort(int* arr, int size) { for (int i = 1; i \u0026lt; size; i++) // i = 1 ~ size-1 { for (int j = i; j \u0026gt;= 1; j--) // j = i ~ 1 { if (arr[j] \u0026lt; arr[j - 1]) Swap(arr[j], arr[j - 1]); else break; } } } 선택 정렬(Selection sort) 정렬되지 않은 데이터 중에서 가장 작은 것을 선정한다. 정렬되지 않은 맨 앞의 데이터와 교환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void SelectionSort(int* arr, int size) { int min = 0; for (int i = 0; i \u0026lt; size; i++) { min = i; for (int j = i + 1; j \u0026lt; size; j++) if (arr[min] \u0026gt; arr[j]) min = j; Swap(arr[i], arr[min]); } } 버블 정렬(Bubble sort) 인접한 두 원소를 비교해서 큰 원소를 뒤로 민다. 1 2 3 4 5 6 7 void BubbleSort(int* arr, int size) { for (int i = 1; i \u0026lt; size; i++) for (int j = 0; j \u0026lt; size - i; j++) if (arr[j] \u0026gt; arr[j + 1]) Swap(arr[j], arr[j + 1]); } 셸 정렬(Shell sort) 간격을 전체 크기의 절반부터 점차 2로 나눠서 줄여가면서, 간격만큼 떨어진 데이터들의 부분리스트를 만들고, 삽입정렬을 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void ShellSort(int* arr, int size) { for (int gap = size / 2; gap \u0026gt; 0; gap /= 2) // gap을 줄여가며 반복 { if (gap % 2 == 0) gap += 1; for (int i = 0; i \u0026lt; size / gap; i++) // 해당 gap으로 만들어진 부분 배열의 개수만큼 반복 InsertionSort(arr, i, size - 1, gap); } } void InsertionSort(int* arr, int first, int last, int gap) { for (int i = first + gap; i \u0026lt;= last; i += gap) { for (int j = i - gap; j \u0026gt;= first; j -= gap) { if (arr[j] \u0026gt; arr[i]) Swap(arr[j], arr[i]); else break; } } } 퀵 정렬(Quick sort) I 큰 값 찾기 \u0026gt;\u0026gt; \u0026hellip; \u0026lt;\u0026lt; J 작은 값 찾기 (내림차순이면 방향만 바뀜) 각각 값을 찾으면 I와 J를 교환하고, I와 J가 교차하면 J와 피벗을 교환하고, 그룹을 나눈 후 반복한다. 시간 복잡도 요소의 개수 만큼 반복 $n$ $*$ 절반씩 나누어지므로 $\\log n$ 하지만, 피벗이 한쪽 끝에 있고 + 모두 정렬(혹은 역으로) 되어 있다면? 계속 $1 : n-1$로 끝에서 나누어지므로, 총$n$번 나누는 게 된다. 따라서 최악의 경우 $n^2$가 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void QuickSort(int* arr, int firstIdx, int lastIdx) { if (firstIdx \u0026gt;= lastIdx) return; int piviotIdx = firstIdx; int largeIdx = firstIdx + 1; int smallIdx = lastIdx; // 대략적으로 요소의 개수 n 만큼 반복하면서 검사하게 된다. while(largeIdx \u0026lt;= smallIdx) // 겹치면, 나간다 { // \u0026gt;\u0026gt;\u0026gt; 큰 값을 찾아서. // 마지막 이하이고, 이번 값이 피벗보다 작을 때 반복한다. // (점점 커지면 배열을 넘어선다... 하지만 그 말은 겹쳤다는 뜻이며, 겹쳤을 때 이 값을 쓰진 않으므로 상관없다) while (largetIdx \u0026lt;= lastIdx \u0026amp;\u0026amp; arr[largetIdx] \u0026lt; arr[piviotIdx]) largetIdx++; // \u0026lt;\u0026lt;\u0026lt; 작은 값을 찾아서. // 첫번째 이상이고, 이번 값이 피벗보다 클 때 반복한다. // (점점 작아지면 피벗 이후 두 번째 칸까지 간다) while (smallIdx \u0026gt;= firstIdx \u0026amp;\u0026amp; arr[smallIdx] \u0026gt; arr[piviotIdx]) smallIdx--; // 겹치면, 피벗과 작은 것을 교체한다, 그리고 나가게 된다 // 겹친게 아니면, 둘이 교체한다 if (largetIdx \u0026gt; smallIdx) Swap(arr[smallIdx], arr[piviotIdx]); else Swap(arr[smallIdx], arr[largetIdx]); } // 겹칠 때까지 교환한 결과, 겹친 부분을 중심으로 왼쪽은 작음 오른쪽은 큼으로 나뉘게 된다 // 겹쳤을 때는 작은 것과 교환했으므로 작은 것이 중심이 된다. // 계속해서 절반씩 나누게 된다면 그 높이는 log n일 것이다. QuickSort(arr, firstIdx, smallIdx - 1); QuickSort(arr, smallIdx + 1, lastIdx); } 힙 정렬(Heap sort) 완전 이진 트리의 일종인 힙을 사용한다. 힙을 만들고, 루트를 꺼낸 후 다시 힙을 만들고($\\log n$)를 반복($n$)한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;iostream\u0026gt; using namespace std; // 루트를 제일 큰 값으로 만드는 최대 힙이다. // log n 만큼의 (트리 높이 만큼의) 반복 횟수가 예상된다. void makeHeap(int* arr, int start, int last) { // 루트에서 시작해서 int rootToMove = arr[start]; int parentIdx; int maxChildIdx = start; for (parentIdx = start; parentIdx \u0026lt; (last + 1) / 2; parentIdx = maxChildIdx) { int leftChildIdx = (parentIdx * 2) + 1; int rightChildIdx = (parentIdx * 2) + 2; // 왼쪽과 오른쪽 자식 중에 루트보다 큰 값이 있으면 maxChildIdx = (rightChildIdx \u0026lt;= last \u0026amp;\u0026amp; arr[rightChildIdx] \u0026gt; arr[leftChildIdx]) ? rightChildIdx : leftChildIdx; if (rootToMove \u0026gt;= arr[maxChildIdx]) break; // 그 큰 자식이 부모의 자리를 꿰찬다. arr[parentIdx] = arr[maxChildIdx]; // 그 자식을 루트로 보고 다시 반복한다. } // 더이상 큰 자식이 없을 때, 그 자리가 적절한 자리이다. arr[parentIdx] = rootToMove; } void heapSort(int* arr, int size) { // 제일 작은 이진 트리의 루트에서 부터 한 부모씩 올라가면서 전체를 힙으로 만든다. int lastRootIndex = size / 2 - 1; for (int i = lastRootIndex; i \u0026gt;= 0; i--) makeHeap(arr, i, size - 1); // 한 요소씩 트리에서 빼면서 반복하므로 n 만큼 반복된다. for (int i = 1; i \u0026lt; size; i++) { // 이진 트리의 루트(0)를 맨 뒷 요소(size - 1)와 바꿔서 맨 뒤는 제일 큰 루트가 차곡차곡 저장되게 한다. swap(arr[0], arr[size - i]); // 이제 맨 끝은 큰게 저장되었으므로 루트부터 그 전(size - 2)노드까지 다시 힙을 만든다. makeHeap(arr, 0, size - i - 1); } } void swap(int\u0026amp; a, int\u0026amp; b) { int temp = a; a = b; b = temp; } void printArray(int* arr, int size) { for (int i = 0; i \u0026lt; size; i++) cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { int arr[10] = { 5, 7, 9, 0, 3, 1, 6, 2, 4, 8 }; int arrSize = 10; heapSort(arr, arrSize); printArray(arr, arrSize); } 병합 정렬(Merge sort) 원소가 1일 때까지 나눠서 1이면 리턴하고, 그 이상일 경우 정렬하고 합치기를 반복한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void MergeSort(int* arr, int first, int last) { int size = last - first + 1; if (size \u0026lt;= 1) return; int mid = (first + last) / 2; // 계속 절반씩 나누므로 총 log n번 반복된다. MergeSort(arr, first, mid); MergeSort(arr, mid + 1, last); // 합친다. Merge(arr, first, last); } void Merge(int* arr, int first, int last) { int mid = (first + last) / 2; int size = (last - first) + 1; int* sorted = new int[size](); int idx = 0; int left = first; int right = mid + 1; // 총 요소의 개수만큼 n번 반복하면서 비교가 된다. // 인덱스를 더해가면서 비교한다. while (left \u0026lt;= mid \u0026amp;\u0026amp; right \u0026lt;= last) { if (arr[left] \u0026lt;= arr[right]) sorted[idx++] = arr[left++]; else if (arr[left] \u0026gt; arr[right]) sorted[idx++] = arr[right++]; } // 남은 배열은 모두 순서대로 추가해준다. if (left \u0026gt; mid) { for (int i = right; i \u0026lt;= last; i++) sorted[idx++] = arr[i]; } else if (right \u0026gt; last) { for (int i = left; i \u0026lt;= mid; i++) sorted[idx++] = arr[i]; } // 원래 배열로 옮긴다. for (int i = 0; i \u0026lt; size; i++) arr[first + i] = sorted[i]; } 계수 정렬(Counting sort) 최대값만한 크기의 리스트를 만들고 나온 횟수를 센다. 그리고 횟수만큼 출력한다. 조건 음수가 아닌 정수만 가능하다. 만약 정수의 최댓값 $k$가 너무 크면 비효율적이다. 추가적인 메모리가 필요하다. 시간 복잡도 원소 개수만큼 넣고 $n$ $+$ 정수의 최댓값만큼 꺼내기 $k$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void CountingSort(int* arr, int size) { int max = 0; for (int i = 0; i \u0026lt; size; i++) // 최대값 찾기 if (arr[i] \u0026gt; max) max = arr[i]; int* counter = new int[max](); // 최대값만한 크기의 리스트 만들기 for (int i =0; i \u0026lt; size; i++) // 중복 횟수 입력하기 n counter[arr[i]]++; for (int i = 0; i \u0026lt; max; i++) for (int j = 0; j \u0026lt; counter[i]; j++) // 순서대로 출력하기 k cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 기수 정렬(Radix sort) 낮은 1의 자리수부터 버킷에 넣었다가 꺼내기를 반복한다. 조건 음수가 아닌 정수만 가능하다. 추가적인 메모리가 필요하다. 시간 복잡도 최대 자릿수만큼 반복 계산하기 $d$ $*$ 원소 개수만큼 $n$ 탐색하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void RadixSort(int* arr, int size) { queue\u0026lt;int\u0026gt; q[10]; // 최대값 찾기 int maxVal = 0; for (int i = 0; i \u0026lt; size; i++) if (maxVal \u0026lt; arr[i]) maxVal = arr[i]; // 최대자릿수인 Radix를 찾는다. int Radix = 1; while (true) { if (Radix \u0026gt;= maxVal) break; Radix = Radix * 10; } // 1의 자리부터 10씩 곱하면서 최대자릿수 Radix까지 반복한다. d for (int i = 1; i \u0026lt; Radix; i *= 10) { // 모든 배열을 다 탐색하면서 n for (int j = 0; j \u0026lt; size; j++) { int k; if (arr[j] \u0026lt; i) k = 0; // 현재 배열의 값 \u0026lt; 현재 자릿수 i 이면, k = 0 else k = (arr[j] / i) % 10; // 그게 아니라면, k = 현재 자릿수에 해당하는 값 // 큐에 현재 배열의 값을 k에 따라 순차적으로 저장한다. q[k].push(arr[j]); } // 0부터 9까지 큐에 저장된 값들을 순차적으로 빼내서, 배열에 다시 저장한다. int idx = 0; for (int j = 0; j \u0026lt; 10; j++) { while (q[j].empty() == 0) { arr[idx] = q[j].front(); q[j].pop(); idx++; } } } } 탐색 알고리즘 이진 탐색(Binary search) 정렬된 배열에서, 원소 $x$를 찾고자 할 때 사용한다. $x$가 중간의 원소보다 작다면 왼쪽을, 크다면 오른쪽을 재탐색한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void BinarySearch_Loop(int* arr, int size, int target) { int start = 0; int end = size - 1; int mid = (end + start) / 2; while(start \u0026lt; end) { if (arr[mid] == target) { cout \u0026lt;\u0026lt; \u0026#34;Found it in index : \u0026#34; \u0026lt;\u0026lt; mid \u0026lt;\u0026lt; endl; return; } else if (arr[mid] \u0026lt; target) start = mid + 1; else end = mid - 1; mid = (end + start) / 2; } cout \u0026lt;\u0026lt; \u0026#34;Couldn\u0026#39;t find it.\u0026#34; \u0026lt;\u0026lt; endl; } void BinarySearch_Recursion(int* arr, int start, int end, int target) { if (start \u0026gt; end) return; int mid = (start + end) / 2; if (arr[mid] == target) { cout \u0026lt;\u0026lt; \u0026#34;Found it in index : \u0026#34; \u0026lt;\u0026lt; mid \u0026lt;\u0026lt; endl; return; } else if (arr[mid] \u0026lt; target) { BinarySearch_Recursion(arr, mid + 1, end, target); start = mid + 1; } else { BinarySearch_Recursion(arr, start, mid - 1, target); } } 이진 탐색 트리(Binary search tree) 다음과 같은 특징을 갖는 트리 자료구조이다. 자식이 최대 2개 + 왼쪽 모든 자식 \u0026lt; 부모 \u0026lt; 오른쪽 모든 자식 코드 보기\nReferences 코딩 인터뷰 완전 분석 ","date":"2022-11-12T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/algorithm-05/","title":"[Algorithm] 정렬, 탐색 알고리즘"},{"content":" 비트 조작 비트 조작 트릭 0s는 모든 비트가 0인 값이며, 1s는 모든 비트가 1인 값이다. 1 2 3 x ^ 0s = x x \u0026amp; 0s = 0 x | 0s = x x ^ 1s = ~x x \u0026amp; 1s = x x | 1s = 1s x ^ x = 0 x \u0026amp; x = x x | x = x 음수를 나타내기 위한 2의 보수법 보수(Complementary Number) 란?\n보충을 해주는 수이다. $R$진수에서, $N$에 대한 $R-1$의 보수란?\n$N$이 $R$진수에서 해당 자릿수의 최대값이 되기 위해 얼마를 보충해 주어야 하는 가이다. $R$진수에서, $N$에 대한 $R$의 보수란?\n$N$이 $R$진수에서 자릿수를 한 자리 높이기 위헤 얼마를 보충해 주어야 하는 가이다. 이것은 $R-1$의 보수 $+ 1$ 과 같다. 예시\n$10$진수에서, $33$에 대한 $9$의 보수는? $99 - 33 = 66$이다. $10$진수에서, $33$에 대한 $10$의 보수는? $100 - 33 = 67$이다. $2$진수에서, 1010에 대한 $1$의 보수는? 1111 - 1010 = 0101이다. 이것은 0과 1의 반전이다. $2$진수에서, 1010에 대한 $2$의 보수는? 10000 - 1010 = 0110이다. 이것은 $1$의 보수 $+ 1$이다. 즉, 0과 1을 반전 시키고 $1$을 더하면 된다. 컴퓨터에서 음수 양수를 구별 하기위해 최상위 비트(MSB; Most significant bit) 를 부호비트로 사용한다.\n$1$은 0001이므로 $-1$는 1001가 되겠다. 그 둘을 빼면? $0$이어야 하는데 1010이 나오는 문제가 있다. 그러면 $1$의 보수법을 사용해서 음수를 표현하면 어떨까?\n0과 1를 반전시켜서 음수를 표현하면 되겠다. $1$인 0001과 $-1$인 1110을 더하면? 1111이 나온다. $1$의 보수는 $+0$인 0000과 $-0$인 1111의 두 가지 $0$이 존재한다는 문제점이 있다. 그래서 $2$의 보수법을 사용해서 음수를 표현한다.\n0과 1을 바꾼다음 $1$을 더해서 음수를 표현하면 되겠다. $1$인 0001과 $-1$인 1111을 더하면? 10000이 나온다. 여기서 MSB가 1이지만, 범위를 벗어났기 때문에 결과적으로 $0$인 0000이 된다. 결과적으로, 음수를 나타내려면, 0과 1을 반전시켜서 $1$을 더한 수에다가 MSB에 1을 붙이면 되겠다.\n논리 우측 시프트와 산술 우측 시프트 논리 우측 시프트(Logical right shift)\n비트를 오른쪽으로 옮긴 후, MSB에 0을 넣는다. \u0026gt;\u0026gt;\u0026gt; 연산과 같다. 산술 우측 시프트(Arithmetic right shift)\n비트를 오른쪽으로 옮기지만, MSB 비트는 변하지 않는다. \u0026gt;\u0026gt; 연산과 같다. 이것은 대략 값을 $2$로 나눈 것과 같은 결과이다. 기본 비트 조작 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;iostream\u0026gt; #include \u0026lt;bitset\u0026gt; using namespace std; const int bitSize = 4; void Printer(int num, int mask, int result) { cout \u0026lt;\u0026lt; \u0026#34;\\t원래 숫자 : \\t\u0026#34; \u0026lt;\u0026lt; bitset\u0026lt;bitSize\u0026gt;(num) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\t마스크 : \\t\u0026#34; \u0026lt;\u0026lt; bitset\u0026lt;bitSize\u0026gt;(mask) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\t결과 숫자 : \\t\u0026#34; \u0026lt;\u0026lt; bitset\u0026lt;bitSize\u0026gt;(result) \u0026lt;\u0026lt; endl; } bool IsBitOne(int num, int i) { int mask = 1 \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 번째 자리 수가 1인가? : \u0026#34; \u0026lt;\u0026lt; endl; Printer(num, mask, num \u0026amp; mask); return (num \u0026amp; mask) != 0; } int SetBitOne(int num, int i) { int mask = 1 \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 번째 자리 수를 1로 만들기 : \u0026#34; \u0026lt;\u0026lt; endl; Printer(num, mask, num | mask); return num | mask; } int SetBitZero(int num, int i) { int mask = ~(1 \u0026lt;\u0026lt; i); cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 번째 자리 수를 0으로 만들기 : \u0026#34; \u0026lt;\u0026lt; endl; Printer(num, mask, num \u0026amp; mask); return num \u0026amp; mask; } int SetBitZeroAfterIndex(int num, int i) { int mask = (1 \u0026lt;\u0026lt; i + 1) - 1; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 번째 자리 이후(i 자리 제외)를 모두 0으로 만들기 : \u0026#34; \u0026lt;\u0026lt; endl; Printer(num, mask, num \u0026amp; mask); return num \u0026amp; mask; } int SetBitZeroBeforeIndex(int num, int i) { int mask = ~((1 \u0026lt;\u0026lt; i) - 1); cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 번째 자리 이전(i 자리 제외)을 모두 0으로 만들기 : \u0026#34; \u0026lt;\u0026lt; endl; Printer(num, mask, num \u0026amp; mask); return num \u0026amp; mask; } int UpdateBit(int num, int i, bool setOne) { int value = ((setOne) ? 1 : 0) \u0026lt;\u0026lt; i; int mask = ~(1 \u0026lt;\u0026lt; i); int remove = num \u0026amp; mask; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; 번째 자리 비트를 \u0026#34; \u0026lt;\u0026lt; setOne \u0026lt;\u0026lt; \u0026#34;으로 만들기 : \u0026#34; \u0026lt;\u0026lt; endl; Printer(num, mask, remove); cout \u0026lt;\u0026lt; \u0026#34;\\t숫자 입력 : \\t\u0026#34; \u0026lt;\u0026lt; bitset\u0026lt;bitSize\u0026gt;(remove | value) \u0026lt;\u0026lt; endl; return remove | value; } int main() { int num = 7; // 숫자 : 1 1 1 int i = 1; // 몇 번째 자리 : 2 1 0 IsBitOne(num, i); SetBitOne(num, i); SetBitZero(num, i); SetBitZeroAfterIndex(num, i); SetBitZeroBeforeIndex(num, i); UpdateBit(num, i, 0); UpdateBit(num, i, 1); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 1 번째 자리 수가 1인가? : 원래 숫자 : 0111 마스크 : 0010 결과 숫자 : 0010 1 번째 자리 수를 1로 만들기 : 원래 숫자 : 0111 마스크 : 0010 결과 숫자 : 0111 1 번째 자리 수를 0으로 만들기 : 원래 숫자 : 0111 마스크 : 1101 결과 숫자 : 0101 1 번째 자리 이후(i 자리 제외)를 모두 0으로 만들기 : 원래 숫자 : 0111 마스크 : 0011 결과 숫자 : 0011 1 번째 자리 이전(i 자리 제외)을 모두 0으로 만들기 : 원래 숫자 : 0111 마스크 : 1110 결과 숫자 : 0110 1 번째 자리 비트를 0으로 만들기 : 원래 숫자 : 0111 마스크 : 1101 결과 숫자 : 0101 숫자 입력 : 0101 1 번째 자리 비트를 1으로 만들기 : 원래 숫자 : 0111 마스크 : 1101 결과 숫자 : 0101 숫자 입력 : 0111 수학 및 논리 퍼즐 소수 모든 자연수는 소수의 곱으로 나타낼 수 있다는 법칙이 있다. 따라서 $x/y$로 나눌 수 있으려면, $x$에 대한 소수의 곱 $\\supset$ $y$에 대한 소수의 곱이 되어야 한다. $x = 2^{a_0} \\times 3^{a_1} \\times 5^{a_2} \\times 7^{a_3} \u0026hellip;$ $y = 2^{b_0} \\times 3^{b_1} \\times 5^{b_2} \\times 7^{b_3}\u0026hellip;$ $a_i \\geq b_i$ 그렇다면 $x$와 $y$의 최대공약수(Greatest common divisor) 는? $gcd(x, y) = 2^{min(a_0, b_0)} \\times 3^{min(a_1, b_1)} \\times 5^{min(a_2, b_2)}$ 그렇다면 $x$와 $y$의 최소공배수(Least Common multiple) 는? $lcm(x, y) = 2^{max(a_0, b_0)} \\times 3^{max(a_1, b_1)} \\times 5^{max(a_2, b_2)}$ 어떤 수가 소수인지 판별하는 법 어떤 수가 소수이려면, $1$과 자기자신 말고는 약수가 없어야 한다. 소수가 아닌 경우, 가운데 위치한 약수를 중심으로 대칭적으로 약수가 형성된다. 예를 들어, $16$의 경우 약수가 $1$, $2$, $4$, $8$, $16$ 이므로 $4$를 중심으로 대칭적으로 약수가 형성됨을 알 수 있다. 따라서 어떤 수의 제곱근까지만 약수인지 판별하면 된다. 1 2 3 4 5 6 7 8 9 10 void IsPrimeNumber(int num) { for (int i = 2; i \u0026lt;= sqrt(num); i++) // num의 제곱근까지만 검사한다. { if (num % i != 0) continue; return false; // 나누어 떨어지면 소수가 아니다. } return true; } $1$부터 $N$까지의 모든 소수를 찾는 법 : 에라토스테네스의 체(Sieve of Eratosthenes) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vector\u0026lt;bool\u0026gt; GetPrimeNumbers(int num) { vector\u0026lt;bool\u0026gt; isPrime(num + 1, true); for (int i = 2; i \u0026lt; sqrt(num); i++) // num의 제곱근까지만 검사한다. { if (isPrime[i] == false) continue; // 아직 처리하지 않은 가장 작은 수를 선택한다 int mul = 2; while(i * mul \u0026lt;= num) // 그 수의 배수를 모두 제거한다 (그 수는 제거하면 안 됨) { isPrime[i * mul] = false; mul++; } } return isPrime; } 확률 조건부 확률 $P(A | B)$는 $B$ 사건이 발생했을 때, $A$가 일어날 확률이다. 즉, $B$를 사건 전체로 보고 $B$ 중에서 $A$인 부분이다. 이것을 사건 $B$에 대한 $A$의 조건부 확률이라고 한다. $$ P(A | B) = \\frac{ P(A \\cap B) }{ P(B) } $$ $$ P(A \\cap B) = P(A | B) P(B) $$ 교집합의 확률 $1$부터 $10$까지의 수 중에서 하나를 뽑을 때, 짝수이면서 $5$ 이하의 수를 뽑을 확률은 어떻게 될까? $$ P(짝수 \\cap 5이하) = P(짝수 | 5이하) P(5이하) $$ $$ P(짝수 \\cap 5이하) = \\frac{2}{5} * \\frac{1}{2} = \\frac{1}{5}$$ 베이즈 정리(Bayes\u0026rsquo; Theorem) 조건부 확률을 다음과 같이 정리할 수 있겠다. $$ P(A \\cap B) = P(A | B) P(B) = P(B | A) P(A) $$ $$ P(A | B) = \\frac{ P(B \\cap A)P(A) }{ P(B) } $$ 합집합의 확률 $A$ 사건 혹은 $B$ 사건이 벌어질 확률은? $$ P(A \\cup B) = P(A) + P(B) - P(A \\cap B) $$ $1$부터 $10$까지의 수 중에서 하나를 뽑을 때, 짝수이거나 $5$ 이하의 수를 뽑을 확률은 어떻게 될까? $$ P(짝수 \\cup 5이하) = P(짝수) + P(5이하) - P(짝수 \\cap 5이하)$$ $$ P(짝수 \\cup 5이하) = \\frac{1}{2} + \\frac{1}{2} - \\frac{1}{5} = \\frac{4}{5}$$ 독립 사건(independent event) $A$와 $B$가 서로 아무런 영향을 미치지 않는 사건을 말한다. $ P(A \\cap B) = 0 $, $ A \\cup B = U $ 예를 들면, $A$ 라는 사람이 공부를 하는 것과 $B$ 라는 사람이 음식을 먹는 것은 독립적인 사건이다. 서로에게 아무런 영향이 없다. 따라서 다음과 같은 공식이 성립한다. $$ P(A | B) = P(A | B^c) = P(A) $$ 이것을 조건부 확률 공식에 대입하면 다음과 같다. $$ P(A \\cap B) = P(A) P(B) $$ 상호 배타적 사건(mutually exclusive event) 어떤 한 사건이 일어나면 다른 사건은 일어날 수 없는 경우이다. $ P(A \\cap B) = 0 $, $ (A, B) \\subset C $ $A$와 $B$는 $C$라는 집단 안에 소속되어 있지만 서로 공통적인 부분은 없다는 뜻이다. 예를 들면, 남성과 여성은 상호배타적이다. 남성과 여성은 둘 다 \u0026lsquo;인간\u0026rsquo;이라는 카테고리에 포함되지만 서로 다르기 때문이다. $P(A \\cap B) = 0$이므로 다음과 같다. $$ P(A \\cup B) = P(A) + P(B) $$ 독립 사건과 상호 배타적 사건은 서로 다른 개념이며, 독립 사건이면서 상호 배타적 사건인 경우는 존재하지 않는다. 재귀와 동적 프로그래밍 재귀적 해법 해당 문제가 재귀 문제인지 아는 방법? 해당 문제를 작은 크기의 부분문제(Subproblem) 로 만들 수 있는지 본다. (1) 하향식 접근법(Top-down approach) 문제를 어떻게 하면 부분문제로 나눌 수 있는지 생각해본다. 부분문제끼리 겹치지 않아야 한다. (2) 상향식 접근법(Bottom-up approach) 간단한 것부터 풀이를 시작해서, 이전에 풀었던 사례를 확장하여 다음 풀이를 찾는다. 예를 들면, 원소 하나를 갖는 리스트에서 시작하여, 두 개, 세 개 늘려가며 풀이법을 찾는다. (3) 반반 접근법(Half-and-half approach) 데이터를 절반으로 나누는 방법이다. 예를 들면, 이진 탐색이나 병합 정렬이 있겠다. 재귀적 해법 vs. 순환적 해법 재귀 호출이 한 번 발생할 때마다 스택에 새로운 층(layer)을 추가해야 하므로, 공간 효율성이 나빠질 수 있다. 모든 재귀적(recursive) 알고리즘은 순환적(iterative) 으로 구현이 가능하다. 하지만 때로 순환적 알고리즘은 코드가 복잡해지므로, 잘 절충해서 선택해야겠다. 동적 프로그래밍 동적 프로그래밍이란? 부분문제를 찾아서, 재귀나 반복문을 사용해서 푸는데, 현재 결과를 캐시에 저장해서 연산 속도를 비약적으로 높인다. 예를 들면, 바로 앞 두 항의 합을 구하는 피보나치 수(Fibonacci number) 가 있다. 간단하게 구현한 아래 코드의 경우 재귀 트리를 참고하면, 계속 2개의 자식으로 분기되므로 $O(2^n)$의 시간복잡도가 걸린다. 1 2 3 4 5 int GetFibonacci(int x) { if (x == 1 || x == 2) return 1; return GetFibonacci(x - 1) + GetFibonacci(x - 2); } (1) 하향식 동적 프로그래밍(메모이제이션) 재귀 트리를 살펴보면, 중복되는 노드들이 있다. 이 값들을 저장했다가 사용하면 시간복잡도를 $O(n)$으로 만들 수 있겠다. 1 2 3 4 5 6 7 8 9 int GetFibonacci(int x, vector\u0026lt;int\u0026gt;\u0026amp; d) { if (x == 1 || x == 2) return 1; if (d[x] != 0) return d[x]; // 이미 계산한 적 있는 문제라면 그대로 반환 d[x] = GetFibonacci(d, x - 1) + GetFibonacci(d, x - 2); return d[x]; } (2) 상향식 동적 프로그래밍 초기 사례인 fib(0)과 fib(1)을 구하고 이것을 이용해 fib(2)를 계산하며 점점 올라가는 방식이다. 1 2 3 4 5 6 7 8 9 10 int GetFibonacci(int x, vector\u0026lt;int\u0026gt;\u0026amp; d) { d[1] = 1; d[2] = 1; for (int i = 3; i \u0026lt;= x; i++) d[i] = d[i - 1] + d[i - 2]; return d[x]; } References 코딩 인터뷰 완전 분석 ","date":"2022-11-12T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/algorithm-04/","title":"[Algorithm] 수학적 개념과 알고리즘"},{"content":" 그래프의 종류 그래프 노드 간의 네트워크 구조이다. 노드와 노드를 연결하는 간선(edge)를 모아 놓은 것이다. 그래프의 종류 방향성이 있는가? 무방향, 일방향, 양방향 모든 노드가 연결되어 있는가? 이것을 연결 그래프(connected graph)라고 한다. 가중치가 있는가? 그래프를 표현하는 방법 인접 리스트 Adjacency list (기준노드)배열 or 해시 테이블 + (기준 노드에 연결된 노드들)배열 or 동적 가변 크기 배열 or 연결리스트 1 2 3 4 1: 2, 3 2: 1, 3 3: 1, 2, 4 4: 3 인접 행렬 Adjacency matrix $n$ x $n$ bool 행렬이다. 만약 matrix[i][j]가 true라면 i에서 j로의 간선이 있다는 의미이다. 1 2 3 4 5 6 7 | 0 1 2 3 4 ------------------ 0 | 0 0 0 0 0 1 | 0 0 1 1 0 2 | 0 1 0 1 0 3 | 0 1 1 0 1 4 | 0 0 0 1 0 그래프 탐색 알고리즘 깊이 우선 탐색 DFS (Depth-first search) 끝까지 가본 후에 갈 길이 없으면, 스택에서 꺼내어 다시 끝까지 간다. 모든 노드를 방문하고자 할 때 더 선호된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // graph는 인접리스트 형태이다. void DFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int node, vector\u0026lt;bool\u0026gt;\u0026amp; visited) { // 해당 노드를 방문한다. visited[node] = true; cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 해당 노드와 연결된 노드들을 방문해간다. for (int i = 0; i \u0026lt; graph[node].size(); i++) { int curNode = graph[node][i]; // 연결된 노드 중에 방문하지 않은 노드가 있다면 방문한다. if (visited[curNode] == false) DFS(graph, curNode, visited); } } 너비 우선 탐색 BFS (Breadth-first search) 인접 노드를 모두 방문하고, 큐에서 꺼내어 다시 모두 방문한다. 최단 경로 혹은 임의의 경로를 찾고 싶을 때 더 빠르다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // graph는 인접리스트 형태이다. void BFS(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int firstNode, vector\u0026lt;bool\u0026gt;\u0026amp; visited) { queue\u0026lt;int\u0026gt; que; // 큐를 사용한다. que.push(firstNode); visited[firstNode] = true; // 첫 노드 while (que.size() != 0) { // 큐에서 하나를 꺼내 방문한다. int node = que.front(); que.pop(); std::cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 해당 노드와 연결된 노드들 중에 방문하지 않은 노드가 있다면 모두 큐에 넣는다. for (int i = 0; i \u0026lt; graph[node].size(); i++) { int curNode = graph[node][i]; if (visited[curNode] == false) { que.push(curNode); visited[curNode] = true; } } } } (3) 양방향 탐색(Bidirectional search) 출발지와 도착지 사이에 최단 경로를 찾을 때 사용된다. 출발지와 도착지 두 노드에서 동시에 BFS를 한 뒤, 충돌하는 경우에 경로를 찾는다. 최단 경로 알고리즘 다익스트라(Dijkstra) 플로이드 워셜(Floyd Warshall) 조건 음의 간선이 없어야 한다 결과 하나의 노드에서 모든 노드로 가는 최단거리 모든 노드에서 모든 노드로 가는 최단거리 표현 인접 리스트 인접 행렬 방법 A까지 거리 + A~B 거리 \u0026lt; B까지 거리 이면 갱신 A~B 최단거리 = min(A~B, A~K~B) 시간 복잡도 우선순위 큐 사용 시, $O(E \\log V)$ $O(V^3)$ 공통 구조체 1 2 3 4 5 struct Node { int to; int cost; }; 다익스트라 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // graph는 인접리스트 형태이며 cost정보가 추가되었다. // table은 INF로 초기화 된 상태이다. void Dijkstra(int startNode, vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt;\u0026amp; graph, vector\u0026lt;int\u0026gt;\u0026amp; table) { int fromCur = 0, fromCost = 0, toCur = 0, toCost = 0; priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pq; // 우선순위 큐를 사용하면 더 빠르다. pq.push({ 0, startNode }); // 첫 노드 table[startNode] = 0; while(!pq.empty()) { // 가장 짧은 거리의 노드를 뺀다. fromCur = pq.top().second; fromCost = -pq.top().first; pq.pop(); if (table[fromCur] \u0026lt; fromCost) return; // 해당 노드와 연결된 노드들 중에 for (int i = 0; i \u0026lt; graph[fromCur].size(); i++) { toCur = graph[fromCur][i].to; // B toCost = fromCost + graph[fromCur][i].cost; // A까지 총거리 + A~B 거리를 if (toCost \u0026lt; table[toCur]) // B까지의 총거리와 비교해서 더 짧다면 { // 갱신하고 우선순위 큐에 넣는다. table[toCur] = toCost; pq.push({ -toCost, toCur }); // -를 붙여서 값이 적은 순으로 우선순위가 높게 한다. } } } } 플로이드 워셜 1 2 3 4 5 6 7 8 9 // graph는 인접행렬 형태이다. void FloydWarshall(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int nodeNum) { for (int k = 1; k \u0026lt; nodeNum + 1; k++) for (int a = 1; a \u0026lt; nodeNum + 1; a++) for (int b = 1; b \u0026lt; nodeNum + 1; b++) graph[a][b] = min(graph[a][k] + graph[k][b], graph[a][b]); } 벨만-포드 다익스트라는 음의 간선을 처리할 수 없지만, 벨만-포드는 처리할 수 있다. 대신 시간 복잡도가 느리다. 따라서 음의 간선이 있다면 벨만-포드를, 음의 간선이 없다면 다익스트라를 사용한다. 다익스트라(Dijkstra) 벨만-포드(Bellman-Ford) 조건 음의 간선이 없어야 한다 결과 하나의 노드에서 모든 노드로 가는 최단거리 모든 노드에서 모든 노드로 가는 최단거리 방법 방문하지 않은 노드 중에서 최단 거리가 가장 가까운 노드만을 방문한다 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구해나간다 시간 복잡도 우선순위 큐 사용 시, $O(E \\log V)$ $O(|V||E|)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 struct Edge { int from; int to; int cost; }; // table은 INF로 초기화 된 상태이다. void BellmanFord(vector\u0026lt;Edge\u0026gt;\u0026amp; edges, vector\u0026lt;int\u0026gt;\u0026amp; table, int nodeNum, int startNode) { // 시작 노드까지의 거리는 0 table[startNode] = 0; // 정점의 횟수만큼 for (int i = 0; i \u0026lt; nodeNum; i++) { // 모든 간선을 살펴본다. for (int j = 0; j \u0026lt; edges.size(); j++) { int destTot = table[edges[i].to]; int srcTot = table[edges[i].from]; int curCost = edges[i].cost; if (srcTot == INF) continue; // 새로운 값이 더 작으면 갱신 if (srcTot + curCost \u0026lt; destTot) table[edges[i].to] = srcTot + curCost; } } // 모든 간선을 살펴본다. for (int i = 0; i \u0026lt; edges.size(); i++) { int destTot = table[edges[i].to]; int srcTot = table[edges[i].from]; int cost = edges[i].cost; if (srcTot == INF) continue; // 음의 가중치 때문에 무한히 최단 경로가 작아진다면 알려준다. if (srcTot + cost \u0026lt; destTot) printf(\u0026#34;Graph contains negative weight cycle\\n\u0026#34;); } } A* 알고리즘 주어진 출발 노드에서부터 목표 노드까지 가는 최단 경로를 찾아내는 알고리즘이다. 출발 노드와 목적지 노드가 명확히 주어진다. 다익스트라와 비슷하나, 휴리스틱(Heuristics) 이라는 추정값을 이용해서 최단거리를 구해나간다는 점이 다르다. 각 단계에서 노드를 평가하는 방법은 다음과 같다.\n$ f(n) = g(n) + h(n)$ $g(n)$ : 출발 노드에서부터 노드 $n$까지의 경비값 $h(n)$ : 노드 $n$에서부터 목표 노드까지의 추정된 경비값 그리드 맵에서의 휴리스틱 $h(n)$은 다음과 같이 구할 수 있다.\n4방향 이동 : 맨하튼 거리 8방향 이동 : Diagonal 거리 어느 방향이든 이동 : 유클리드 거리 참고 사이트 그리드 맵에서 8방향 이동 시 A* 알고리즘으로 최단 경로를 구하는 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int INF = 999; struct Pos { int x, y; }; struct Node { int f; Pos pos; bool operator\u0026lt;(const Node\u0026amp; rhs) const { return f \u0026lt; rhs.f; } }; struct NodeData { int g, h, f; Pos prev; // 이전 노드 값 NodeData() { g = INF; h = INF; f = INF; prev = {0, 0}; } void Print() { printf(\u0026#34;%2d+%2d=%2d(%d, %d) \u0026#34;, g, h, f, prev.x, prev.y); } }; class AStar { private: const int D = 10; const int D_DIAGONAL = 14; const int DIR_LENGTH = 8; const Pos DIR[8] = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}}; NodeData ** table; int getG(Pos pos) { return table[pos.x][pos.y].g; } int getH(Pos pos) { return table[pos.x][pos.y].h; } int getF(Pos pos) { return table[pos.x][pos.y].f; } void setTable(Pos pos, int g, int h, Pos prev) { table[pos.x][pos.y].g = g; table[pos.x][pos.y].h = h; table[pos.x][pos.y].f = g + h; table[pos.x][pos.y].prev = prev; } int getDistance(Pos from, Pos to) { int xDis = abs(from.x - to.x); int yDis = abs(from.y - to.y); int min = (xDis \u0026lt; yDis) ? xDis : yDis; int max = (xDis \u0026lt; yDis) ? yDis : xDis; // 8방향 대각선 이동 가능 거리 return min * D_DIAGONAL + (max - min) * D; } void aStar(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; map, int row, int col, Pos start, Pos des) { // 테이블 초기화 table = new NodeData*[row]; for (int i = 0; i \u0026lt; row; i++) { table[i] = new NodeData[col](); } priority_queue\u0026lt;Node\u0026gt; pq; // 시작노드에서 시작노드까지의 거리 0 // 시작노드에서 목적지노드까지의 거리 H setTable(start, 0, getDistance(des, start), {0, 0}); // { 우선순위의 기준이 되는 F값 , xy좌표 } pq.push({ -getF(start), start }); while (!pq.empty()) { Pos cur = pq.top().pos; int curF = -pq.top().f; pq.pop(); // 목적지에 도달했다면 끝내기 if (cur.x == des.x \u0026amp;\u0026amp; cur.y == des.y) break; // 기존의 F값보다 \u0026lt; 현재 노드의 F값이 더 크면 (더 좋은(짧은) 거리값이 아니면) // 필요 없다 if (getF(cur) \u0026lt; curF) continue; for (int i = 0; i \u0026lt; DIR_LENGTH; ++i) { Pos next = { cur.x + DIR[i].x, cur.y + DIR[i].y }; if (next.x \u0026lt; 0 || next.y \u0026lt; 0) continue; if (row \u0026lt;= next.x || col \u0026lt;= next.y) continue; if (map[next.x][next.y] == INF) continue; // 노드 next의 G값 = 이전노드 cur의 G값 + 이전노드와 next의 거리 // 노드 next의 F값 = G값 + 목적지노드와 next의 거리(H) int nextG = getG(cur) + getDistance(cur, next); int nextH = getDistance(des, next); int nextF = nextG + nextH; if (getF(next) \u0026lt; nextF) continue; setTable(next, nextG, nextH, cur); pq.push({ -getF(next), next }); } } } void printTable(int row, int col, Pos start, Pos des) { printf(\u0026#34;시작 노드 : {%d, %d}, 목적지 노드 : {%d, %d}\\n\u0026#34;, start.x, start.y, des.x, des.y); printf(\u0026#34;형식 : G + H = F (이전노드x, 이전노드y)\\n\u0026#34;); for (int i = 0; i \u0026lt; row; i++) { for (int j = 0; j \u0026lt; col; j++) { if (table[i][j].g != INF) table[i][j].Print(); else { cout \u0026lt;\u0026lt; setw(15) \u0026lt;\u0026lt; \u0026#34;\u0026#34;; } } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } void printPath(Pos start, Pos des) { // 경로 출력을 위해 목적지부터 되돌아가며 path에 경로 넣기 vector\u0026lt;Pos\u0026gt; path; path.push_back(des); Pos cur = table[des.x][des.y].prev; while (1) { path.push_back(cur); if (cur.x == start.x \u0026amp;\u0026amp; cur.y == start.y) break; cur = table[cur.x][cur.y].prev; } cout \u0026lt;\u0026lt; \u0026#34;path : \u0026#34;; for (int i = path.size() - 1; i \u0026gt;= 0; i--) { cout \u0026lt;\u0026lt; \u0026#34;{\u0026#34; \u0026lt;\u0026lt; path[i].x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; path[i].y \u0026lt;\u0026lt; \u0026#34;}\u0026#34;; if (i != 0) cout \u0026lt;\u0026lt; \u0026#34; \u0026gt; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } public: AStar(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; map, int row, int col, Pos start, Pos des) { aStar(map, row, col, start, des); printTable(row, col, start, des); printPath(start, des); } }; int main() { int row = 5; int col = 5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; map = { {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, INF, 0}, {0, INF, INF, INF, 0}, {0, 0, 0, 0, 0} }; Pos start = { 0, 0 }; Pos des = { 4, 4 }; AStar * astar = new AStar(map, row, col, start, des); delete astar; } 위상 정렬 위상 정렬(Topology sort) 조건 사이클이 없는 방향 그래프 설명 방향성에 거스르지 않고 순서대로 정렬하기 인접 리스트를 사용한다 시간 복잡도 모든 노드와 간선을 확인하므로, $O(V + E)$이다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // BFS를 사용한 방법이다. // indegree는 해당 노드(인덱스)로 들어오는 카운트가 저장된 배열이다. // graph는 인접 리스트 형태이다. void TopologySort() { int nodeNum, edgeNum; cin \u0026gt;\u0026gt; nodeNum \u0026gt;\u0026gt; edgeNum; // 진입차수를 0으로 초기화 vector\u0026lt;int\u0026gt; indegree(nodeNum + 1); // 그래프 입력 받기 vector\u0026lt;int\u0026gt; graph[10001]; for (int i = 0; i \u0026lt; edgeNum; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; graph[from].push_back(to); indegree[to] += 1; } vector\u0026lt;int\u0026gt; result; queue\u0026lt;int\u0026gt; q; // 큐를 사용한다. // 진입차수가 0인 노드를 모두 큐에 넣는다. for (int i = 1; i \u0026lt; nodeNum + 1; i++) if (indegree[i] == 0) q.push(i); // 큐가 빌 때까지 계속한다. while(!q.empty()) { // 큐에서 노드를 하나 꺼낸다. 꺼낸 순서가 정렬 결과이다. int from = q.front(); q.pop(); result.push_back(from); // 꺼낸 노드와 연결된 노드의 진입차수를 1씩 감소시킨다. for (int i = 0; i \u0026lt; graph[from].size(); i++) { int to = graph[from][i]; indegree[to]--; // 진입차수가 0이 되면 큐에 넣는다. if (indegree[to] == 0) q.push(to); } } } 최소 비용 신장트리 알고리즘 신장 트리(Spanning tree) 모든 노드를 포함하면서, 사이클이 존재하지 않는 부분 그래프. 최소 비용 신장트리(MST; Minimum Spanning Tree) 알고리즘 최소한의 비용으로 모든 노드를 연결하는 알고리즘. 크루스칼 알고리즘 크루스칼 알고리즘(Kruskal Algorithm) 조건 가중치가 있는 무방향 그래프 설명 그리디를 사용하여 최소 비용 간선 순으로 사이클이 발생하는지 체크한다 시간 복잡도 간선 정렬 작업이 제일 오래걸리는 부분이므로, $O(E \\log E)$이다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 struct EdgeData { int a; int b; int cost; // 비용이 작은 것이 앞으로 간다. bool operator\u0026lt;(EdgeData b) { return cost \u0026lt; b.cost; } }; void UnionParent(int a, int b, vector\u0026lt;int\u0026gt;\u0026amp; parent) { a = FindParent(a, parent); b = FindParent(b, parent); if (a \u0026gt; b) parent[a] = parent[b]; else parent[b] = parent[a]; } int FindParent(int idx, vector\u0026lt;int\u0026gt;\u0026amp; parent) { if (idx != parent[idx]) parent[idx] = FindParent(parent[idx], parent); return parent[idx]; } void Kruskal() { int nodeNum, edgeNum; cin \u0026gt;\u0026gt; nodeNum \u0026gt;\u0026gt; edgeNum; // 부모 테이블을 자기 자신으로 초기화 vector\u0026lt;int\u0026gt; parent(nodeNum + 1); for (int i = 1; i \u0026lt; nodeNum + 1; i++) parent[i] = i; // 연결된 간선에 대한 정보 입력 받기 vector\u0026lt;EdgeData\u0026gt; edges; for (int i = 0; i \u0026lt; edgeNum; i++) { int a, b, cost; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; cost; edges.push_back({ a, b, cost }); } // 간선을 비용에 따라 오름차순으로 정렬한다. E log E의 시간 복잡도가 걸린다. sort(edges.begin(), edges.end()); int a, b, result = 0; for (int i = 0; i \u0026lt; edges.size(); i++) { a = edges[i].a; b = edges[i].b; // 연결된 두 노드의 부모노드가 같다면 사이클이므로 제외하고, if (FindParent(a, parent) == FindParent(b, parent)) continue; // 다르다면 포함시킨다 == Union한다. UnionParent(a, b, parent); result += edges[i].cost; } cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } References 코딩 인터뷰 완전 분석 ","date":"2022-11-05T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/algorithm-03/","title":"[Algorithm] 자료구조 - 그래프"},{"content":" 트리의 종류 트리 부모-자식의 계층 구조이다. 하나의 루트 노드를 갖는다. 루트 노드는 0개 이상의 자식을 갖고, 그 자식 또한 0개 이상의 자식을 갖는다. 트리는 그래프의 한 종류이다. 사이클(cycle)이 존재할 수 없는 하나의 연결 그래프(connected graph)라고 볼 수 있다. 트리 종류 의미 이진트리 (Binary tree) 자식이 최대 2개인 트리 완전 이진트리 (Complete binary tree) 자식이 최대 2개 + 왼쪽부터 꽉꽉 채워짐 전 이진트리 (Full binary tree) 자식이 최대 2개 + 자식이 아예 없거나 정확히 2개 있음 포화 이진트리 (Perfect binary tree) 전부 자식이 2개 노드의 개수가 정확히 $2^{k-1}$($k$는 트리의 높이) 힙 (Heap) 자식이 최대 2개 + 왼쪽부터 꽉꽉 채워짐 + 모든 자식 \u0026lt; 부모 (최대힙) or 모든 자식 \u0026gt; 부모 (최소힙) 이진 탐색 트리 (BST; Binary search tree) 자식이 최대 2개\n+ 왼쪽 모든 자식 \u0026lt; 부모 \u0026lt; 오른쪽 모든 자식 균형 트리\n(Balenced tree) 자식이 최대 2개\n+ 왼쪽 모든 자식 \u0026lt; 부모 \u0026lt; 오른쪽 모든 자식\n+ 균형 (엄격한 AVL, 약한 레드-블랙 트리) 힙 (부모노드가 가장 작은 값이 되는, 최소힙을 기준으로 설명하면) 삽입 밑바닥 가장 오른쪽에 삽입한다. 계속 부모와 비교하면서, 해당 노드 \u0026lt; 부모이면 교환하며 올라간다. $O(\\log n)$ 최소 원소 뽑아내기 가장 작은 원소는 루트 노드이므로, 그것을 빼내면 된다. 그 후에는? 밑바닥 가장 오른쪽 원소를 루트로 올린다. 계속 자식들과 비교하면서, 해당 노드 \u0026gt; 자식이면 교환하며 내려간다. $O(\\log n)$ 코드 보기\n이진 탐색 트리 이진 탐색 트리(BST; binary search tree) 는 자식이 최대 2개이면서 왼쪽 모든 자식 \u0026lt; 부모 \u0026lt; 오른쪽 모든 자식과 같은 특징을 가진다. 검색 이진 탐색처럼 절반씩 나눠가며 찾아 내려가기 때문에 트리의 높이인 $O(\\log n)$이 걸린다. 하지만 균형이 깨져있어서 자식 노드들이 한쪽으로 몰려 있다면 $O(n)$ 이 걸린다. 삽입 들어갈 위치를 찾는데 트리 높이 만큼의 시간인 $O(\\log n)$이 걸린다. 위치를 찾았다면 삽입 한다. 삭제 삭제할 값을 찾은 후 자식이 하나이거나 없으면, 삭제할 값을 지우고, 자식을 부모에 연결한다. 자식이 둘이면, 오른쪽 자식의 자식들 중에 가장 작은 노드(Successor)를 찾아서 교환하고, 삭제한다. 시간 복잡도 삭제 대상 노드를 찾는데 그 높이만큼($d$)의 시간이 걸린다. 삭제 대상 노드의 서브트리에서 Successor 노드를 찾는다.($h - d$) 총 $d + h - d = h = O(\\log n)$ 만큼의 시간 복잡도가 걸린다 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 #include \u0026lt;iostream\u0026gt; using namespace std; struct Node { int data; Node * left; Node * right; }; typedef Node * NodePtr; class BST { private: NodePtr root; // 삽입 시간 복잡도? 트리의 높이인 h == log n이 된다. NodePtr insertNode(NodePtr root, int data) { // 트리가 비어 있다면 새로운 노드를 만든다. if (root == nullptr) return makeNewNode(data); // 루트보다 작은 값이면 루트의 왼쪽에 추가한다. // 루트보다 큰 값이면 루트의 오른쪽에 추가한다. if (root-\u0026gt;data \u0026gt; data) root-\u0026gt;left = insertNode(root-\u0026gt;left, data); else if (root-\u0026gt;data \u0026lt; data) root-\u0026gt;right = insertNode(root-\u0026gt;right, data); return root; } // 삭제 시간 복잡도? // 삭제 대상 노드를 찾는데 그 높이만큼(d)의 시간이 걸린다. // 삭제 대상 노드의 서브트리에서 Successor 노드를 찾는다.(h-d) // 총 d + h - d 만큼 == h 만큼의 시간 복잡도가 걸린다 == log n NodePtr deleteNode(NodePtr root, int data) { // base case if (root == nullptr) return root; // 루트보다 작은 값이면 왼쪽으로 가본다. // 루트보다 큰 값이면 오른쪽으로 가본다. if (root-\u0026gt;data \u0026gt; data) root-\u0026gt;left = deleteNode(root-\u0026gt;left, data); // 알아서 삭제된 노드가 부모의 자식으로 연결된다. else if (root-\u0026gt;data \u0026lt; data) root-\u0026gt;right = deleteNode(root-\u0026gt;right, data); else // 삭제할 노드를 찾았으면 { NodePtr temp; // 자식이 하나거나 없으면, 지우고 자식(data or nullptr)을 부모에 연결한다. if (root-\u0026gt;left == nullptr) { temp = root-\u0026gt;right; free(root); return temp; } else if (root-\u0026gt;right == nullptr) { temp = root-\u0026gt;left; free(root); return temp; } // 자식이 둘이면, 오른쪽 자식 중에 가장 작은 노드를 찾아서 교환하고 삭제한다. else { temp = getSuccessorNode(root-\u0026gt;right); root-\u0026gt;data = temp-\u0026gt;data; // 왜 right 일까? 결국 마지막은 root를 리턴하므로. root-\u0026gt;right에서 시작했으니. 결과는 root이다. root-\u0026gt;right = deleteNode(root-\u0026gt;right, temp-\u0026gt;data); } } return root; } // 오른쪽 자식 중에 가장 작은 노드를 찾는다. NodePtr getSuccessorNode(NodePtr root) { if (root-\u0026gt;left == nullptr) return root; return getSuccessorNode(root-\u0026gt;left); } NodePtr search(NodePtr root, int data) { if (root == nullptr || root-\u0026gt;data == data) return root; else if (root-\u0026gt;data \u0026gt; data) return search(root-\u0026gt;left, data); else if (root-\u0026gt;data \u0026lt; data) return search(root-\u0026gt;right, data); } void printTree(Node *root, string indent = \u0026#34;\u0026#34;, bool last = true) { if (root == nullptr) return; cout \u0026lt;\u0026lt; indent; if (last) { cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } cout \u0026lt;\u0026lt; root-\u0026gt;data \u0026lt;\u0026lt; endl; printTree(root-\u0026gt;left, indent, false); printTree(root-\u0026gt;right, indent, true); } NodePtr makeNewNode(int data) { NodePtr newNode = new Node(); newNode-\u0026gt;data = data; newNode-\u0026gt;left = nullptr; newNode-\u0026gt;right = nullptr; return newNode; } public: BST() { root = nullptr; } void Insert(int key) { root = insertNode(root, key); } void Delete(int key) { root = deleteNode(root, key); } void PrintTree() { printTree(root); } }; int main() { BST* tree = new BST(); tree-\u0026gt;Insert(1); tree-\u0026gt;Insert(2); tree-\u0026gt;Insert(3); tree-\u0026gt;Insert(4); tree-\u0026gt;Insert(5); tree-\u0026gt;PrintTree(); tree-\u0026gt;Delete(2); tree-\u0026gt;Delete(4); cout \u0026lt;\u0026lt; \u0026#34;After deleting \u0026#34; \u0026lt;\u0026lt; endl; tree-\u0026gt;PrintTree(); delete tree; } AVL 트리 AVL 트리(Adelson-Velsky and Landis tree) 스스로 균형을 잡는 이진 탐색 트리(self-balancing binary search tree)이다. 삽입, 검색, 삭제에 늘 $O(\\log n⁡)$을 보장한다. AVL 트리는 레드-블랙 트리보다 더 엄격하게 균형이 잡혀 있기 때문에, 삽입과 삭제를 할 때 최악의 경우에는 더 많은 회전(rotations)이 필요하다. Balance Factor 왼쪽 서브트리의 높이 - 오른쪽 서브트리의 높이인 BF를 기준으로 높이 차이를 구해서 균형을 판단한다. AVL트리는 BF가 $1$에서 $-1$ 사이가 되는 균형 상태를 유지한다. 만약 BF가 $2$ 혹은 $-2$인 불균형이 되면 회전(rotation) 을 통해 균형을 잡는다. 불균형은 LR, LL, RL, RR 의 총 4 가지의 형태로 존재한다. $2$ 만큼 불균형이라면, 왼쪽 서브트리가 오른쪽 서브트리보다 더 높은 것이다. 이때, 오른쪽으로 추가된 노드가 있는 경우 LR (Left Right) 형태라고 한다. 이때, 왼쪽으로 추가된 노드가 있는 경우 LL (Left Left) 형태라고 한다. LR 불균형일 경우, LR → 왼쪽 회전 → LL → 오른쪽 회전 → 균형 으로 균형을 맞추고, LL 불균형일 경우, LL → 오른쪽 회전 → 균형 으로 균형을 맞추면 된다. $-2$ 만큼 불균형이라면, 오른쪽 서브트리가 왼쪽 서브트리보다 더 높은 것이다. 이때, 왼쪽으로 추가된 노드가 있는 경우 RL (Right Left) 형태라고 한다. 이때, 오른쪽으로 추가된 노드가 있는 경우 RR (Right Right) 형태라고 한다. RL 불균형일 경우, RL → 오른쪽 회전 → RR → 왼쪽 회전 → 균형 으로 균형을 맞추고, RR 불균형일 경우, RR → 왼쪽 회전 → 균형 으로 균형을 맞추면 된다. 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 #include \u0026lt;iostream\u0026gt; using namespace std; struct Node { int data; Node * left; Node * right; int height; }; typedef Node * NodePtr; class AVLTree { private: NodePtr root; NodePtr insertNode(NodePtr node, int key) { // 새노드와 루트를 비교해서 // 새노드가 작으면 : 왼쪽에 삽입 // 새노드가 크면 : 오른쪽에 삽입 if (node == nullptr) return (newNode(key)); if (key \u0026lt; node-\u0026gt;data) node-\u0026gt;left = insertNode(node-\u0026gt;left, key); else if (key \u0026gt; node-\u0026gt;data) node-\u0026gt;right = insertNode(node-\u0026gt;right, key); else return node; // 새로워진 노드의 높이 계산 node-\u0026gt;height = 1 + max(height(node-\u0026gt;left), height(node-\u0026gt;right)); // Balance Factor에 따라 균형 맞추기 int balanceFactor = getBalanceFactor(node); // 왼쪽 서브 트리가 높다. if (balanceFactor \u0026gt; 1) { // 루트의 왼쪽 자식의 왼쪽에 노드가 추가되었다. if (key \u0026lt; node-\u0026gt;left-\u0026gt;data) { return rightRotate(node); } // 루트의 왼쪽 자식의 오른쪽에 노드가 추가되었다. else if (key \u0026gt; node-\u0026gt;left-\u0026gt;data) { node-\u0026gt;left = leftRotate(node-\u0026gt;left); return rightRotate(node); } } // 오른쪽 서브 트리가 높다. else if (balanceFactor \u0026lt; -1) { // 루트의 오른쪽 자식의 오른쪽에 노드가 추가되었다. if (key \u0026gt; node-\u0026gt;right-\u0026gt;data) { return leftRotate(node); } // 루트의 오른쪽 자식의 왼쪽에 노드가 추가되었다. else if (key \u0026lt; node-\u0026gt;right-\u0026gt;data) { node-\u0026gt;right = rightRotate(node-\u0026gt;right); return leftRotate(node); } } return node; } NodePtr deleteNode(NodePtr root, int key) { // 위치를 찾아서 삭제한다. if (root == nullptr) return root; if (key \u0026lt; root-\u0026gt;data) root-\u0026gt;left = deleteNode(root-\u0026gt;left, key); else if (key \u0026gt; root-\u0026gt;data) root-\u0026gt;right = deleteNode(root-\u0026gt;right, key); // root == 삭제할 노드 else { if ((root-\u0026gt;left == nullptr) || (root-\u0026gt;right == nullptr)) { NodePtr temp = root-\u0026gt;left ? root-\u0026gt;left : root-\u0026gt;right; // 자식이 없으면 temp == root 삭제 if (temp == nullptr) { temp = root; root = nullptr; } // 한쪽 자식이 있으면 자식을 root 자리로 올리고 삭제 else { *root = *temp; } free(temp); } // 자식이 둘 다 있으면 else { // 오른쪽 서브트리에서 가장 작은 노드(successor)를 찾는다. NodePtr temp = getSuccessorNode(root-\u0026gt;right); // 삭제하려는 노드(root)에 successor의 값을 대입해서 옮긴다. root-\u0026gt;data = temp-\u0026gt;data; // 대입한 후 남겨진 successor 노드를 오른쪽 서브트리에서 삭제한다. root-\u0026gt;right = deleteNode(root-\u0026gt;right, temp-\u0026gt;data); } } if (root == nullptr) return root; // 새로워진 노드의 높이 계산 root-\u0026gt;height = 1 + max(height(root-\u0026gt;left), height(root-\u0026gt;right)); // Balance Factor에 따라 균형 맞추기 int balanceFactor = getBalanceFactor(root); // 왼쪽 서브 트리가 높다. if (balanceFactor \u0026gt; 1) { // 루트의 왼쪽 자식의 왼쪽에 노드가 많다. if (getBalanceFactor(root-\u0026gt;left) \u0026gt;= 0) { return rightRotate(root); } // 루트의 왼쪽 자식의 오른쪽에 노드가 많다. else { root-\u0026gt;left = leftRotate(root-\u0026gt;left); return rightRotate(root); } } // 오른쪽 서브 트리가 높다. else if (balanceFactor \u0026lt; -1) { // 루트의 오른쪽 자식의 오른쪽에 노드가 많다. if (getBalanceFactor(root-\u0026gt;right) \u0026lt;= 0) { return leftRotate(root); } // 루트의 오른쪽 자식의 왼쪽에 노드가 많다. else { root-\u0026gt;right = rightRotate(root-\u0026gt;right); return leftRotate(root); } } return root; } NodePtr rightRotate(NodePtr x) { // z z // x -\u0026gt; y // y x // x y // y -\u0026gt; z x // z NodePtr y = x-\u0026gt;left; // [y의 오른쪽 자식 처리] // y의 오른쪽 자식은 x의 왼쪽 자식이 된다. x-\u0026gt;left = y-\u0026gt;right; // x의 왼쪽 자식이었던 y가 // x를 오른쪽 자식으로 삼는 부모가 된다. y-\u0026gt;right = x; // 높이 갱신 x-\u0026gt;height = max(height(x-\u0026gt;left), height(x-\u0026gt;right)) + 1; y-\u0026gt;height = max(height(y-\u0026gt;left), height(y-\u0026gt;right)) + 1; // 새로운 루트노트 y return y; } NodePtr leftRotate(NodePtr x) { // z z // x -\u0026gt; y // y x // x y // y -\u0026gt; x z // z NodePtr y = x-\u0026gt;right; // [y의 왼쪽 자식 처리] // y의 왼쪽 자식은 x의 오른쪽 자식이 된다. x-\u0026gt;right = y-\u0026gt;left; // x의 오른쪽 자식이었던 y가 // x를 왼쪽 자식으로 삼는 부모가 된다. y-\u0026gt;left = x; // 높이 갱신 x-\u0026gt;height = 1 + max(x-\u0026gt;left-\u0026gt;height, x-\u0026gt;right-\u0026gt;height); y-\u0026gt;height = 1 + max(y-\u0026gt;left-\u0026gt;height, y-\u0026gt;right-\u0026gt;height); // 새로운 루트노트 y return y; } int max(int a, int b) { return (a \u0026gt; b) ? a : b; } int height(NodePtr node) { if (node == nullptr) return 0; return node-\u0026gt;height; } int getBalanceFactor(NodePtr node) { if (node == nullptr) return 0; return height(node-\u0026gt;left) - height(node-\u0026gt;right); } // 가장 작은 노드를 찾는다. NodePtr getSuccessorNode(NodePtr root) { if (root-\u0026gt;left == nullptr) return root; return getSuccessorNode(root-\u0026gt;left); } void printTree(NodePtr root, string indent = \u0026#34;\u0026#34;, bool last = true) { if (root == nullptr) return; cout \u0026lt;\u0026lt; indent; if (last) { cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } cout \u0026lt;\u0026lt; root-\u0026gt;data \u0026lt;\u0026lt; endl; printTree(root-\u0026gt;left, indent, false); printTree(root-\u0026gt;right, indent, true); } NodePtr newNode(int data) { NodePtr node = new Node(); node-\u0026gt;data = data; node-\u0026gt;left = nullptr; node-\u0026gt;right = nullptr; node-\u0026gt;height = 1; return node; } public: AVLTree() { root = nullptr; } void Insert(int key) { root = insertNode(root, key); } void Delete(int key) { deleteNode(root, key); } void PrintTree() { printTree(root); } }; int main() { AVLTree * tree = new AVLTree(); tree-\u0026gt;Insert(33); tree-\u0026gt;Insert(13); tree-\u0026gt;Insert(53); tree-\u0026gt;Insert(9); tree-\u0026gt;Insert(21); tree-\u0026gt;Insert(61); tree-\u0026gt;Insert(8); tree-\u0026gt;Insert(11); tree-\u0026gt;PrintTree(); tree-\u0026gt;Delete(13); cout \u0026lt;\u0026lt; \u0026#34;After deleting \u0026#34; \u0026lt;\u0026lt; endl; tree-\u0026gt;PrintTree(); delete tree; } 레드-블랙 트리 레드-블랙 트리(Red-black tree) 스스로 균형을 잡는 이진 탐색 트리(self-balancing binary search tree)이다. 삽입, 검색, 삭제에 늘 $O(\\log n⁡)$을 보장한다. 레드-블랙 트리는 이진 탐색 트리의 특성에다 다음과 같은 조건이 추가된다. 순서 명칭 설명 1 Root Property 루트 노드는 Black이다. 2 External Property 모든 단말 노드들은 Black이다. 3 Internal Property Red 노드의 자식 양쪽은 언제나 Black이다. - No Double Red (Red 노드가 연속으로 나올 수 없다.) 4 Depth Property 어떤 노드에서 하위 단말 노드들에 도달하는 모든 경로의 Black 노드 개수는 같다. 이런 조건들에 의해서 다음과 같이 균형이 잡힌다. 3번 조건에 따르면 Red 노드가 연속으로 나올 수 없다. 그래서 최단 경로는 모두 Black 노드로만 구성되어 있다고 했을 때, 최장 경로는 Black 노드와 Red 노드가 번갈아 나오는 것이 될 것이다. 여기에 4번 조건에 따라서 모든 경로에서 Black 노드의 수가 같다고 했기 때문에, 존재하는 모든 경로에 대해 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없다. 다시 말해서 레드-블랙 트리는 개략적(roughly)으로 균형이 잡혀 있다(balanced). 따라서, 삽입, 삭제, 검색시 최악의 경우에서의 시간복잡도가 트리의 높이에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 효율적이라고 할 수 있다. 삽입 설명에 앞서, 노드의 이름을 이렇게 정한다. N는 삽입된 현재 노드 P는 삽입된 노드의 부모 노드 G는 삽입된 노드의 조부모 노드 U는 삽입된 노드의 삼촌 노드(G의 자식이며 P의 형제이다) 조건에 위반이 될 수 있는 경우는 두 가지를 생각해볼 수 있다. Red 위반 Red 노드가 Red 자식 노드를 가지고 있다. Black 위반 어떤 경로에 Black 노드가 더 많다. 삽입 노드는 Red이므로 Black 위반은 발생할 수 없다. 따라서 Red 위반을 고려해본다. Red 위반이기 때문에 N, P는 모두 Red이겠다. 그리고 그 전에는 위반이 없었으므로 G는 Black이겠다. 우리가 알 수 없는 것은 다음과 같다. U는 무슨 색인지 모른다. N, P가 어느쪽 자식인지 모른다. 모르는 것들을 가지고 각각의 case를 고려해서 트리의 균형을 유지해보자. Red 위반 시(N, P가 모두 Red일 때) case들 번호 조건 해결법 case 1 U가 Red P, U, G의 색깔을 변경한다.(Recolor) 그리고 재귀적으로 루트까지 적용해나간다. case 2 U가 Black case 2.1 P가 오른쪽자식 N이 왼쪽자식 P를 기준으로 오른쪽 회전을 하고, G를 기준으로 왼쪽 회전을 한다. Recolor case 2.2 P가 오른쪽자식 N이 오른쪽자식 G를 기준으로 왼쪽 회전을 한다. Recolor case 2.3 P가 왼쪽자식 N이 오른쪽자식 P를 기준으로 왼쪽 회전을 하고, G를 기준으로 오른쪽 회전을 한다. Recolor case 2.4 P가 왼쪽자식 N이 왼쪽자식 G를 기준으로 오른쪽 회전을 한다. Recolor 삭제 설명에 앞서, 노드의 이름을 이렇게 정한다. X는 삭제할 노드 P는 삭제할 노드의 부모 노드 S는 삭제할 노드의 형제 이진 탐색 트리의 규칙에 따라서 노드를 삭제한다. 삭제하려는 노드의 자식이 양쪽 다 있을 경우에는 오른쪽 서브 트리에서의 최솟값인 Successor 노드를 찾아 교환한다. 이 때, Successor 노드는 가장 작은 값이기 때문에(끝부분) 자식이 없거나 혹은 오른쪽에 하나만 있음을 알 수 있다. 삭제하려는 노드가 Red라면, Red를 삭제하는 것은 문제가 안 되므로 (Black의 개수가 중요했다) 그냥 삭제한다. 하지만 Black이라면 살펴봐야하겠다. 번호 조건 해결법 case 1 X가 Red 그냥 삭제한다 case 2 X가 Black case 2.1 S가 Red S와 P의 색깔을 변경한다. P를 기준으로 왼쪽으로 회전한다. 그리고 바뀐 위치의 S부터 다시 본다. case 2.2 S의 양쪽 자식이 Black S의 색깔을 변경한다. case 2.3 S의 오른쪽 자식이 Black S와 그의 왼쪽 자식의 색깔을 변경한다. S를 기준으로 오른쪽으로 회전한다. 그리고 아래의 과정을 거친다. case 2.4 S의 오른쪽 자식이 Red P, S와 그의 오른쪽 자식의 색깔을 변경한다. P를 기준으로 왼쪽으로 회전한다. 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 #include \u0026lt;iostream\u0026gt; using namespace std; enum Color { Black, Red }; struct Node { int data; Node * parent; Node * left; Node * right; Color color; }; typedef Node * NodePtr; class RBTree { private: NodePtr root; NodePtr TNULL; // 단말 노드 void insertNodeHelper(int key) { NodePtr node = newNode(key); NodePtr y = nullptr; NodePtr x = this-\u0026gt;root; // 이진 탐색 트리 규칙에 따라서 맞는 위치에 있는 // 리프 노드 x를 찾는다. // y는 x의 부모이다. while (x != TNULL) { y = x; if (node-\u0026gt;data \u0026lt; x-\u0026gt;data) x = x-\u0026gt;left; else x = x-\u0026gt;right; } // 새로운 노드의 부모를 y로 만든다. node-\u0026gt;parent = y; if (y == nullptr) root = node; else if (node-\u0026gt;data \u0026lt; y-\u0026gt;data) y-\u0026gt;left = node; else y-\u0026gt;right = node; // 새로운 노드가 루트 노드이면 검은색으로 만들고 리턴한다. if (node-\u0026gt;parent == nullptr) { node-\u0026gt;color = Black; return; } // 새로운 노드의 부모가 루트 노드이면 리턴한다. if (node-\u0026gt;parent-\u0026gt;parent == nullptr) return; // 조부모까지 존재한다면 (깊이 3) 규칙에 맞게 트리를 손본다. fixInsert(node); } void fixInsert(NodePtr node) { // G // P U // N NodePtr u; // 삽입 시 발생하는 빨간색 위반(N과 P가 모두 빨간색)인 경우 수정이 필요하다. while (node-\u0026gt;parent-\u0026gt;color == Red) { if (node-\u0026gt;parent == node-\u0026gt;parent-\u0026gt;parent-\u0026gt;right) { u = node-\u0026gt;parent-\u0026gt;parent-\u0026gt;left; // case 1 // U가 빨간색인 경우에는 // P, U, G의 색깔을 변경한다. if (u-\u0026gt;color == Red) { node-\u0026gt;parent-\u0026gt;color = Black; // P : Black u-\u0026gt;color = Black; // U : Black node-\u0026gt;parent-\u0026gt;parent-\u0026gt;color = Red; // G : Red // G를 node로 보고 거기부터 다시 본다. node = node-\u0026gt;parent-\u0026gt;parent; } // U가 검은색이고 P가 오른쪽 자식인 경우에는 else { // case 2.1 // N이 왼쪽 자식이라면 // P를 기준으로 오른쪽 회전을 하고, // G를 기준으로 왼쪽 회전을 한다. // G G N // U P -\u0026gt; U N -\u0026gt; G P // N P U if (node == node-\u0026gt;parent-\u0026gt;left) { node = node-\u0026gt;parent; rightRotate(node); } // case 2.2 // N이 오른쪽 자식이라면 // G를 기준으로 왼쪽 회전을 한다. // G P // U P -\u0026gt; G N // N U // 노드의 부모와 조부모 색상을 바꾼다. // red(P) // black(G) red // black node-\u0026gt;parent-\u0026gt;color = Black; // 부모 : Black node-\u0026gt;parent-\u0026gt;parent-\u0026gt;color = Red; // 조부모 : Red leftRotate(node-\u0026gt;parent-\u0026gt;parent); } } else { u = node-\u0026gt;parent-\u0026gt;parent-\u0026gt;right; // case 1 // U가 빨간색인 경우에는 // P, U, G의 색깔을 변경한다. if (u-\u0026gt;color == Red) { node-\u0026gt;parent-\u0026gt;color = Black; // P : Black u-\u0026gt;color = Black; // U : Black node-\u0026gt;parent-\u0026gt;parent-\u0026gt;color = Red; // G : Red // G를 N으로 만들고 거기부터 다시 본다. node = node-\u0026gt;parent-\u0026gt;parent; } // U가 검은색이고 P가 왼쪽 자식인 경우에는 else { // case 2.3 // N이 오른쪽 자식이라면 // P를 기준으로 왼쪽 회전을 하고, // G를 기준으로 오른쪽 회전을 한다. // G G N // P U -\u0026gt; N U -\u0026gt; P G // N P U if (node == node-\u0026gt;parent-\u0026gt;right) { node = node-\u0026gt;parent; leftRotate(node); } // case 2.4 // N이 왼쪽 자식이라면 // G를 기준으로 오른쪽 회전을 한다. // G P // P U -\u0026gt; N G // N U // 노드의 부모와 조부모 색상을 바꾼다. // red(P) // red black(G) // black node-\u0026gt;parent-\u0026gt;color = Black; // 부모 : Black node-\u0026gt;parent-\u0026gt;parent-\u0026gt;color = Red; // 조부모 : Red rightRotate(node-\u0026gt;parent-\u0026gt;parent); } } if (node == root) break; } root-\u0026gt;color = Black; } void deleteNodeHelper(NodePtr node, int key) { NodePtr z = TNULL; NodePtr x, y; // 이진 탐색 트리 규칙에 따라서 node를 옮기면서 key를 가진 노드를 찾는다. // 결과적으로 삭제하려는 노드가 z가 된다. while (node != TNULL) { if (node-\u0026gt;data == key) z = node; if (node-\u0026gt;data \u0026lt;= key) node = node-\u0026gt;right; else node = node-\u0026gt;left; } // 찾은 z가 리프 노드라면 그런 키를 가진 노드가 없는 것이다. if (z == TNULL) { cout \u0026lt;\u0026lt; \u0026#34;Couldn\u0026#39;t find key in the tree\u0026#34; \u0026lt;\u0026lt; endl; return; } y = z; int y_original_color = y-\u0026gt;color; // 이진 탐색 트리의 규칙에 따라 // 삭제하려는 노드의 // 왼쪽이 빈 노드라면, 오른쪽 노드를 삭제할 위치로 옮긴다. if (z-\u0026gt;left == TNULL) { // x는 결과적으로, 삭제하는 노드의 오른쪽 자식 위치이다. // 그리고 삭제하는 노드와 뒤바꾼 자리이다. x = z-\u0026gt;right; rbTransplant(z, z-\u0026gt;right); } // 오른쪽이 빈 노드라면, 왼쪽 노드를 삭제할 위치로 옮긴다. else if (z-\u0026gt;right == TNULL) { x = z-\u0026gt;left; rbTransplant(z, z-\u0026gt;left); } // 양쪽 다 자식이 있다면 else { // successor 노드를 찾는다. y = getMinimumNode(z-\u0026gt;right); y_original_color = y-\u0026gt;color; // x는 결과적으로 successor 노드의 오른쪽 자식 위치이다. // 그리고 삭제하려는 노드 \u0026lt;- sucessor 노드 \u0026lt;- x 처럼 이동한 자리이다. x = y-\u0026gt;right; if (y-\u0026gt;parent == z) { x-\u0026gt;parent = y; } else { // successor 노드의 오른쪽 자식을 successor 노드 자리에 놓는다. rbTransplant(y, y-\u0026gt;right); // 삭제하려는 노드의 오른쪽을 successor 노드의 오른쪽으로 만든다. y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;parent = y; } // 삭제하려는 노드 자리에 successor 노드를 놓는다. rbTransplant(z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;parent = y; y-\u0026gt;color = z-\u0026gt;color; } delete z; // 만약에 삭제한 노드의 색상이 Black이라면 // 자리를 바꾼 위치인 x부터 트리를 손본다. if (y_original_color == Black) fixDelete(x); } void fixDelete(NodePtr x) { NodePtr s; while (x != root \u0026amp;\u0026amp; x-\u0026gt;color == Black) { if (x == x-\u0026gt;parent-\u0026gt;left) { s = x-\u0026gt;parent-\u0026gt;right; // N이 Black인데 S가 Red이면 // P를 기준으로 왼쪽으로 회전한다. if (s-\u0026gt;color == Red) { // P S // N S -\u0026gt; P . // . . N . // case 2.1 s-\u0026gt;color = Black; // S : Black x-\u0026gt;parent-\u0026gt;color = Red; // P : Red leftRotate(x-\u0026gt;parent); // 바뀐 N의 위치에 따라 형제의 위치도 맞게 설정한다. s = x-\u0026gt;parent-\u0026gt;right; } // S의 양쪽 자식이 모두 Black이면 // S의 색깔을 Red로 바꾼다. // case 2.2 if (s-\u0026gt;left-\u0026gt;color == Black \u0026amp;\u0026amp; s-\u0026gt;right-\u0026gt;color == Black) { s-\u0026gt;color = Red; // S : Red // 한 칸 위로 올라가며 계속 본다. x = x-\u0026gt;parent; } else { // S의 오른쪽 자식이 Black이면 // case 2.3 if (s-\u0026gt;right-\u0026gt;color == Black) { s-\u0026gt;left-\u0026gt;color = Black; // S의 왼쪽자식 : Black s-\u0026gt;color = Red; // S : Red rightRotate(s); s = x-\u0026gt;parent-\u0026gt;right; } // S의 오른쪽 자식이 Red이면 // case 2.4 s-\u0026gt;color = x-\u0026gt;parent-\u0026gt;color; // S : P x-\u0026gt;parent-\u0026gt;color = Black; // P : Black s-\u0026gt;right-\u0026gt;color = Black; // S의 오른쪽 자식 : Black leftRotate(x-\u0026gt;parent); x = root; } } else { s = x-\u0026gt;parent-\u0026gt;left; if (s-\u0026gt;color == Red) { // case 2.1 s-\u0026gt;color = Black; x-\u0026gt;parent-\u0026gt;color = Red; rightRotate(x-\u0026gt;parent); s = x-\u0026gt;parent-\u0026gt;left; } if (s-\u0026gt;right-\u0026gt;color == Black \u0026amp;\u0026amp; s-\u0026gt;right-\u0026gt;color == Black) { // case 2.2 s-\u0026gt;color = Red; x = x-\u0026gt;parent; } else { if (s-\u0026gt;left-\u0026gt;color == Black) { // case 2.3 s-\u0026gt;right-\u0026gt;color = Black; s-\u0026gt;color = Red; leftRotate(s); s = x-\u0026gt;parent-\u0026gt;left; } // case 2.4 s-\u0026gt;color = x-\u0026gt;parent-\u0026gt;color; x-\u0026gt;parent-\u0026gt;color = Black; s-\u0026gt;left-\u0026gt;color = Black; rightRotate(x-\u0026gt;parent); x = root; } } } x-\u0026gt;color = Black; } void rbTransplant(NodePtr deleteThis, NodePtr moveThis) { // deleteThis의 자리에 moveThis를 옮긴다. if (deleteThis-\u0026gt;parent == nullptr) root = moveThis; else if (deleteThis == deleteThis-\u0026gt;parent-\u0026gt;left) deleteThis-\u0026gt;parent-\u0026gt;left = moveThis; else deleteThis-\u0026gt;parent-\u0026gt;right = moveThis; moveThis-\u0026gt;parent = deleteThis-\u0026gt;parent; } // 왼쪽 회전 void leftRotate(NodePtr x) { // z z // x -\u0026gt; y // y x // x y // y -\u0026gt; x z // z // x의 오른쪽 자식이었던 y가 // x를 왼쪽 자식으로 삼는 부모가 된다. NodePtr y = x-\u0026gt;right; // [y의 왼쪽 자식 처리] // y의 왼쪽 자식은 x의 오른쪽 자식이 된다. x-\u0026gt;right = y-\u0026gt;left; if (y-\u0026gt;left != TNULL) y-\u0026gt;left-\u0026gt;parent = x; // [y의 부모 처리] // x가 루트였다면 y를 루트로 // x가 왼쪽 자식이었으면 y를 왼쪽 자식으로 // x가 오른쪽 자식이었으면 y를 오른쪽 자식으로 y-\u0026gt;parent = x-\u0026gt;parent; if (x-\u0026gt;parent == nullptr) this-\u0026gt;root = y; else if (x == x-\u0026gt;parent-\u0026gt;left) x-\u0026gt;parent-\u0026gt;left = y; else x-\u0026gt;parent-\u0026gt;right = y; // [x, y 연결] y-\u0026gt;left = x; x-\u0026gt;parent = y; } // 오른쪽 회전 void rightRotate(NodePtr x) { // z z // x -\u0026gt; y // y x // x y // y -\u0026gt; x z // z // x의 왼쪽 자식이었던 y가 // x를 오른쪽 자식으로 삼는 부모가 된다. NodePtr y = x-\u0026gt;left; // [y의 오른쪽 자식 처리] // y의 오른쪽 자식은 x의 왼쪽 자식이 된다. x-\u0026gt;left = y-\u0026gt;right; if (y-\u0026gt;right != TNULL) y-\u0026gt;right-\u0026gt;parent = x; // [y의 부모 처리] // x가 루트였다면 y를 루트로 // x가 왼쪽 자식이었으면 y를 왼쪽 자식으로 // x가 오른쪽 자식이었으면 y를 오른쪽 자식으로 y-\u0026gt;parent = x-\u0026gt;parent; if (x-\u0026gt;parent == nullptr) this-\u0026gt;root = y; else if (x == x-\u0026gt;parent-\u0026gt;right) x-\u0026gt;parent-\u0026gt;right = y; else x-\u0026gt;parent-\u0026gt;left = y; // [x, y 연결] y-\u0026gt;right = x; x-\u0026gt;parent = y; } NodePtr getMinimumNode(NodePtr node) { while (node-\u0026gt;left != TNULL) node = node-\u0026gt;left; return node; } NodePtr getMaximumNode(NodePtr node) { while (node-\u0026gt;right != TNULL) node = node-\u0026gt;right; return node; } NodePtr getSuccessorNode(NodePtr node) { // 오른쪽 서브트리에서 제일 작은 노드이다. if (node-\u0026gt;right != TNULL) return getMinimumNode(node-\u0026gt;right); // 만약에 오른쪽 노드가 없다면, // 해당 노드가 오른쪽 자식인 부모로 계속 올라간다. NodePtr res = node-\u0026gt;parent; while (res != TNULL \u0026amp;\u0026amp; node == res-\u0026gt;right) { node = res; res = res-\u0026gt;parent; } return res; } NodePtr getPredecessorNode(NodePtr node) { // 왼쪽 서브트리에서 제일 큰 노드이다. if (node-\u0026gt;left != TNULL) return getMaximumNode(node-\u0026gt;left); // 만약에 왼쪽 노드가 없다면, // 해당 노드가 왼쪽쪽 자식인 부모로 계속 올라간다. NodePtr res = node-\u0026gt;parent; while (res != TNULL \u0026amp;\u0026amp; node == res-\u0026gt;left) { node = res; res = res-\u0026gt;parent; } return res; } NodePtr searchTreeHelper(NodePtr node, int key) { if (node == TNULL || key == node-\u0026gt;data) return node; if (key \u0026lt; node-\u0026gt;data) return searchTreeHelper(node-\u0026gt;left, key); return searchTreeHelper(node-\u0026gt;right, key); } void preOrderHelper(NodePtr node) { if (node == TNULL) return; cout \u0026lt;\u0026lt; node-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; preOrderHelper(node-\u0026gt;left); preOrderHelper(node-\u0026gt;right); } void inOrderHelper(NodePtr node) { if (node == TNULL) return; inOrderHelper(node-\u0026gt;left); cout \u0026lt;\u0026lt; node-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; inOrderHelper(node-\u0026gt;right); } void postOrderHelper(NodePtr node) { if (node == TNULL) return; postOrderHelper(node-\u0026gt;left); postOrderHelper(node-\u0026gt;right); cout \u0026lt;\u0026lt; node-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } void printHelper(NodePtr root, string indent, bool last) { if (root == TNULL) return; cout \u0026lt;\u0026lt; indent; if (last) { cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } string curColor = root-\u0026gt;color ? \u0026#34;RED\u0026#34; : \u0026#34;BLACK\u0026#34;; cout \u0026lt;\u0026lt; root-\u0026gt;data \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; curColor \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; printHelper(root-\u0026gt;left, indent, false); printHelper(root-\u0026gt;right, indent, true); } NodePtr getRoot() { return this-\u0026gt;root; } void initializeNULLNode(NodePtr node, NodePtr parent) { node-\u0026gt;data = 0; node-\u0026gt;parent = parent; node-\u0026gt;left = nullptr; node-\u0026gt;right = nullptr; node-\u0026gt;color = Black; } Node * newNode(int key) { NodePtr node = new Node; node-\u0026gt;parent = nullptr; node-\u0026gt;data = key; node-\u0026gt;left = TNULL; node-\u0026gt;right = TNULL; node-\u0026gt;color = Red; // 새 노드는 늘 Red이다. return node; } public: RBTree() { TNULL = new Node; initializeNULLNode(TNULL, nullptr); root = TNULL; } void InsertNode(int key) { insertNodeHelper(key); } void DeleteNode(int key) { deleteNodeHelper(this-\u0026gt;root, key); } NodePtr SearchNode(int key) { return searchTreeHelper(this-\u0026gt;root, key); } void PrintPreorder() { preOrderHelper(this-\u0026gt;root); } void PrintInorder() { inOrderHelper(this-\u0026gt;root); } void PrintPostorder() { postOrderHelper(this-\u0026gt;root); } void PrintTree() { if (root) printHelper(this-\u0026gt;root, \u0026#34;\u0026#34;, true); } }; int main() { RBTree * tree = new RBTree(); tree-\u0026gt;InsertNode(8); tree-\u0026gt;InsertNode(18); tree-\u0026gt;InsertNode(5); tree-\u0026gt;InsertNode(15); tree-\u0026gt;InsertNode(17); tree-\u0026gt;InsertNode(25); tree-\u0026gt;InsertNode(40); tree-\u0026gt;InsertNode(80); tree-\u0026gt;DeleteNode(25); tree-\u0026gt;PrintTree(); delete tree; } 트리의 순회 트리 순회 방식 순서 예제 결과 전위 순회 (Preorder) 방문 Left Right C B A E D F G 중위 순회 (Inorder) Left 방문 Right A B C D E F G 후위 순회 (Postorder) Left Right 방문 A B D G F E C 트라이 트라이(trie) = 접두사 트리(prefix tree) $K$-진 트리 구조를 통해 문자열을 저장하는 방식이다. ($K$는 단어 개수) 접두사를 빠르게 찾아볼 수 있다. 길이가 $K$인 문자열은 $O(K)$만에 유효한 접두사인지 확인할 수 있다. 자동완성 기능, 사전 검색 등 문자열을 탐색하는데 특화되어있는 자료구조다. 각 노드에 문자를 저장하고, 트리를 아래쪽으로 순회하면 단어 하나가 나온다. 단어의 끝은 널 노드(null node)인 *노드로 나타내거나 플래그로 나타낼 수 있다. 각 노드는 [ 널 노드를 사용한다면 1개(플래그라면 0개) ~ 알파벳 개수 + 1개 ]까지 자식을 갖고 있을 수 있다. References 코딩 인터뷰 완전 분석 https://algorithmtutor.com/Data-Structures/Tree/Red-Black-Trees/ https://ko.wikipedia.org/wiki/레드-블랙_트리 ","date":"2022-11-05T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/algorithm-02/","title":"[Algorithm] 자료구조 - 트리"},{"content":" 배열 해시 테이블 키(key) 를 값(value) 에 대응시킨 자료구조로써 매우 빠르게 데이터를 저장, 삭제, 검색할 수 있다. 각각의 key에 해시 함수(hash function) 를 적용해서 고유한 값을 얻고, 그 값을 이용해서 value를 저장, 삭제, 검색한다. 대표적인 해시 함수들 $k$ : 키 $n$ : 테이블 크기 $A$ : $0$ ~ $1$ 사이의 실수 해시 함수명 고유한 값을 얻는 법 Division Method $h(k) = k \\mod n$ Multiplication Method $h(k) = (kA \\mod 1) × m$ Digit Folding key 문자열을 ASCII 코드로 바꾸고 값을 합한 것 Univeral Hashing 해시 함수를 무작위로 선택하는 것 충돌이란? 각기 다른 key의 해시값이 똑같을 때를 말한다. 충돌을 해결할 수 있는 방법들\u0026hellip; [ 분리 연결법(Separate Chaining) ] 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장한다. (1) 연결 리스트(linked list)를 이용한 체이닝(chaining) 최악의 경우 원소를 찾는데, $O(n)$ 시간이 걸린다. (2) 균형 이진 탐색 트리(balanced binary search tree)를 이용한 체이닝 최악의 경우 원소를 찾는데, $O(\\log n)$ 시간이 걸린다. [ 개방 주소법(Open Addressing) ] 비어있는 해시 테이블의 공간을 활용하는 방법이다. (1) 선형 탐색(Linear Probing) 고정폭 만큼씩 이동한다. (2) 2차 탐색(Quadratic Probing) 폭을 제곱으로 늘리며 이동한다. $1^2$ \u0026gt; $2^2$ \u0026gt; $3^2$ (3) 2중 해시(Double Hashing Probing) 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 단점 해시 테이블에 담을 수 있는 전체 데이터가 배열의 크기에 제한된다. 클러스터링(clustering) 문제 예를 들어 배열의 크기가 100일 때 20~29가 채워져있다면, 다음 수가 인덱스 30으로 갈 확률이 10%나 된다. 각 언어별 해시 자료구조 자료구조 구현 정렬 연속할당 랜덤접근 검색/삽입/삭제 C++ map 레드블랙트리 O X Via Key $O(\\log n)$ C++ unordered_map 해시 테이블 X O Via Key $O(1)$ C# SortedDictionary 이진탐색트리 O X Via Key $O(\\log n)$ C# Dictionary 해시 테이블 X O Via Key $O(1)$ 가변 크기 배열 할당된 capacity를 넘어서면 자동으로 2배의 크기를 재할당한다. C++ vector\n멤버 중에 size()는 담긴 데이터의 개수이고, capacity()는 할당된 공간의 개수이다. resize()는 인자값만큼의 size()로 만든다. 늘릴때는 0으로 채운다. 줄일 때는 원소를 없앤다. reserve()는 size()는 변하지 않고, capacity()만 인자값만큼 늘린다. 늘리기만 된다. C# List\n기존에 배치된 메모리 위치와 크기를 유지한 상태에서 추가적으로 부족한 메모리를 할당받아서 연결하겠지? 아니다. 해당 크기의 2배의 메모리 공간을 새로 찾아서 할당하는 방식이다. 따라서 이전 공간은 가비지를 발생시킨다. 문자열 C#의 StringBuilder C#의 string은 불변(Immutable) 객체이다.\n따라서 새로운 문자열으로 변경, 추가하면 기존 값이 대체되는 것이 아니라, 해당 크기의 다른 공간을 새로 할당한다. 이것은 이전 공간의 가비지를 발생시킨다. 이에 반해 가변(Mutable) 객체인 StringBuilder는\n새로운 문자열으로 변경, 추가하면 기존 메모리 공간에 값을 변경, 추가한다. 따라서 변경이 일어나는 문자열은 StringBuilder를 사용해야 좋겠다. 연결리스트 연결리스트의 특징 랜덤접근이 불가능하다. 따라서 특정 인덱스를 상수 시간에 접근할 수 없다. $K$번째 원소를 찾고 있다면, 처음부터 $K$번 루프를 돌아야 한다. 순차접근이 일반 배열보다 느리다. 메모리에 순차적으로 원소가 저장되는 배열과 다르게, 연결리스트는 불연속적으로 저장된다. 따라서 (참조 지역성의 원리에 따라서) 캐시에 원소들이 함께 올라가지 않기 때문에 접근이 느릴 수밖에 없다. 원소를 추가, 삭제하는 것이 상수 시간에 가능하다. 가변 배열처럼 달리 추가, 삭제 후 나머지 원소를 뒤로 밀거나, 앞으로 옮기는 작업이 필요없다. 각 언어별 연결리스트 자료구조 자료구조 구현 정렬 연속할당 랜덤접근 검색 삽입/삭제 C++ list 이중 연결리스트 User X X $O(n)$ $O(1)$ C# LinkedList 이중 연결리스트 User X X $O(n)$ $O(1)$ Runner 기법 연결리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법이다. 빠른 Runner : 2칸씩 건너뛴다. 느린 Runner : 1칸씩 건너뛴다. 빠른 런너가 연결 리스트의 끝에 도달하면, 느린 런너는 연결 리스트의 중간 지점을 가리키게 된다. 여기서부터 값을 비교하거나 뒤집기를 시도하는 등 여러모로 활용할 수 있겠다. 스택과 큐 스택과 큐 비교 자료구조 특징 정렬 연속할당 랜덤접근 검색 삽입/삭제 언어 지원 스택 LIFO X O Only Top Top: $O(1)$ $O(1)$ C++ stack C# Stack 큐 FIFO X O Only Front Front: $O(1)$ $O(1)$ C++ queue C# Queue 스택 DFS(Depth-first search) 에서 사용한다. 재귀적(Recursive) 함수를 호출할 때 사용한다. 연결리스트로 구현할 수도 있다. 큐 BFS(Breadth-first search) 에서 사용한다. 컴퓨터 버퍼에서 주로 사용한다. 여러개가 입력이 되었으나 처리를 하지 못할 때, 버퍼(큐)를 만들어 대기 시킨다. 연결리스트로 구현할 수도 있다. References 코딩 인터뷰 완전 분석 ","date":"2022-11-05T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/algorithm-01/","title":"[Algorithm] 자료구조 - 배열, 문자열, 연결리스트, 스택, 큐"},{"content":" 인터프리터 (Interpreter) 어떤 언어에 대해 그 언어의 문법에 대한 표현을 정의하면서, 그 표현을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // 표현 public interface IExpression { bool Interpret(string context); } public class TerminalExpression : IExpression { private string data; public TerminalExpression(string data) { this.data = data; } // 해당 표현을 해석하는 해석자 public override bool Interpret(string context) { if (context.contains(data)) { return true; } return false; } } public class AndExpression : IExpression { private IExpression expr1 = null; private IExpression expr2 = null; public AndExpression(IExpression expr1, IExpression expr2) { this.expr1 = expr1; this.expr2 = expr2; } public override bool Interpret(string context) { return expr1.Interpret(context) \u0026amp;\u0026amp; expr2.Interpret(context); } } public class OrExpression : IExpression { private IExpression expr1 = null; private IExpression expr2 = null; public OrExpression(IExpression expr1, IExpression expr2) { this.expr1 = expr1; this.expr2 = expr2; } public override bool Interpret(string context) { return expr1.Interpret(context) || expr2.Interpret(context); } } class Program { static void Main(string[] args) { // 표현들 IExpression robert = new TerminalExpression(\u0026#34;Robert\u0026#34;); IExpression john = new TerminalExpression(\u0026#34;John\u0026#34;); IExpression julie = new TerminalExpression(\u0026#34;Julie\u0026#34;); IExpression Married = new TerminalExpression(\u0026#34;Married\u0026#34;); IExpression isMale = new OrExpression(robert, john); IExpression isMarriedWoman = new AndExpression(julie, married); // 컨텍스트 string context1 = \u0026#34;John\u0026#34;; string context2 = \u0026#34;Married Julie\u0026#34;; // 컨텍스트를 표현에 따라 해석한다. Console.WriteLine(\u0026#34;John is male? \u0026#34; + isMale.Interpret(context1)); // true Console.WriteLine(\u0026#34;Julie is a married women? \u0026#34; + isMarriedWoman.Interpret(context2)); // true } } References https://velog.io/@cham/Design-Pattern-인터프리터-패턴Interpreter-Pattern ","date":"2022-08-23T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-23/","title":"[Design Pattern] 행동 패턴 10. 인터프리터 (Interpreter)"},{"content":" 이터레이터 (Iterator) 내부 세부구조를 노출하지 않고, 어떤 집합 객체에 속한 요소들을 순차적으로 접근할 수 있는 방법을 제공한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 // 이터레이터 abstract class Iterator : IEnumerator { object IEnumerator.Current =\u0026gt; Current(); public abstract int Key(); public abstract object Current(); public abstract bool MoveNext(); public abstract void Reset(); } class AlphabeticalOrderIterator : Iterator { // 해당 컬렉션 private WordsCollection _collection; // 현재 위치 private int _position = -1; private bool _reverse = false; public AlphabeticalOrderIterator(WordsCollection collection, bool reverse = false) { this._collection = collection; this._reverse = reverse; if (reverse) { this._position = collection.getItems().Count; } } public override object Current() { return this._collection.getItems()[_position]; } public override int Key() { return this._position; } public override bool MoveNext() { int updatedPosition = this._position + (this._reverse ? -1 : 1); if (updatedPosition \u0026gt;= 0 \u0026amp;\u0026amp; updatedPosition \u0026lt; this._collection.getItems().Count) { this._position = updatedPosition; return true; } else { return false; } } public override void Reset() { this._position = this._reverse ? this._collection.getItems().Count - 1 : 0; } } // 이터레이터로 순회할 컬렉션 abstract class IteratorAggregate : IEnumerable { public abstract IEnumerator GetEnumerator(); } class WordsCollection : IteratorAggregate { List\u0026lt;string\u0026gt; _collection = new List\u0026lt;string\u0026gt;(); bool _direction = false; public void ReverseDirection() { _direction = !_direction; } public List\u0026lt;string\u0026gt; getItems() { return _collection; } public void AddItem(string item) { this._collection.Add(item); } public override IEnumerator GetEnumerator() { // 이터레이터를 생성한다. (팩토리 메서드) return new AlphabeticalOrderIterator(this, _direction); } } class Program { static void Main(string[] args) { // 컬렉션 var collection = new WordsCollection(); collection.AddItem(\u0026#34;First\u0026#34;); collection.AddItem(\u0026#34;Second\u0026#34;); collection.AddItem(\u0026#34;Third\u0026#34;); // Straight traversal foreach (var element in collection) { Console.WriteLine(element); } // Reverse traversal collection.ReverseDirection(); foreach (var element in collection) { Console.WriteLine(element); } } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-22T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-22/","title":"[Design Pattern] 행동 패턴 9. 이터레이터 (Iterator)"},{"content":" 커맨드 (Command) 클라이언트의 요구사항을 캡슐화해서 Command 객체로 만들어서, 이것을 실행하는 Invoker가 구체적인 요구사항을 모르도록 한다. 특징 Invoker가 Command를 몰라도 실행할 수 있다. 작업을 호출하는 클래스와 작업을 수행하는 클래스를 분리했다. 요구사항을 큐에 저장하거나, 로그로 기록하거나, 작업을 취소시킬 수도 있다. 명칭 설명 비유 Invoker Command를 갖고서 요청을 시작한다. 웨이트리스 Receiver 실제 작업을 수행한다. 주방장 Command Receiver를 받아서 실행하는 Execute()가 있다. 주문서 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 // Command public interface Command { public string name { get; } public void Execute(); public void Undo(); } public class NoCommand : Command { public string name =\u0026gt; \u0026#34;NoCommand\u0026#34;; public NoCommand() { } public void Execute() { } public void Undo() { } } public class DoorCloseCommand : Command { public string name =\u0026gt; \u0026#34;DoorCloseCommand\u0026#34;; Door door; public DoorCloseCommand(Door door) { this.door = door; } public void Execute() { door.Down(); } public void Undo() { door.Up(); } } public class DoorOpenCommand : Command { public string name =\u0026gt; return \u0026#34;DoorOpenCommand\u0026#34;; Door door; public DoorOpenCommand(Door door) { this.door = door; } public void Execute() { door.Up(); } public void Undo() { door.Down(); } } // Receiver public class Door { private string name; public Door(string name) { this.name = name; } public void Up() { Console.WriteLine(name + \u0026#34; Door up\u0026#34;); } public void Down() { Console.WriteLine(name + \u0026#34; Door Down\u0026#34;); } } // Invoker public class RemoteControl { private Command[] onCommands; private Command[] offCommands; private Command unDoCommand; public RemoteControl() { onCommands = new Command[7]; offCommands = new Command[7]; for (int i = 0; i \u0026lt; onCommands.Length; i++) { onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); } unDoCommand = new NoCommand(); } public void SetCommand(int slot, Command onCommand, Command offCommand) { onCommands[slot] = onCommand; offCommands[slot] = offCommand; } public void OnButtonPressed(int slot) { onCommands[slot].Execute(); unDoCommand = offCommands[slot]; } public void OffButtonPressed(int slot) { offCommands[slot].Execute(); unDoCommand = onCommands[slot]; } public void UndoButtonPressed() { unDoCommand.Undo(); } } class Program { static void Main(string[] args) { // 웨이트리스 RemoteControl remoteControl = new RemoteControl(); // 주방장 Door door = new Door(\u0026#34;\u0026#34;); // 주문서 DoorOpenCommand doorOpen = new DoorOpenCommand(door); DoorCloseCommand doorClose = new DoorCloseCommand(door); // 웨이트리스가 주문서를 받는다. remoteControl.SetCommand(0, doorOpen, doorClose); // ... // 주문서 실행 remoteControl.OnButtonPressed(0); // Door up remoteControl.UndoButtonPressed(); // Door down // ... } } 일반화 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // 커맨드 : 주문서 public interface ICommand { void Execute(); } // 간단한 커맨드 class SimpleCommand : ICommand { private string _payload = string.Empty; public SimpleCommand(string payload) { this._payload = payload; } public void Execute() { Console.WriteLine($\u0026#34;SimpleCommand: ({this._payload})\u0026#34;); } } // 리시버를 담은 커맨드 class ComplexCommand : ICommand { private Receiver _receiver; // 리시버의 메서드를 호출하기 위해 필요한 필드들 private string _a; private string _b; // 리시버를 받는다. public ComplexCommand(Receiver receiver, string a, string b) { this._receiver = receiver; this._a = a; this._b = b; } // 리시버의 메서드를 호출할 수 있다. public void Execute() { Console.WriteLine(\u0026#34;ComplexCommand: 리시버 호출로 동작한다.\u0026#34;); this._receiver.DoSomething(this._a); this._receiver.DoSomethingElse(this._b); } } // 리시버 : 주방장 // 중요한 비즈니스 로직을 갖고 있어서, 모든 요청사항들을 다룰 수 있다. class Receiver { public void DoSomething(string a) { Console.WriteLine($\u0026#34;Receiver: Working on ({a}.)\u0026#34;); } public void DoSomethingElse(string b) { Console.WriteLine($\u0026#34;Receiver: Also working on ({b}.)\u0026#34;); } } // 인보커 : 웨이트리스 class Invoker { private ICommand _onStart; private ICommand _onFinish; // 커맨드를 받는다. public void SetOnStart(ICommand command) { this._onStart = command; } public void SetOnFinish(ICommand command) { this._onFinish = command; } // 인보커는 구체화된 커맨드나 구체화된 리시버를 모른다. // 그냥 커멘드를 실행시킬 뿐이다. // 그러면 커맨드에 따라서 그 안에 있는 리시버가 적절히 동작한다. public void DoSomethingImportant() { if (this._onStart is ICommand) { this._onStart.Execute(); } if (this._onFinish is ICommand) { this._onFinish.Execute(); } } } class Program { static void Main(string[] args) { // The client code can parameterize an invoker with any commands. Invoker invoker = new Invoker(); Receiver receiver = new Receiver(); invoker.SetOnStart(new SimpleCommand(\u0026#34;Say Hi!\u0026#34;)); invoker.SetOnFinish(new ComplexCommand(receiver, \u0026#34;Send email\u0026#34;, \u0026#34;Save report\u0026#34;)); invoker.DoSomethingImportant(); // SimpleCommand: (Say Hi!) // Receiver: Working on (Send email.) // Receiver: Also working on (Save report.) } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-21T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-21/","title":"[Design Pattern] 행동 패턴 8. 커맨드 (Command)"},{"content":" 메멘토 (Memento) 객체의 구현 세부 사항을 공개하지 않으면서(캡슐화), 해당 객체의 이전 상태를 저장하고 복원할 수 있게 해준다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 // Originator class Originator { // 상태 private string _state; public Originator(string state) { this._state = state; } // 이 비즈니스 로직에서는 상태가 변할 수 있기 때문에 클라이언트는 상태를 따로 저장할 필요가 있다. public void DoSomething() { Console.WriteLine(\u0026#34;Originator: I\u0026#39;m doing something important.\u0026#34;); // 상태가 변한다. this._state = GenerateRandomString(30); } private string GenerateRandomString(int length = 10) { string allowedSymbols = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; string result = string.Empty; while (length \u0026gt; 0) { result += allowedSymbols[new Random().Next(0, allowedSymbols.Length)]; Thread.Sleep(12); length--; } return result; } // 현재 상태를 메멘토 안에다가 저장한다. public IMemento Save() { return new ConcreteMemento(this._state); } // 메멘토 안에 있는 상태를 다시 복원한다. public void Restore(IMemento memento) { if (!(memento is ConcreteMemento)) { throw new Exception(\u0026#34;Unknown memento class \u0026#34; + memento.ToString()); } this._state = memento.GetState(); } } // 메멘토 public interface IMemento { string GetName(); string GetState(); DateTime GetDate(); } class ConcreteMemento : IMemento { private string _state; private DateTime _date; public ConcreteMemento(string state) { this._state = state; this._date = DateTime.Now; } // Originator가 이 메서드를 사용해서 상태를 복원한다. public string GetState() { return this._state; } // Caretaker가 아래 메서드들을 사용해서 메타데이터를 출력한다. public string GetName() { return $\u0026#34;{this._date} / ({this._state.Substring(0, 9)})...\u0026#34;; } public DateTime GetDate() { return this._date; } } // Caretaker // Originator의 상태를 모른다. 구체화된 메멘토 클래스도 모른다. class Caretaker { private List\u0026lt;IMemento\u0026gt; _mementos = new List\u0026lt;IMemento\u0026gt;(); private Originator _originator = null; public Caretaker(Originator originator) { this._originator = originator; } // Originator의 상태를 저장한다. public void Backup() { this._mementos.Add(this._originator.Save()); } // Originator의 상태를 복원한다. public void Undo() { if (this._mementos.Count == 0) return; var memento = this._mementos.Last(); this._mementos.Remove(memento); try { this._originator.Restore(memento); } catch (Exception) { this.Undo(); } } public void ShowHistory() { foreach (var memento in this._mementos) { Console.WriteLine(memento.GetName()); } } } class Program { static void Main(string[] args) { Originator originator = new Originator(\u0026#34;Super-duper-super-puper-super.\u0026#34;); Caretaker caretaker = new Caretaker(originator); caretaker.Backup(); originator.DoSomething(); caretaker.Backup(); originator.DoSomething(); caretaker.Backup(); originator.DoSomething(); // 히스토리 caretaker.ShowHistory(); // 복원 caretaker.Undo(); caretaker.Undo(); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-20T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-20/","title":"[Design Pattern] 행동 패턴 8. 메멘토 (Memento)"},{"content":" 비지터 (Visitor) 객체의 구조(Component)와 처리(Visitor)를 분리한다. 객체 구조의 요소들 위에서 수행되어지는 연산을 표현한다. 특징 기존 구조를 변경하지 않고 기존 클래스 계층구조에 새로운 행동들을 추가할 수 있도록 한다. Visitor는 Component의 필드나 메서드를 사용할 수 있어야 하므로, 접근 권한을 더 많이 공개해야 할 수 있다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 // 컴포넌트 : 구조가 짜여져 있다. public interface IComponent { void Accept(IVisitor visitor); } public class ConcreteComponentA : IComponent { // 비지터를 받아들이고 // 비지터의 메서드A를 실행하게 한다. // 따라서 비지터는 컴포넌트A에 해당하는 동작을 처리한다. public void Accept(IVisitor visitor) { visitor.VisitConcreteComponentA(this); } // 베이스 클래스에 없는 메서드도 있다. // 하지만 비지터는 구체적인 컴포넌트를 알고 있으므로 이 메서드를 사용할 수 있다. public string ExclusiveMethodOfConcreteComponentA() { return \u0026#34;A\u0026#34;; } } public class ConcreteComponentB : IComponent { public void Accept(IVisitor visitor) { visitor.VisitConcreteComponentB(this); } public string SpecialMethodOfConcreteComponentB() { return \u0026#34;B\u0026#34;; } } // 비지터 : 컴포넌트를 방문해서 동작을 처리한다. // 구체적인 컴포넌트 클래스에 따라 동작한다. // 새로운 처리를 추가하고 싶다면, 새로운 방문자를 만들고, 컴포넌트에서 방문자를 받아들이게 하면 된다. public interface IVisitor { void VisitConcreteComponentA(ConcreteComponentA element); void VisitConcreteComponentB(ConcreteComponentB element); } class ConcreteVisitor1 : IVisitor { public void VisitConcreteComponentA(ConcreteComponentA element) { Console.WriteLine(\u0026#34;1-\u0026#34;); Console.WriteLine(element.ExclusiveMethodOfConcreteComponentA()); } public void VisitConcreteComponentB(ConcreteComponentB element) { Console.WriteLine(\u0026#34;1-\u0026#34;); Console.WriteLine(element.SpecialMethodOfConcreteComponentB()); } } class ConcreteVisitor2 : IVisitor { public void VisitConcreteComponentA(ConcreteComponentA element) { Console.WriteLine(\u0026#34;2-\u0026#34;); Console.WriteLine(element.ExclusiveMethodOfConcreteComponentA()); } public void VisitConcreteComponentB(ConcreteComponentB element) { Console.WriteLine(\u0026#34;2-\u0026#34;); Console.WriteLine(element.SpecialMethodOfConcreteComponentB()); } } public class Client { public static void ClientCode(List\u0026lt;IComponent\u0026gt; components, IVisitor visitor) { foreach (var component in components) { // 클라이언트는 구체적인 컴포넌트 클래스를 몰라도 된다. component.Accept(visitor); } } } class Program { static void Main(string[] args) { List\u0026lt;IComponent\u0026gt; components = new List\u0026lt;IComponent\u0026gt; { new ConcreteComponentA(), new ConcreteComponentB() }; var visitor1 = new ConcreteVisitor1(); var visitor2 = new ConcreteVisitor2(); // 똑같은 클라이언트 코드로 다양한 비지터를 사용할 수 있다. Client.ClientCode(components, visitor1); // 1-A, 1-B Client.ClientCode(components, visitor2); // 2-A, 2-B } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-19T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-19/","title":"[Design Pattern] 행동 패턴 7. 비지터 (Visitor)"},{"content":" 책임 연쇄 (Chain of responsibility) 주어진 요청을 처리하기 위해서 객체 사슬을 생성하고, 이 요청은 사슬을 따라 전달되면서 적절한 핸들러에 의해 처리되게 한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 // 핸들러는 핸들러들의 체인을 만든다. // 요청을 처리할 동작도 정의되어 있다. public interface IHandler { IHandler SetNext(IHandler handler); object Handle(object request); } abstract class AbstractHandler : IHandler { private IHandler _nextHandler; // 기본 메서드를 베이스 클래스에서 구현할 수 있다. public IHandler SetNext(IHandler handler) { this._nextHandler = handler; // 핸들러를 리턴한다. // 이렇게 함으로써 아래 코드처럼 핸들러들을 연결시킬 수 있다. // monkey.SetNext(squirrel).SetNext(dog); return handler; } public virtual object Handle(object request) { if (this._nextHandler != null) { return this._nextHandler.Handle(request); } else { return null; } } } class MonkeyHandler : AbstractHandler { public override object Handle(object request) { if ((request as string) == \u0026#34;Banana\u0026#34;) { return $\u0026#34;Monkey: I\u0026#39;ll eat the {request.ToString()}.\\n\u0026#34;; } else { return base.Handle(request); } } } class SquirrelHandler : AbstractHandler { public override object Handle(object request) { if (request.ToString() == \u0026#34;Nut\u0026#34;) { return $\u0026#34;Squirrel: I\u0026#39;ll eat the {request.ToString()}.\\n\u0026#34;; } else { return base.Handle(request); } } } class DogHandler : AbstractHandler { public override object Handle(object request) { if (request.ToString() == \u0026#34;MeatBall\u0026#34;) { return $\u0026#34;Dog: I\u0026#39;ll eat the {request.ToString()}.\\n\u0026#34;; } else { return base.Handle(request); } } } class Client { // 클라이언트는 한 개의 핸들러만 사용한다. 체인이 연결된지도 모른다. public static void ClientCode(AbstractHandler handler) { var list = new List\u0026lt;string\u0026gt; { \u0026#34;Nut\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cup of coffee\u0026#34; }; foreach (var food in list) { Console.WriteLine($\u0026#34;Client: Who wants a {food}?\u0026#34;); var result = handler.Handle(food); if (result != null) { Console.Write($\u0026#34; {result}\u0026#34;); } else { Console.WriteLine($\u0026#34; {food} was left untouched.\u0026#34;); } } } } class Program { static void Main(string[] args) { var monkey = new MonkeyHandler(); var squirrel = new SquirrelHandler(); var dog = new DogHandler(); // 체인 만들기 monkey.SetNext(squirrel).SetNext(dog); // Monkey -\u0026gt; Squirrel -\u0026gt; Dog Client.ClientCode(monkey); // Squirrel -\u0026gt; Dog Client.ClientCode(squirrel); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-18T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-18/","title":"[Design Pattern] 행동 패턴 6. 책임 연쇄 (Chain of responsibility)"},{"content":" 템플릿 메서드 (Template Method) 부모 클래스에서 알고리즘의 골격을 정의하고, 해당 알고리즘의 구조를 변경하지 않고 자식 클래스들이 알고리즘의 특정 단계들을 오버라이드​(재정의)​ 할 수 있도록 한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 // 추상 클래스 abstract class AbstractClass { // 알고리즘의 뼈대를 정의한다. public void TemplateMethod() { this.BaseOperation1(); this.RequiredOperations1(); this.BaseOperation2(); this.Hook1(); this.RequiredOperation2(); this.BaseOperation3(); this.Hook2(); } // 이 동작들은 이미 구현되어 있다. protected void BaseOperation1() { Console.WriteLine(\u0026#34;AbstractClass says: I am doing the bulk of the work\u0026#34;); } protected void BaseOperation2() { Console.WriteLine(\u0026#34;AbstractClass says: But I let subclasses override some operations\u0026#34;); } protected void BaseOperation3() { Console.WriteLine(\u0026#34;AbstractClass says: But I am doing the bulk of the work anyway\u0026#34;); } // 이 동작들은 자식 클래스에서 구현해야 한다. protected abstract void RequiredOperations1(); protected abstract void RequiredOperation2(); // 훅(Hook)은 아무것도 하지 않는 구상 메소드를 부모 클래스에 정의하고, // 자식 클래스에서 필요에 따라 재정의하여 사용하는 것이다. protected virtual void Hook1() { } protected virtual void Hook2() { } } // 자식 클래스들은 추상 클래스의 추상 메서드들을 오버라이드해서 구현한다. class ConcreteClass1 : AbstractClass { protected override void RequiredOperations1() { Console.WriteLine(\u0026#34;1-1\u0026#34;); } protected override void RequiredOperation2() { Console.WriteLine(\u0026#34;1-2\u0026#34;); } } class ConcreteClass2 : AbstractClass { protected override void RequiredOperations1() { Console.WriteLine(\u0026#34;2-1\u0026#34;); } protected override void RequiredOperation2() { Console.WriteLine(\u0026#34;2-2\u0026#34;); } protected override void Hook1() { Console.WriteLine(\u0026#34;2-Hook1\u0026#34;); } } class Client { // 클라이언트는 추상 클래스의 템플릿 메서드를 호출한다. public static void ClientCode(AbstractClass abstractClass) { // ... abstractClass.TemplateMethod(); // ... } } class Program { static void Main(string[] args) { Client.ClientCode(new ConcreteClass1()); // 1-1, 1-2 Client.ClientCode(new ConcreteClass2()); // 2-1, 2-2, 2-Hook1 } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-17T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-17/","title":"[Design Pattern] 행동 패턴 5. 템플릿 메서드 (Template Method)"},{"content":" 상태 (State) 객체 내부의 상태가 바뀌었을 때 객체가 행동을 바꾸도록 한다. 마치 객체가 자신의 클래스를 바꾸는 것처럼 보인다. 특징 기존 상태를 변경하지 않고 쉽게 새로운 상태를 추가할 수 있다. switch 문을 길게 작성하는 것보다 단순하다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 클라이언트가 원하는 것을 담고 있는 Context class Context { // 현재 State를 가지고 있다. private State _state = null; public Context(State state) { this.TransitionTo(state); } // 런타임에 State를 바꿀 수 있게 한다. public void TransitionTo(State state) { this._state = state; this._state.SetContext(this); } // 현재 State에 맞는 행동을 하도록 한다. public void Request1() { this._state.Handle1(); } public void Request2() { this._state.Handle2(); } } // State abstract class State { // State가 상태를 바꿀 수 있게 하기위해 Context를 가지고 있다. protected Context _context; public void SetContext(Context context) { this._context = context; } public abstract void Handle1(); public abstract void Handle2(); } class ConcreteStateA : State { public override void Handle1() { Console.WriteLine(\u0026#34;ConcreteStateA handles request1.\u0026#34;); Console.WriteLine(\u0026#34;ConcreteStateA wants to change the state of the context.\u0026#34;); this._context.TransitionTo(new ConcreteStateB()); } public override void Handle2() { Console.WriteLine(\u0026#34;ConcreteStateA handles request2.\u0026#34;); } } class ConcreteStateB : State { public override void Handle1() { Console.Write(\u0026#34;ConcreteStateB handles request1.\u0026#34;); } public override void Handle2() { Console.WriteLine(\u0026#34;ConcreteStateB handles request2.\u0026#34;); Console.WriteLine(\u0026#34;ConcreteStateB wants to change the state of the context.\u0026#34;); this._context.TransitionTo(new ConcreteStateA()); } } class Program { static void Main(string[] args) { var context = new Context(new ConcreteStateA()); context.Request1(); // State A에 따라 행동 -\u0026gt; State가 B로 바뀜 context.Request2(); // State B에 따라 행동 -\u0026gt; State가 A로 바뀜 } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-16T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-16/","title":"[Design Pattern] 행동 패턴 4. 상태 (State)"},{"content":" 전략 (Strategy) 바꿔 쓸 수 있는 행동을 캡슐화하고, 어떤 행동을 사용할지는 서브클래스에 맡긴다. 특징 클라이언트가 런타임에 손쉽게 행동(알고리즘)을 바꿔가면서 쓸 수 있게 해준다. 클라이언트는 각각의 Strategy가 어떤 전략인지를 알고 있어야 한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 // 클라이언트가 원하는 것을 담고 있는 Context class Context { // Strategy를 가지고 있다. // 구체적으로 어떤 행동을 할지는 모른다. private IStrategy _strategy; public Context() { } public Context(IStrategy strategy) { this._strategy = strategy; } // 런타임에 Strategy를 바꿀 수 있게 한다. public void SetStrategy(IStrategy strategy) { this._strategy = strategy; } // Strategy가 행동을 하도록 한다. public void DoSomeBusinessLogic() { var strs = new List\u0026lt;string\u0026gt;{ \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34; }; var result = this._strategy.DoAlgorithm(strs); string resultStr = string.Empty; foreach (var element in result as List\u0026lt;string\u0026gt;) { resultStr += element + \u0026#34;,\u0026#34;; } Console.WriteLine(resultStr); } } // 특정 행동을 하는 Strategy public interface IStrategy { object DoAlgorithm(object data); } class ConcreteStrategyA : IStrategy { public object DoAlgorithm(object data) { var list = data as List\u0026lt;string\u0026gt;; list.Sort(); return list; } } class ConcreteStrategyB : IStrategy { public object DoAlgorithm(object data) { var list = data as List\u0026lt;string\u0026gt;; list.Sort(); list.Reverse(); return list; } } class Program { static void Main(string[] args) { // 클라이언트는 자기가 원하는 행동을 알고, 그에 맞는 Strategy를 Context에 넘겨준다. var context = new Context(); context.SetStrategy(new ConcreteStrategyA()); context.DoSomeBusinessLogic(); // a,b,c,d,e context.SetStrategy(new ConcreteStrategyB()); context.DoSomeBusinessLogic(); // e,d,c,b,a } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-15T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-15/","title":"[Design Pattern] 행동 패턴 3. 전략 (Strategy)"},{"content":" 옵저버 (Observer) 객체 사이에 1 대 다 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때, 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지 받고, 자동으로 갱신될 수 있게 만든다. 특징 기존 코드를 변경하지 않고도 새로운 주체, 새로운 구독자를 추가할 수 있다. 런타임에 객체 간 관계를 설정할 수 있다. 구독자가 알림받는 순서는 보장되지 않는다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 // 주체 public interface ISubject { // 옵저버를 등록, 삭제하고, // 옵저버들에게 알려서 Update 할 수 있다. void Attach(IObserver observer); void Detach(IObserver observer); void Notify(); } public class Subject : ISubject { public int State { get; set; } = -0; private List\u0026lt;IObserver\u0026gt; _observers = new List\u0026lt;IObserver\u0026gt;(); public void Attach(IObserver observer) { this._observers.Add(observer); } public void Detach(IObserver observer) { this._observers.Remove(observer); } public void Notify() { foreach (var observer in _observers) { // 옵저버를 Update한다. observer.Update(this); } } public void SomeBusinessLogic() { this.State = new Random().Next(0, 10); Thread.Sleep(15); Console.WriteLine(\u0026#34;Subject: My state has just changed to: \u0026#34; + this.State); this.Notify(); } } // 옵저버 (구독자) public interface IObserver { void Update(ISubject subject); } class ConcreteObserverA : IObserver { public void Update(ISubject subject) { if ((subject as Subject).State \u0026lt; 3) { Console.WriteLine(\u0026#34;A가 반응한다.\u0026#34;); } } } class ConcreteObserverB : IObserver { public void Update(ISubject subject) { if ((subject as Subject).State == 0 || (subject as Subject).State \u0026gt;= 2) { Console.WriteLine(\u0026#34;B가 반응한다.\u0026#34;); } } } class Program { static void Main(string[] args) { var subject = new Subject(); var observerA = new ConcreteObserverA(); subject.Attach(observerA); var observerB = new ConcreteObserverB(); subject.Attach(observerB); // State == 2 -\u0026gt; A, B subject.SomeBusinessLogic(); // State == 1 -\u0026gt; A subject.SomeBusinessLogic(); // State == 2 -\u0026gt; A subject.Detach(observerB); subject.SomeBusinessLogic(); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-14T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-14/","title":"[Design Pattern] 행동 패턴 2. 옵저버 (Observer)"},{"content":" 중재자 (Mediator) 한 집합에 속해 있는 객체의 상호작용을 캡슐화하는 객체를 정의한다. 객체들이 직접 서로 참조하지 않도록 하여, 객체 사이의 느슨한 커플링(loose coupling) 을 촉진시키고 개발자가 객체의 상호작용을 독립적으로 다양화시킬 수 있게 만든다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // 중재자 public interface IMediator { void Notify(object sender, string ev); } class ConcreteMediator : IMediator { private Component1 _component1; private Component2 _component2; public ConcreteMediator(Component1 component1, Component2 component2) { this._component1 = component1; this._component1.SetMediator(this); this._component2 = component2; this._component2.SetMediator(this); } public void Notify(object sender, string ev) { if (ev == \u0026#34;A\u0026#34;) { Console.WriteLine(\u0026#34;A에 반응한다. 아래의 내용을 트리거한다.\u0026#34;); this._component2.DoC(); } if (ev == \u0026#34;D\u0026#34;) { Console.WriteLine(\u0026#34;D에 반응한다. 아래의 내용을 트리거한다.\u0026#34;); this._component1.DoB(); this._component2.DoC(); } } } // 컴포넌트들 class BaseComponent { protected IMediator _mediator; public BaseComponent(IMediator mediator = null) { this._mediator = mediator; } public void SetMediator(IMediator mediator) { this._mediator = mediator; } } class Component1 : BaseComponent { public void DoA() { Console.WriteLine(\u0026#34;A 수행\u0026#34;); this._mediator.Notify(this, \u0026#34;A\u0026#34;); } public void DoB() { Console.WriteLine(\u0026#34;B 수행\u0026#34;); this._mediator.Notify(this, \u0026#34;B\u0026#34;); } } class Component2 : BaseComponent { public void DoC() { Console.WriteLine(\u0026#34;C 수행\u0026#34;); this._mediator.Notify(this, \u0026#34;C\u0026#34;); } public void DoD() { Console.WriteLine(\u0026#34;D 수행\u0026#34;); this._mediator.Notify(this, \u0026#34;D\u0026#34;); } } class Program { static void Main(string[] args) { Component1 component1 = new Component1(); Component2 component2 = new Component2(); IMediator mediator = new ConcreteMediator(component1, component2); component1.SetMediator(mediator); component2.SetMediator(mediator); // A -\u0026gt; 중재자 반응 -\u0026gt; C component1.DoA(); // D -\u0026gt; 중재자 반응 -\u0026gt; B, C component2.DoD(); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-13T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-13/","title":"[Design Pattern] 행동 패턴 1. 중재자 (Mediator)"},{"content":" 플라이웨이트 (Flyweight) 많은 수의 잘게 쪼개진 객체를 효과적으로 사용하기 위해서 공유를 사용한다. 그렇게 함으로써 메모리 사용량을 줄일 수 있다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 public class Flyweight { // 플라이웨이트는 공유되는 상태를 가지고 있다. private Car _sharedState; public Flyweight(Car car) { this._sharedState = car; } public void Operation(Car uniqueState) { string s = JsonConvert.SerializeObject(this._sharedState); string u = JsonConvert.SerializeObject(uniqueState); Console.WriteLine($\u0026#34;Flyweight: Displaying shared {s} and unique {u} state.\u0026#34;); } } // 플라이웨이트를 관리하는 플라이웨이트 팩토리 public class FlyweightFactory { private List\u0026lt;Tuple\u0026lt;Flyweight, string\u0026gt;\u0026gt; flyweights = new List\u0026lt;Tuple\u0026lt;Flyweight, string\u0026gt;\u0026gt;(); public FlyweightFactory(params Car[] args) { foreach (var elem in args) { flyweights.Add(new Tuple\u0026lt;Flyweight, string\u0026gt;(new Flyweight(elem), this.getKey(elem))); } } // 플라이웨이트의 스트링 해시를 가져온다. private string getKey(Car key) { List\u0026lt;string\u0026gt; elements = new List\u0026lt;string\u0026gt;(); elements.Add(key.Model); elements.Add(key.Color); elements.Add(key.Company); if (key.Owner != null \u0026amp;\u0026amp; key.Number != null) { elements.Add(key.Number); elements.Add(key.Owner); } elements.Sort(); return string.Join(\u0026#34;_\u0026#34;, elements); } public Flyweight GetFlyweight(Car sharedState) { string key = this.getKey(sharedState); if (flyweights.Where(t =\u0026gt; t.Item2 == key).Count() == 0) { Console.WriteLine(\u0026#34;FlyweightFactory: Can\u0026#39;t find a flyweight, creating new one.\u0026#34;); // 해당 플라이웨이트가 없으므로 새로운 것을 추가한다. this.flyweights.Add(new Tuple\u0026lt;Flyweight, string\u0026gt;(new Flyweight(sharedState), key)); } else { // 해당 플라이웨이트가 있으면 기존의 것을 반환한다. Console.WriteLine(\u0026#34;FlyweightFactory: Reusing existing flyweight.\u0026#34;); } return this.flyweights.Where(t =\u0026gt; t.Item2 == key).FirstOrDefault().Item1; } public void ListFlyweights() { var count = flyweights.Count; Console.WriteLine($\u0026#34;\\nFlyweightFactory: I have {count} flyweights:\u0026#34;); foreach (var flyweight in flyweights) { Console.WriteLine(flyweight.Item2); } } } public class Car { public string Owner { get; set; } public string Number { get; set; } public string Company { get; set; } public string Model { get; set; } public string Color { get; set; } } class Program { static void Main(string[] args) { var factory = new FlyweightFactory( new Car { Company = \u0026#34;Chevrolet\u0026#34;, Model = \u0026#34;Camaro2018\u0026#34;, Color = \u0026#34;pink\u0026#34; }, new Car { Company = \u0026#34;Mercedes Benz\u0026#34;, Model = \u0026#34;C300\u0026#34;, Color = \u0026#34;black\u0026#34; }, new Car { Company = \u0026#34;Mercedes Benz\u0026#34;, Model = \u0026#34;C500\u0026#34;, Color = \u0026#34;red\u0026#34; }, new Car { Company = \u0026#34;BMW\u0026#34;, Model = \u0026#34;M5\u0026#34;, Color = \u0026#34;red\u0026#34; }, new Car { Company = \u0026#34;BMW\u0026#34;, Model = \u0026#34;X6\u0026#34;, Color = \u0026#34;white\u0026#34; } ); factory.ListFlyweights(); AddCarToPoliceDatabase(factory, new Car { Number = \u0026#34;CL234IR\u0026#34;, Owner = \u0026#34;James Doe\u0026#34;, Company = \u0026#34;BMW\u0026#34;, Model = \u0026#34;M5\u0026#34;, Color = \u0026#34;red\u0026#34; }); AddCarToPoliceDatabase(factory, new Car { Number = \u0026#34;CL234IR\u0026#34;, Owner = \u0026#34;James Doe\u0026#34;, Company = \u0026#34;BMW\u0026#34;, Model = \u0026#34;X1\u0026#34;, Color = \u0026#34;red\u0026#34; }); factory.ListFlyweights(); } // 새로운 Car를 추가한다. public static void AddCarToPoliceDatabase(FlyweightFactory factory, Car car) { Console.WriteLine(\u0026#34;\\nClient: Adding a car to database.\u0026#34;); var flyweight = factory.GetFlyweight(new Car { Color = car.Color, Model = car.Model, Company = car.Company }); flyweight.Operation(car); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 FlyweightFactory: I have 5 flyweights: Camaro2018_Chevrolet_pink black_C300_Mercedes Benz C500_Mercedes Benz_red BMW_M5_red BMW_white_X6 Client: Adding a car to database. FlyweightFactory: Reusing existing flyweight. Flyweight: Displaying shared {\u0026#34;Owner\u0026#34;:null,\u0026#34;Number\u0026#34;:null,\u0026#34;Company\u0026#34;:\u0026#34;BMW\u0026#34;,\u0026#34;Model\u0026#34;:\u0026#34;M5\u0026#34;,\u0026#34;Color\u0026#34;:\u0026#34;red\u0026#34;} and unique {\u0026#34;Owner\u0026#34;:\u0026#34;James Doe\u0026#34;,\u0026#34;Number\u0026#34;:\u0026#34;CL234IR\u0026#34;,\u0026#34;Company\u0026#34;:\u0026#34;BMW\u0026#34;,\u0026#34;Model\u0026#34;:\u0026#34;M5\u0026#34;,\u0026#34;Color\u0026#34;:\u0026#34;red\u0026#34;} state. Client: Adding a car to database. FlyweightFactory: Can\u0026#39;t find a flyweight, creating new one. Flyweight: Displaying shared {\u0026#34;Owner\u0026#34;:null,\u0026#34;Number\u0026#34;:null,\u0026#34;Company\u0026#34;:\u0026#34;BMW\u0026#34;,\u0026#34;Model\u0026#34;:\u0026#34;X1\u0026#34;,\u0026#34;Color\u0026#34;:\u0026#34;red\u0026#34;} and unique {\u0026#34;Owner\u0026#34;:\u0026#34;James Doe\u0026#34;,\u0026#34;Number\u0026#34;:\u0026#34;CL234IR\u0026#34;,\u0026#34;Company\u0026#34;:\u0026#34;BMW\u0026#34;,\u0026#34;Model\u0026#34;:\u0026#34;X1\u0026#34;,\u0026#34;Color\u0026#34;:\u0026#34;red\u0026#34;} state. FlyweightFactory: I have 6 flyweights: Camaro2018_Chevrolet_pink black_C300_Mercedes Benz C500_Mercedes Benz_red BMW_M5_red BMW_white_X6 BMW_red_X1 References https://refactoring.guru/ko/design-patterns ","date":"2022-08-12T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-12/","title":"[Design Pattern] 구조 패턴 7. 플라이웨이트 (Flyweight)"},{"content":" 컴포지트 (Composite) 부분과 전체를 나타내는 계층구조(트리)를 사용해서, 클라이언트가 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있게 한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 abstract class Component { public Component() { } public abstract string Operation(); public virtual void Add(Component component) { throw new NotImplementedException(); } public virtual void Remove(Component component) { throw new NotImplementedException(); } public virtual bool IsComposite() { return true; } } // 자식이 없는 단일 객체와 class Leaf : Component { public override string Operation() { return \u0026#34;Leaf\u0026#34;; } public override bool IsComposite() { return false; } } // 자식이 있는 복합 객체를 똑같은 방식으로 다룰 수 있다. class Composite : Component { protected List\u0026lt;Component\u0026gt; _children = new List\u0026lt;Component\u0026gt;(); public override void Add(Component component) { this._children.Add(component); } public override void Remove(Component component) { this._children.Remove(component); } // 재귀적으로 실행된다. public override string Operation() { int i = 0; string result = \u0026#34;Branch(\u0026#34;; foreach (Component component in this._children) { result += component.Operation(); if (i != this._children.Count - 1) { result += \u0026#34;+\u0026#34;; } i++; } return result + \u0026#34;)\u0026#34;; } } class Client { public void ClientCode(Component leaf) { Console.WriteLine($\u0026#34;RESULT: {leaf.Operation()}\\n\u0026#34;); } public void ClientCode2(Component component1, Component component2) { if (component1.IsComposite()) { component1.Add(component2); } Console.WriteLine($\u0026#34;RESULT: {component1.Operation()}\u0026#34;); } } class Program { static void Main(string[] args) { Client client = new Client(); // 단일 객체 다루기 Leaf leaf = new Leaf(); client.ClientCode(leaf); // 복합 객체 다루기 Composite tree = new Composite(); Composite branch1 = new Composite(); branch1.Add(new Leaf()); branch1.Add(new Leaf()); Composite branch2 = new Composite(); branch2.Add(new Leaf()); tree.Add(branch1); tree.Add(branch2); client.ClientCode(tree); client.ClientCode2(tree, leaf); } } 1 2 3 RESULT: Leaf RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)) RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf) References https://refactoring.guru/ko/design-patterns ","date":"2022-08-11T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-11/","title":"[Design Pattern] 구조 패턴 6. 컴포지트 (Composite) "},{"content":" 브리지 (Bridge) 구현 부분(플랫폼) 과 추상화 부분(인터페이스) 을 각각 독립적으로 분리 하여서 서로 영향을 주지 않고 내부적으로 확장할 수 있게 한다. 예를 들면, 추상화 부분이란 APP의 GUI라고 볼 수 있고, 구현 부분이란 OS의 API라고 볼 수 있다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // 추상화 부분 class Abstraction { protected IImplementation _implementation; public Abstraction(IImplementation implementation) { this._implementation = implementation; } public virtual string Operation() { return \u0026#34;Abstract: Base operation with:\\n\u0026#34; + _implementation.OperationImplementation(); } } // 구현 부분을 건드리지 않고 추상화 부분을 확장할 수 있다. class ExtendedAbstraction : Abstraction { public ExtendedAbstraction(IImplementation implementation) : base(implementation) { } public override string Operation() { return \u0026#34;ExtendedAbstraction: Extended operation with:\\n\u0026#34; + base._implementation.OperationImplementation(); } } // 구현 부분 public interface IImplementation { string OperationImplementation(); } class ConcreteImplementationA : IImplementation { public string OperationImplementation() { return \u0026#34;ConcreteImplementationA: The result in platform A.\\n\u0026#34;; } } class ConcreteImplementationB : IImplementation { public string OperationImplementation() { return \u0026#34;ConcreteImplementationA: The result in platform B.\\n\u0026#34;; } } class Client { // 클라이언트는 추상화 부분으로 접근할 수 있다. public void ClientCode(Abstraction abstraction) { Console.Write(abstraction.Operation()); } } class Program { static void Main(string[] args) { Client client = new Client(); Abstraction abstraction; // 구현 부분과 추상화 부분이 독립적으로 상호 교환될 수 있다. abstraction = new Abstraction(new ConcreteImplementationA()); client.ClientCode(abstraction); abstraction = new ExtendedAbstraction(new ConcreteImplementationB()); client.ClientCode(abstraction); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-10T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-10/","title":"[Design Pattern] 구조 패턴 5. 브리지 (Bridge) "},{"content":" 프록시 (Proxy) 다른 객체에 대한 접근을 제어(보호)하기 위한 대리자 역할을 수행한다. 하지만 Adapter와 달리 인터페이스를 변경하지는 않고 동일한 인터페이스를 제공한다. (책임은 없다) 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 프록시와 원래 객체는 둘 다 같은 인터페이스를 사용한다. public interface ISubject { void Request(); } // 원래 객체 class RealSubject : ISubject { public void Request() { Console.WriteLine(\u0026#34;RealSubject: Handling Request.\u0026#34;); } } // 프록시 class Proxy : ISubject { private RealSubject _realSubject; public Proxy(RealSubject realSubject) { this._realSubject = realSubject; } public void Request() { // 접근을 제어한다. if (this.CheckAccess()) { this._realSubject.Request(); this.LogAccess(); } } public bool CheckAccess() { Console.WriteLine(\u0026#34;Proxy: Checking access prior to firing a real request.\u0026#34;); return true; } public void LogAccess() { Console.WriteLine(\u0026#34;Proxy: Logging the time of request.\u0026#34;); } } public class Client { public void ClientCode(ISubject subject) { // ... subject.Request(); // ... } } class Program { static void Main(string[] args) { Client client = new Client(); // 원래 객체 RealSubject realSubject = new RealSubject(); client.ClientCode(realSubject); // 프록시 Proxy proxy = new Proxy(realSubject); client.ClientCode(proxy); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-09T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-09/","title":"[Design Pattern] 구조 패턴 4. 프록시 (Proxy) "},{"content":" 퍼사드 (Facade) 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공한다. 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의하는 것이다. 특징 복잡한 하위 시스템에 단순화된 인터페이스를 제공한다. 모든 클래스에 결합된 전지전능한 객체가 될 수 있다는 위험성이 있다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class Facade { protected Subsystem1 _subsystem1; protected Subsystem2 _subsystem2; public Facade(Subsystem1 subsystem1, Subsystem2 subsystem2) { this._subsystem1 = subsystem1; this._subsystem2 = subsystem2; } public string Operation() { string result = \u0026#34;Facade initializes subsystems:\\n\u0026#34;; result += this._subsystem1.operation1(); result += this._subsystem2.operation1(); result += \u0026#34;Facade orders subsystems to perform the action:\\n\u0026#34;; result += this._subsystem1.operationN(); result += this._subsystem2.operationZ(); return result; } } // 서브 시스템들 public class Subsystem1 { public string operation1() { return \u0026#34;Subsystem1: Ready!\\n\u0026#34;; } public string operationN() { return \u0026#34;Subsystem1: Go!\\n\u0026#34;; } } public class Subsystem2 { public string operation1() { return \u0026#34;Subsystem2: Get ready!\\n\u0026#34;; } public string operationZ() { return \u0026#34;Subsystem2: Fire!\\n\u0026#34;; } } class Client { public static void ClientCode(Facade facade) { Console.Write(facade.Operation()); } } class Program { static void Main(string[] args) { Subsystem1 subsystem1 = new Subsystem1(); Subsystem2 subsystem2 = new Subsystem2(); Facade facade = new Facade(subsystem1, subsystem2); // 클라이언트는 퍼사드만 알면 서브시스템을 손쉽게 사용할 수 있다. Client.ClientCode(facade); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-08T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-08/","title":"[Design Pattern] 구조 패턴 3. 퍼사드 (Facade)"},{"content":" 어댑터 (Adapter) 클래스의 인터페이스를 다른 인터페이스로 변환해서 호환시켜준다. 특징 오래된 코드나 서드파티 코드를 수정 없이 조정할 수 있다. 하지만 지속적인 레거시 코드를 사용한다는 장기적인 문제가 있을 수 있다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 이 인터페이스의 GetRequest()를 호출해서 public interface ITarget { string GetRequest(); } // 이 클래스를 사용하고 싶다면? class Adaptee { public string GetSpecificRequest() { return \u0026#34;Specific request.\u0026#34;; } } // 어댑터를 만든다. class Adapter : ITarget { private readonly Adaptee _adaptee; public Adapter(Adaptee adaptee) { this._adaptee = adaptee; } public string GetRequest() { return this._adaptee.GetSpecificRequest(); } } class Program { static void Main(string[] args) { Adaptee adaptee = new Adaptee(); // 어댑터를 사용해서 어댑티를 ITarget 인터페이스로 호환시킨다. ITarget target = new Adapter(adaptee); Console.WriteLine(target.GetRequest()); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-07T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-07/","title":"[Design Pattern] 구조 패턴 2. 어댑터 (Adapter)"},{"content":" 데코레이터 (Decorator) 동적으로 런타임에 객체에 추가적인 책임을 부여한다. 특징 기능을 확장하기 위한 서브 클래싱의 대안이다. 정적으로 기능을 늘릴 수 있는 상속과 달리, 데코레이터 패턴은 런타임에 객체의 행동이 확장되게 돕는다. 문제점 : 무지막지하게 늘어나는 서브 클래스 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public abstract class Beverage { public abstract string GetDesc(); } public class Espresso : Beverage { public override string GetDesc() { return \u0026#34;샷 추가\u0026#34;; } } public class ChocolateCoffee : Beverage { public override string GetDesc() { return \u0026#34;초코 파우더 추가\u0026#34;; } } public class WhippedCreamChocolateCoffee : Beverage { public override string GetDesc() { return \u0026#34;휘핑과 초코파우더 추가\u0026#34;; } } // ... 계속 이렇게 만들다가는 엄청난 서브 클래스들이 생긴다. // 음식의 옵션 별로 따로 두면 좋지 않을까? 해결 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 똑같이 Beverage를 상속하는 데코레이터를 만든다. public abstract class BeverageDecorator : Beverage { Beverage beverage; public BeverageDecorator(Beverage b) { beverage = b; } public override string GetDesc() { return beverage.GetDesc(); } } public class Whip : BeverageDecorator { public Whip(Beverage b) : base(b) {} public override string GetDesc() { return base.GetDesc() + \u0026#34;, 휘핑 추가\u0026#34;; } } public class Choco : BeverageDecorator { public Choco(Beverage b) : base(b) {} public override string GetDesc() { return base.GetDesc() + \u0026#34;, 초코 추가\u0026#34;; } } class Program { static void Main(string[] args) { Beverage b = new Espresso(); // 책임을 동적으로 추가할 수 있다. b = new Choco(b); b = new Choco(b); b = new Whip(b); Console.WriteLine(b.GetDesc()); // 샷 추가, 초코 추가, 초코 추가, 휘핑 추가 } } 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 public abstract class Component { public abstract string Operation(); } // 컴포넌트를 상속하는 구체화된 컴포넌트 class ConcreteComponent : Component { public override string Operation() { return \u0026#34;ConcreteComponent\u0026#34;; } } // 컴포넌트를 상속하는 데코레이터 abstract class Decorator : Component { // 컴포넌트를 가지고 있다. protected Component _component; public Decorator(Component component) { this._component = component; } public void SetComponent(Component component) { this._component = component; } public override string Operation() { if (this._component != null) { return this._component.Operation(); } else { return string.Empty; } } } // 구체화된 데코레이터 A class ConcreteDecoratorA : Decorator { public ConcreteDecoratorA(Component comp) : base(comp) { } public override string Operation() { return $\u0026#34;ConcreteDecoratorA({base.Operation()})\u0026#34;; } } // 구체화된 데코레이터 B class ConcreteDecoratorB : Decorator { public ConcreteDecoratorB(Component comp) : base(comp) { } public override string Operation() { return $\u0026#34;ConcreteDecoratorB({base.Operation()})\u0026#34;; } } public class Client { public void ClientCode(Component component) { Console.WriteLine(component.Operation()); } } class Program { static void Main(string[] args) { Client client = new Client(); var simple = new ConcreteComponent(); client.ClientCode(simple); // ConcreteComponent // 데코레이터로 책임을 추가할 수 있다. ConcreteDecoratorA decorator1 = new ConcreteDecoratorA(simple); ConcreteDecoratorB decorator2 = new ConcreteDecoratorB(decorator1); client.ClientCode(decorator2); // ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent)) } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-06T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-06/","title":"[Design Pattern] 구조 패턴 1. 데코레이터 (Decorator)"},{"content":" 프로토타입 (Prototype) 기존 인스턴스를 복제하여 새로운 인스턴스를 만드는 방법이다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public class Person { public int Age; public DateTime BirthDate; public string Name; public IdInfo IdInfo; // 얕은 복사 // string과 IdInfo가 제대로 복사되지 않는다. public Person ShallowCopy() { return (Person) this.MemberwiseClone(); } public Person DeepCopy() { Person clone = (Person) this.MemberwiseClone(); // 깊은 복사 clone.Name = String.Copy(Name); clone.IdInfo = new IdInfo(IdInfo.IdNumber); return clone; } } public class IdInfo { public int IdNumber; public IdInfo(int idNumber) { this.IdNumber = idNumber; } } class Program { static void Main(string[] args) { Person p1 = new Person(); p1.Age = 42; p1.BirthDate = Convert.ToDateTime(\u0026#34;1977-01-01\u0026#34;); p1.Name = \u0026#34;Jack Daniels\u0026#34;; p1.IdInfo = new IdInfo(666); Person p2 = p1.ShallowCopy(); // 얕은 복사 Person p3 = p1.DeepCopy(); // 깊은 복사 // p1이 변경됨 p1.Age = 32; p1.BirthDate = Convert.ToDateTime(\u0026#34;1900-01-01\u0026#34;); p1.Name = \u0026#34;Frank\u0026#34;; p1.IdInfo.IdNumber = 7878; // 결과 DisplayValues(p1); DisplayValues(p2); // IdInfo의 값이 p1과 동일하게 변경됨 DisplayValues(p3); } public static void DisplayValues(Person p) { Console.WriteLine(\u0026#34;Name: {0:s}, Age: {1:d}, BirthDate: {2:MM/dd/yy}, ID#: {0:d}\u0026#34;, p.Name, p.Age, p.BirthDate, p.IdInfo.IdNumber); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-05T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-05/","title":"[Design Pattern] 행동 패턴 5. 프로토타입 (Prototype)"},{"content":" 빌더 (Builder) 객체를 생성하는 클래스와 표현(조립) 하는 클래스를 분리해서, 동일한 절차를 거치더라도 서로 다른 표현(조립된 완성품) 을 생성하는 방법을 제공한다. 문제점 : 너무 많은 인자를 넘겨야 하는 생성자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Moster { string name; int age; int power; int speed; // ... 많은 수의 필드들 // 엄청나게 늘어날 가능성이 있는 생성자 인자의 수... public Moster(string n, int a, int p, int s) {} } class Program { static void Main(string[] args) { Monster m = new Monster(\u0026#34;ScaryFireMonster\u0026#34;, 11, 99, 500); } } 해결 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public interface IMonsterBuilder { // 각각의 요소를 독립적으로 조립할 수 있게 한다. // 이렇게 저렇게 조립한 다양한 결과물들을 만들 수 있다. void BuildName(string n); void BuildAge(int a); void BuildFire(Fire f); void BuildIce(Ice i); } public class ScaryMosterBuilder : IMonsterBuilder { Monster monster; public void BuildName(string n) { monster.Name = n; } public void BuildAge(int a) { monster.Age = a; } public void BuildFire(Fire f) { monster.fire = f; } public void BuildIce(Ice i) { monster.ice = i; } public Monster GetMonster() { return monster; } } public class Director { IBuilder builder; public void SetBuilder(IBuilder b) { builder = b; } public void BuildScaryFireMonster() { // 객체를 생성하는 부분이 이곳에 마련되어 있다. // 수많은 인자를 넘겨야 하는 생성자가 없다. // 필요한 것들만 Build 해준다. builder.BuildName(\u0026#34;ScaryFireMonster\u0026#34;); builder.BuildAge(13); builder.BuildFire(new Fire()); } public void BuildScaryIceMonster() { builder.BuildName(\u0026#34;ScaryIceMonster\u0026#34;); builder.BuildAge(15); builder.BuildIce(new Ice()); } } class Program { static void Main(string[] args) { var builder = new ScaryMosterBuilder(); var director = new Director(); director.SetBuilder(builder); director.BuildScaryFireMonster(); Monster m = builder.GetMonster(); } } 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 // 빌더 public interface IBuilder { // 객체를 표현(조립)한다. // 나중에 여러가지를 덧붙일 수 있겠다. void BuildPartA(); void BuildPartB(); void BuildPartC(); } public class ConcreteBuilder : IBuilder { private Product _product = new Product(); public ConcreteBuilder() { this.Reset(); } public void Reset() { this._product = new Product(); } public void BuildPartA() { this._product.Add(\u0026#34;PartA1\u0026#34;); } public void BuildPartB() { this._product.Add(\u0026#34;PartB1\u0026#34;); } public void BuildPartC() { this._product.Add(\u0026#34;PartC1\u0026#34;); } public Product GetProduct() { Product result = this._product; this.Reset(); return result; } } // 제품 public class Product { private List\u0026lt;object\u0026gt; _parts = new List\u0026lt;object\u0026gt;(); public void Add(string part) { _parts.Add(part); } public string ListParts() { string str = string.Empty; for (int i = 0; i \u0026lt; this._parts.Count; i++) str += _parts[i] + \u0026#34;, \u0026#34;; str = str.Remove(str.Length - 2); return \u0026#34;Product parts: \u0026#34; + str + \u0026#34;\\n\u0026#34;; } } // 디렉터 public class Director { private IBuilder _builder; public IBuilder Builder { set { _builder = value; } } // 객체를 생성한다. public void BuildMinimalViableProduct() { this._builder.BuildPartA(); } public void BuildFullFeaturedProduct() { this._builder.BuildPartA(); this._builder.BuildPartB(); this._builder.BuildPartC(); } } class Program { static void Main(string[] args) { var director = new Director(); var builder = new ConcreteBuilder(); director.Builder = builder; director.BuildMinimalViableProduct(); Console.WriteLine(builder.GetProduct().ListParts()); director.BuildFullFeaturedProduct(); Console.WriteLine(builder.GetProduct().ListParts()); // without a Director builder.BuildPartA(); builder.BuildPartC(); Console.Write(builder.GetProduct().ListParts()); } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-04T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-04/","title":"[Design Pattern] 행동 패턴 4. 빌더 (Builder)"},{"content":" 추상 팩토리 (Abstract Factory) 구체적인 클래스를 몰라도 일련의 객체군을 만들 수 있는 인터페이스를 제공한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // 추상 팩토리 public interface IAbstractFactory { IProductA CreateProductA(); // 어떤 클래스의 인스턴스를 만들지는 IProductB CreateProductB(); } // 구체화된 팩토리1 class ConcreteFactory1 : IAbstractFactory { // 이 팩토리에 맞는 객체군들을 만들 수 있다. public IProductA CreateProductA() { // 서브 클래스에서 결정한다. (팩토리 메서드) return new ConcreteProductA1(); } public IProductB CreateProductB() { return new ConcreteProductB1(); } } // 구체화된 팩토리2 class ConcreteFactory2 : IAbstractFactory { public IProductA CreateProductA() { return new ConcreteProductA2(); } public IProductB CreateProductB() { return new ConcreteProductB2(); } } // 제품 A public interface IProductA { string UsefulFunctionA(); } class ConcreteProductA1 : IProductA { public string UsefulFunctionA() { return \u0026#34;A1\u0026#34;; } } class ConcreteProductA2 : IProductA { public string UsefulFunctionA() { return \u0026#34;A2\u0026#34;; } } // 제품 B public interface IProductB { string UsefulFunctionB(); string AnotherUsefulFunctionB(IProductA collaborator); } class ConcreteProductB1 : IProductB { public string UsefulFunctionB() { return \u0026#34;B1\u0026#34;; } public string AnotherUsefulFunctionB(IProductA collaborator) { var result = collaborator.UsefulFunctionA(); return $\u0026#34;B1 collaborating with the ({result})\u0026#34;; } } class ConcreteProductB2 : IProductB { public string UsefulFunctionB() { return \u0026#34;B2\u0026#34;; } public string AnotherUsefulFunctionB(IAbstractProductA collaborator) { var result = collaborator.UsefulFunctionA(); return $\u0026#34;B2 collaborating with the ({result})\u0026#34;; } } // 클라이언트 class Program { static void Main(string[] args) { // factory에 따라 IAbstractFactory factory = new ConcreteFactory1(); // 알아서 알맞은 객체군을 만든다. var productA = factory.CreateProductA(); var productB = factory.CreateProductB(); Console.WriteLine(productB.UsefulFunctionB()); // B1 Console.WriteLine(productB.AnotherUsefulFunctionB(productA)); // B1 with A1 } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-03T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-03/","title":"[Design Pattern] 행동 패턴 3. 추상 팩토리 (Abstract Factory)"},{"content":" 팩토리 메서드 (Factory Method) 객체를 만들 수 있는 인터페이스를 제공한다. 어떤 클래스의 객체를 만들지는 서브 클래스들이 결정한다. 개념적인 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 abstract class Creator { // 팩토리 메서드 // 새로운 무언가를 만들고 싶다면 이것을 오버라이드하기만 하면 된다. (확장성) public abstract IProduct FactoryMethod(); public string SomeOperation() { var product = FactoryMethod(); var result = product.Operation(); return result; } } class ConcreteCreator1 : Creator { public override IProduct FactoryMethod() { // 서브 클래스가 어떤 클래스의 객체를 만들지 결정한다. return new ConcreteProduct1(); } } class ConcreteCreator2 : Creator { public override IProduct FactoryMethod() { return new ConcreteProduct2(); } } // 제품 public interface IProduct { string Operation(); } // 제품 1 class ConcreteProduct1 : IProduct { public string Operation() { return \u0026#34;ConcreteProduct1\u0026#34;; } } // 제품 2 class ConcreteProduct2 : IProduct { public string Operation() { return \u0026#34;ConcreteProduct2\u0026#34;; } } class Program { static void Main(string[] args) { Creator creator = new ConcreteCreator1(); Console.WriteLine(creator.SomeOperation()); // ConcreteProduct1 } } References https://refactoring.guru/ko/design-patterns ","date":"2022-08-02T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-02/","title":"[Design Pattern] 행동 패턴 2. 팩토리 메서드 (Factory Method)"},{"content":" 싱글톤 (Singleton) 객체의 인스턴스가 오직 한 개만 생성되는 패턴이다. 한 개의 인스턴스에 대한 전역적인 접근점을 제공한다. 특징 전역적인 접근점을 제공하기 때문에 데이터를 공유하기 쉽다. 공유 자원에 동시 접근을 제한하기 위해 사용할 수 있다. 오직 하나의 인스턴스만 생성하기 때문에 메모리 낭비를 방지할 수 있다. 단일 책임 원칙 위반 : 한 번에 두 가지의 문제를 동시에 해결한다. 동기화 문제 해결방안 고전적인 싱글톤 구현 방법 1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { static Singleton instance = null; Singleton() { } public static Singleton GetInstance() { if (instance == null) instance = new Singleton(); // 게으른 초기화 return instance; } } 문제점 멀티 스레드 환경에서 동기화처리를 안 하면 문제가 발생할 수 있다. 두 개 이상의 스레드가 인스턴스를 획득하기 위해서 GetInstance() 메서드에 진입해서 경합을 벌이는 과정에서 서로 다른 두 개의 인스턴스가 만들어질 수 있다. 인스턴스를 처음부터 만들어버린다. 1 2 3 4 5 6 7 8 9 10 11 12 public class SingletonEarly { // 이른 초기화. 인스턴스를 처음부터 만들어 버린다. static SingletonEarly instance = new SingletonEarly(); SingletonEarly() { } public static SingletonEarly GetInstance() { return instance; } } 단점: 인스턴스를 미리 만들어버리면 그 인스턴스가 자원을 많이 차지하는 경우에는 시스템 리소스가 쓸데없이 낭비될 가능성이 있다. DCL (Double-Checking Locking)을 사용해서 동기화 한다. Lock을 사용하는 방법. 매번 동기화하지 않고, 인스턴스가 생성되지 않았을 때만 동기화하여 속도를 높인다. 동기화 후, 다시 한 번 인스턴스가 생성되었는지 확인하고 null이라면 인스턴스를 생성한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class SingletonDCL { // volatile 키워드: // instance 변수에 대한 액세스는 모두 캐시되지 않으며, 메모리에 있는 값을 직접 액세스한다. // 다른 스레드로 인해 값이 변경되지만 컴파일러가 이를 인식하지 못할 수 있기 때문에 volatile 키워드를 사용한다. static volatile SingletonDCL instance = null; static readonly object _lock = new object(); SingletonDCL() { } public static SingletonDCL GetInstance() { if (instance == null) // instance가 생성되지 않았을 때만 동기화한다. { lock (_lock) // _lock이 다른 스레드에서 사용 중이면 사용이 끝날 때까지 기다린다. { if (instance == null) instance = new SingletonDCL(); // 다시 한번 null 인지 확인한다. } } return instance; } } Lazy를 사용하는 방법. Lazy\u0026lt;T\u0026gt;는 선언할 때 인스턴스가 생성되지 않고, 접근하려고 할 때 생성한다. 내부적으로 DCL 패턴을 사용 하고 있기 때문에 멀티 스레딩에 안전하다. 1 2 3 4 5 6 7 8 9 10 11 12 public class SingletonLazy { // Lazy\u0026lt;T\u0026gt;는 사용하기 전까지는 인스턴스를 미리 생성하지 않는다. 멀티 스레드에서도 안전하다. static readonly Lazy\u0026lt;SingletonLazy\u0026gt; instance = new Lazy\u0026lt;SingletonLazy\u0026gt;(() =\u0026gt; new SingletonLazy()); SingletonLazy() { } public static SingletonLazy GetInstance() { return instance.Value; } } with Unity 싱글톤을 제네릭 클래스로 만든 후, 상속해서 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 using UnityEngine; public class Singleton\u0026lt;T\u0026gt; : MonoBehaviour where T : Component { private static T _instance; public static T Instance { get { if (_instance == null) { _instance = FindObjectOfType\u0026lt;T\u0026gt;(); if (_instance == null) { GameObject obj = new GameObject(); obj.name = typeof(T).Name; _instance = obj.AddComponent\u0026lt;T\u0026gt;(); } } return _instance; } } public virtual void Awake() { if (_instance == null) { _instance = this as T; DontDestroyOnLoad(gameObject); } else { Destroy(gameObject); } } } ","date":"2022-08-01T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/design-pattern-01/","title":"[Design Pattern] 행동 패턴 1. 싱글톤 (Singleton)"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n디스크의 구조 논리블록(logical block) 디스크의 단위 정보 저장 공간이다. 1차원 배열처럼 취급한다. 논리블록 단위로 저장, 전송된다. 섹터(sector) 디스크 내에서 논리블록이 저장되는 물리적인 위치이다. 섹터가 0이면 최외곽 실린더의 첫 번째 트랙에 있는 첫 번째 섹터이다. 디스크 관리 (1) physical-formatting (low-level formatting) 디스크를 컨트롤러가 읽고 쓸수 있도록 섹터들로 나누는 과정이다. 각 섹터는 header + 실제 data(보통 512bytes) + trailer로 구성된다. header와 trailer는 sector number, ECC(error-collecting code)등의 정보가 저장되며, 컨트롤러가 직접 접근 및 운영한다. (2) partitioning 디스크를 하나 이상의 실린더 그룹으로 나누는 과정이다. 운영체제는 이것을 독립적인 디스크(logical disk)로 취급한다. (3) logical-formatting 파일시스템을 만드는 것이다. FAT, inode, free space 등의 구조가 포함된다. (4) booting ROM에 저장되어 있는 small bootstrap loader를 실행하는 것이다. 실행하면, full bootstrap loader program이 있는 섹터 0을 로드해서 실행한다. 그러면, 운영체제의 커널을 찾아서 그것을 로드해서 실행한다. 디스크 스케줄링 디스크 접근 시간(access time) 탐색시간(seek time) 헤드를 해당 실린더로 움직이는데 걸리는 시간 회전지연시간(rotational latency) 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간 전송시간(transfer time) 해당 섹터가 헤드에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간 회전지연시간, 전송시간은 상대적인 수치가 작을 뿐 아니라 운영체제가 통제하기 힘든 부분이다. 따라서 운영체제는 탐색시간을 줄이기 위해 헤드의 움직임을 최소화하는 스케줄링 작업을 한다. 그렇다면 여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떤 순서로 처리할 것인가? (1) FCFS(First Come First Served) 스케줄링 디스크에 먼저 들어온 요청을 먼저 처리한다. (2) SSTF(Shortest Seek Time First) 스케줄링 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 먼저 처리한다. 기아 현상(starvation) 을 발생시킬 수 있다. 헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야한다. (3) SCAN 알고리즘 헤드가 정해진 방향으로 이동하면서 길목에 있는 요청들을 처리하며 지나간다. 엘리베이터 스케줄링 알고리즘(elevator scheduling algorithm)이라고도 부른다. 탐색시간의 편차가 있다. 제일 안쪽, 바깥쪽에 비해서 가운데 위치가 기다리는 평균시간이 더 짧다. (4) C-SCAN(Circular-SCAN) 알고리즘 헤드가 정해진 방향으로 이동하면서 길목에 있는 요청들을 처리하는 것은 SCAN과 똑같지만, 끝에 도달하면 요청을 처리하지 않고 출발점으로 이동만 하는 방식이다. 이동거리는 길어지지만, 탐색시간의 편차를 줄이기 위함이다. (5) LOOK과 C-LOOK 알고리즘 헤드가 한쪽 방향으로 이동하다가, 더 이상 그 방향에 대기 중인 요청이 없으면 헤드 진행 방향을 바꾸는 방식이다. 다중 디스크 환경에서의 스케줄링 다중 디스크 환경에서의 스케줄링은 그 목표에 따라 결정이 달라진다. 탐색시간 줄이기 헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크를 선택한다. 디스크 간의 부하균형(load balancing) 모든 디스크에 요청이 골고루 분배되도록 스케줄링한다. 전력소모 줄이기 일부 디스크에 요청을 집중시키고 나머지 디스크는 회전을 정지시킨다. 스왑 영역 관리 디스크를 사용하는 두 가지 이유 (1) 메모리의 휘발성 → 파일 시스템 (2) 메모리의 공간 부족 → 스왑 영역 스왑 영역 가상 메모리 시스템에서 디스크를 메모리의 연장 공간으로 사용한다. 파일 시스템과 별도의 파티션을 사용하는 것이 일반적이다. 일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조되므로, 공간 효율성보다는 속도 효율성이 우선시 된다. 따라서, 블록의 크기 및 저장 방식이 일반 파일 시스템과 다르다. RAID RAID(Redundant Array of Independent Disks) 디스크 여러개를 묶어서 함께 사용하는 것이다. RAID의 사용 목적 디스크 처리 속도 향상 여러 디스크에 블록의 내용을 분산 저장한다. 그리고 병렬적으로 읽는다. (interleaving, striping) 신뢰성(reliability) 향상 동일한 정보를 디스크에 중복 저장한다. 하나의 디스크가 고장나도 다른 디스크에서 읽어올 수 있다. (mirroring, shadowing) 단순한 중복 저장이 아니라, 일부 디스크에 parity를 저장해서 공간 효율성을 높일 수도 있다. ","date":"2022-07-27T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-12/","title":"[OS] Chapter 12. 디스크 관리"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n파일과 파일 시스템 File A named collection of related information 일반적으로 비휘발성의 보조기억장치에 저장된다. 운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 관리한다. Operation create, read, write, reposition(lseek), delete, open, close 등 File attribute (혹은 파일의 metadata) 파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들이다. 파일 이름, 유형, 저장된 위치, 파일 사이즈 접근 권한(읽기/쓰기/실행), 시간(생성/변경/사용), 소유자 등 File system 운영체제에서 파일을 관리하는 부분이다. 파일, 파일의 메타데이터, 디렉터리 등의 정보를 관리한다. 파일의 저장방법을 결정한다. 파일을 보호한다. Directory 해당 디렉터리에 속한 파일의 이름, 메타데이터 등의 정보를 가지는 파일이다. 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일이다. Operation search for a file, create a file, delete a file list a dictionary, rename a file, traverse the file system Partition(= Logical Disk) 하나의 디스크 안에 여러개의 파티션을 둘 수도 있고, 여러개의 디스크를 하나의 파티션으로 둘 수도 있다. 물리적인 디스크를 파티션으로 구성한 뒤에, 각각의 파티션에 파일 시스템을 깔거나 swapping 등의 다른 용도로 사용할 수 있다. open(a/b/c) 디스크로부터 파일 c의 메타데이터를 메모리로 가지고 오기 위해서 디렉터리 경로를 search 한다. 루트 디렉터리 /를 open하고, 그 안에서 파일 a의 위치 획득 파일 a를 read하고, 그 안에서 파일 b의 위치 획득 파일 b를 read하고, 그 안에서 파일 c의 위치 획득 파일 c를 open한다. 디렉터리 search에 너무 많은 시간이 소요되기 때문에 open을 read, write와 따로둔다. 그래서 한번 open한 파일은 read/write할 때 디렉터리 search가 불필요하다. 파일 보호 각 파일들에 대해 누구에게 어떤 유형의 접근(read/write/execution)을 허락할 것인가? 접근 제어 방법 Access control Matrix Access control list 파일별로 누구에게 어떤 접근 권한이 있는지 표시한다. Capability 사용자별로 자신이 접근 권한을 가진 파일, 해당 권한을 표시한다. Grouping 전체 사용자를 owner, group, public으로 구분하고 각 파일에 대해 각각의 그룹에 대한 접근 권한(rwx)을 3비트씩 표시한다. UNIX 예시: rwxr--r-- Password 파일마다 password를 두는 방법이다. 모든 접근 권한에 대해 하나의 password를 두기: all-or-nothing 접근 권한별로 password를 두기: 암기 문제, 관리 문제 파일 시스템 마운팅 File system Mounting 특정 파티션에 있는 파일 시스템의 특정 디텍터리에, 다른 파티션의 파일 시스템을 마운트하는 것이다. 서로 다른 파일 시스템에 접근할 수 있게 된다. 파일 접근 방법 순차 접근(sequential access) 카세프 테이프를 사용하는 것처럼 접근하는 방식이다. 읽거나 쓰면, offset이 자동으로 증가한다. a → b → c 직접 접근, 임의 접근(direct access, random access) LP 레코드 판과 같이 접근하는 방식이다. 파일을 구성하는 레코드를 임의의 순서로 접근할 수 있다. a → c 디스크에 파일 정보를 저장하는 방법 (1) Contiguous Allocation 디스크의 연속적인 블럭에 파일을 저장하는 방법이다. 장점 빠른 I/O가 가능하다. 한번의 디스크 seek/rotation으로 많은 바이트를 transfer할 수 있다. 직접 접근(랜덤 접근)이 가능하다. 단점 비어있는 블럭이 있어도 연속되는 블럭이 충분치 않으면 저장할 수 없다. (외부 조각) 파일의 크기를 늘리는데(File grow) 제약이 있다. 파일 생성 시에 얼마나 큰 hole을 할당할 것인가? grow 가능 vs 낭비(내부 조각) (2) Linked Allocation 파일을 불연속적으로 저장하고 pointer로 연결하는 방법이다. 장점 외부조각이 발생하지 않는다. 단점 직접 접근이 불가능하다. 신뢰성(Reliability)문제. 하나의 섹터가 고장나면 연결된 다른 섹터에 접근할 수 없게된다. 다음 위치를 가리키는 pointer의 저장공간이 필요하기 때문에 공간의 효율성이 떨어진다. 512bytes/sector, 4bytes/pointer FAT(File-allocation table) 파일 시스템 pointer를 별도의 공간에 저장해서 신뢰성, 공간 효율성의 문제를 해결한 것이다. (3) Indexed Allocation index를 가지고 있는 블럭을 두는 방법이다. 장점 외부조각이 발생하지 않는다. 직접접근이 가능하다. 단점 작은 크기의 파일이더라도 index를 저장하기 위한 블럭이 필요하므로 공간 낭비가 있다. 너무 큰 크기의 파일은 여러개의 index 블럭이 필요하다. (해결방법: linked-scheme, multi-level index) 실제로 사용되는 파일 시스템의 구조 UNIX 파일 시스템 Boot block 부팅에 필요한 정보(bootstrap loader) Super block 파일 시스템에 관한 총체적인 정보 Inode list 파일 이름을 제외한 파일의 모든 메타데이터를 저장 (위에서 메타데이터는 파일의 디렉터리에 저장된다고 했지만 유닉스나 기타 실제 파일 시스템에서는 파일 이름만 디렉터리에 저장되고 나머지. 메타데이터들은 여기에 저장된다) Data block 파일의 실제 내용을 보관 FAT 파일 시스템 Data block의 개수 만큼 FAT 블럭이 존재하고, 내용에는 다음 블럭이 어딘지가 저장되어(pointer) 있다. Free-Spcae Management 비어 있는 블럭들을 어떻게 관리할 것인가? (1) Bit map / Bit vector 블럭이 비어있는지 혹은 사용중인지를 0, 1로 저장한다. 따라서 부가적인 공간을 필요로 한다. 연속적인 가용 공간을 찾기에 효과적이다. (2) Linked list 모든 비어있는 블럭들을 링크로 연결한다. (free list) 공간의 낭비가 없다. 연속적인 가용 공간을 찾기 쉽기 않다. (3) Grouping linked list 방법의 변형이다. 첫 번째 빈 블럭이 n개의 pointer를 가지고, 또 다시 n-1번째의 빈 블럭이 n개의 pointer를 가진다. (4) Counting 프로그램들이 종종 여러 개의 연속적인 블럭을 할당하고 반납한다는 성질에 착안해서, 빈 블럭의 첫 번째 위치와 거기서 부터 몇 개의 빈블럭이 연속되어 있는지를 쌍으로 저장한다. (first free block, # of contiguous free blocks) Directory Implementation 디렉터리를 어떻게 구현할 것인가? (1) Linear list 파일의 이름과 메타데이터를 리스트로 저장한다. \u0026lt;file name, file metadata\u0026gt; 구현이 간단하다. 디렉터리 내에 파일이 있는지 찾기 위해서는 linear search가 필요하다. (time-consuming) (2) Hash table linear list에다가 hashing을 추가한 것이다. 해시 함수를 적용해서 파일 이름을 파일의 위치로 바꾸어주고, 거기에 이름과 메타데이터를 저장한다. 탐색시간을 없앴다. 충돌 발생 가능성이 있다. 파일의 메타데이터를 어디에 보관할 것인가? (1) 디렉터리에 보관 (2) 디렉터리에는 pointer를 두고, 다른 곳에 보관(inode, FAT 등) 긴 파일명의 지원 파일 이름이 고정 크기의 entry의 길이 보다 길어지면, entry의 마지막 부분에 이름의 뒷부분이 위치한 포인터를 둔다. VFS와 NFS VFS(Virtual File System) 서로 다른 다양한 파일 시스템에 대해 동일한 시스템 콜 인터페이스(API)를 통해 접근할 수 있게 해주는 운영체제의 layer이다. NFS(Network File System) 분산 시스템에서 네트워크를 통해 파일을 공유하는 대표적인 파일 공유 방법이다. Page cache와 Buffer cache Page cache 가상 메모리에서, swap area에 있는 페이지에 대한 접근을 빠르게 하기 위해 물리적인 메모리에 올린 프레임들이다. Buffer cache 파일 시스템에서, I/O 처리를 빠르게 하기 위해서 메모리에 올린 파일의 블럭이다. Memorey-mapped I/O 파일의 일부분을 메모리에 매핑을 시켜서, 이 영역에 대한 접근 연산은 I/O를 수행하게 하는 것이다. Unified Buffer Cache 최근의 OS에서는 기존의 Buffer cache가 Page cache에 통합되었다. 그래서 파일의 블럭 단위가 아니라 페이지 단위로 캐싱된다. ","date":"2022-07-20T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-11/","title":"[OS] Chapter 11. 파일 시스템"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n요구 페이징 운영체제는 CPU에서 당장 수행해야 할 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓았다가 다시 필요해지면 메모리에 올리가 있는 부분과 교체하는 방식을 사용한다. 이렇게 하면, 메모리의 연장 공간인 것처럼 디스크 스왑 영역을 사용할 수 있게 된다. 그래서 프로그램은 물리적 메모리의 크기 제약을 신경쓰지 않아도 되므로 각자 독자적인 메모리 주소 공간을 가질 수 있게 된다. 프로세스마다 가지고 있는 0번지부터 시작하는 메모리 주소 공간을 가상 메모리(virtual memory) 라고 한다. 프로세스의 이런 주소 공간을 어떤 단위로 메모리에 적재하는가에 따라 요구 페이징(demand paging) 과 요구 세그먼테이션(demand segmentation) 방식으로 나뉜다. 하지만 대부분 요구 페이징 방식을 사용한다. 요구 페이징(demand paging) 프로그램을 실행했을 때, 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라, 당장 사용될 페이지만을 올리는 방식이다. 장점 물리적 메모리 용량보다 더 큰 프로그램도 실행할 수 있다. 당장 사용할 페이지만 올리기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 올리는 데 드는. 입출력 오버헤드도 감소한다. 사용되지 않을 주소 영역에 대한 입출력까지 수행하던 기존 방식에 비해 응답 시간을 단축시킬 수 있다. 또한 시스템이 더 많은 프로세스를 수용할 수 있게 해준다. 해당 페이지가 메모리에 존재하는지 표시하기 위해 유효-무효 비트(valid-invalid bit) 를 사용한다. 페이지 부재(page fault) CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아서 유효-무효 비트가 무효로 세팅되어 있는 경우이다. 페이지 부재를 처리하는 방식 (1) CPU가 무효 페이지에 접근하면, (2) 주소 변환을 담당하는 하드웨어인 MMU가 페이지 부재트랩(page fault trap)을 발생시칸다. CPU의 제어권이 커널 모드로 전환되고, 운영체제의 페이지 부재 처리루틴(page fault handler)이 호출된다. (3, 4) 해당 페이지의 접근이 적법한 것으로 판명된 경우, 물리적 메모리에서 비어 있는 프레임을 할당 받아서 그 공간에 해당 페이지를 읽어온다. 만약 비어있는 프레임이 없다면, 기존에 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫒아낸다. (스왑 아웃; swap out) 페이지를 메모리로 적재하는데 오랜시간이 걸리므로 해당 프로세스는 CPU를 빼앗기고 봉쇄 상태가 된다. 현재까지 수행되던 CPU 레지스터 상태 및 프로그램 카운터 값은 프로세스 제어블록에 저장해 두어서 나중에 이 프로세스가 CPU를 할당 받으면 정확히 같은 상태에서 다음 명령을 수행할 수 있도록 한다. (5) 디스크 입출력이 완료되어서 인터럽트가 발생하면 페이지 테이블에서 해당 페이지의 유효-무효 비트를 유효로 설정하고, 봉쇄되었던 프로세스를 준비 큐로 이동시킨다. (6) 이 프로세스가 CPU를 할당 받으면 프로세스 제어블록에 저장해두었던 값을 복원시켜 이전에 중단되었던 명령(instruction)부터 실행을 재개한다. 요구 페이징의 성능 유효 접근시간 (effective access time)\n$ = (1 - P) \\times $ 메모리 접근시간 $ + P \\times ($ 페이지 부재 발생 처리 오버헤드 $+$ 메모리에 빈 프레임이 없는 경우 스왑 아웃 오버헤드 $+$ 요청된 페이지의 스왑 인 오버헤드 $+$ 프로세스의 재시작 오버헤드$)$ 페이지 부재 발생비율(page fault rate)\n$ 0 \\le P \\le 1 $ $ P = 0 : $ 페이지 부재가 한 번도 일어나지 않은 경우 $ P = 1 : $ 모든 참조 요청에서 페이지 부재가 발생한 경우 요구 페이징의 성능에 가장 큰 영향을 미치는 요소는 페이지 부재의 발생 빈도이다.\n$P = 0$이면, 즉 페이지 부재가 일어나지 않으면, 오로지 메모리 접근 시간만 소요된다. $P \\ne 0$이면, 즉 페이지 부재가 일어나면, 많은 오버헤드가 필요하게 된다. 페이지 교체 페이지 교체(page replacement) 페이지 부재가 발생했을 때 메모리에 빈 공간이 없으면, 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫒아내서 공간을 확보한다. 이것을 페이지 교체라고 한다. 페이지 교체 알고리즘 어떤 페이지를 쫒아낼 것인가를 결정하는 알고리즘이다. 이 알고리즘의 목표는 페이지 부재율을 최소화하는 것이다. 성능평가 페이지 참조열(page reference string)에 대해 페이지 부재율을 계산함으로써 평가할 수 있다. 해당 번호의 페이지가 메모리에 올라와 있으면 적중(hit), 없으면 부재가 발생했다고 한다. (1) 최적 페이지 교체 (Optimal Algorithm) 빌레디의 최적 알고리즘(Belady\u0026rsquo;s optimal algorithm), MIN, OPT 등으로 불린다. 가장 먼 미래에 참조될 페이지를 먼저 교체하는 방법이다. 미래에 어떤 페이지가 어떤 순서로 참조될지 미리 알고있다는 전제하에 알고리즘을 운영하므로, 실제 온라인으로 사용할 수 있는 알고리즘이 아니다. 이런 알고리즘을 오프라인 알고리즘이라고 부른다. 어떤 경우라도 가장 적은 페이지 부재율을 보장하므로, 다른 알고리즘의 성능을 평가하는 상한선(upper bound)을 제공한다. 즉, 최적 알고리즘과 유사한 결과가 나오면 좋은 것이다. (2) 선입선출 알고리즘 (First In First Out; FIFO) 메모리에 가장 먼저 올라온 페이지를 먼저 교체하는 방법이다. 향후 참조 가능성을 생각하지 않기 때문에 비효율적인 상황이 발생할 수 있다. FIFO 이상 현상(FIFO anomaly) 메모리를 증가시켰음에도 불구하고 페이지 부재가 오히려 늘어나는 상황 (3) LRU 알고리즘 (Least Recently Used) 가장 오래전에 참조한 페이지를 먼저 교체하는 방법이다. 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높다는 성질인, 시간 지역성(temporal locality) 에 따른 방법이다. (4) LFU 알고리즘 (Least Frequently Used) 과거에 참조 횟수(reference count)가 가장 적은 페이지를 먼저 교체하는 방법이다.\n참조 횟수를 계산하는 방식에 따라\u0026hellip;\nIncached-LFU 페이지가 메모리에서 쫒겨났다가 다시 들어오면 참조 횟수가 1이된다. Perfect-LFU 과거의 총 참조 횟수를 카운트한다. 과거의 참조 기록을 모두 보관해야 하므로 오베헤드가 상대적으로 크다. LRU의 경우에는 직전에 참조된 시점만을 반영하지만 LFU는 장기적인 시간 규모에서의 참조 성향을 고려한다. 참조열이 1, 1, 1, 1, 2, 2, 3, 3, 2, 4, 5와 같고 현재 5 페이지를 참조하기 위해 페이지 교체를 해야한다고 했을 때, LRU는 가장 오래전에 참조한 1을 내쫒는다. $O(1)$의 시간 복잡도가 걸린다. LFU는 가장 참조 횟수가 적은 4를 내쫒는다. 힙(heap)을 사용해서 $O(log n)$의 시간 복잡도가 걸린다. 캐쉬 운영의 시간 제약 캐슁 기법 한정된 빠른 공간(=캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식이다. paging system(디스크의 스왑 영역의 페이지를 캐싱)외에도 cache memory, buffer caching(디스크의 파일 시스템의 파일의 블럭을 캐싱), web caching(지리적으로 멀리 떨어져있는 컴퓨터에서 웹서버에서 매번 읽어오지 않고 내 컴퓨터에 캐싱되어 있는 것을 읽어오는 것) 등 다양한 분야에서 사용된다. 교체 알고리즘은 캐쉬 운영의 시간 제약이 있다. 교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없다. buffer caching이나 web caching의 경우에는 $O(1)$, $O(log n)$ 정도까지만 허용된다. paging system의 경우 제약 조건이 더 있다. 페이지 부재가 발생한 경우에만, 트랩이 발생하고 제어권이 넘어가서 운영체제가 관리할 수 있게 된다. 그래서 페이지가 이미 메모리에 존재하는 경우에는 운영체제가 참조 시각 등의 정보를 알 수 없다. 그래서 $O(1)$이더라도 LRU의 리스트(참조한 것들의 목록) 조작도 불가능하게 된다. 그렇기 때문에 LRU, LFU는 사실 paging system에 적절한 알고리즘들은 아니다. (5) 클럭 알고리즘(Clock Algorithm) = NUR(Not Used Recently) LRU, LFU 알고리즘은 페이지 참조 시각, 참조 횟수를 소프트웨어적으로 유지하고 비교하므로 오버헤드가 발생한다. 클럭 알고리즘은 이것을 하드웨어적으로 지원해서 훨씬 빠르고 효율적으로 이루어지게 한다. 대부분의 시스템에서 이 알고리즘을 채택한다. LRU를 근사시킨 알고리즘이다. 최근에 참조되지 않은 페이지를 교체하는 것은 LRU와 동일하다. 하지만 참조 시점이 가장 오래되었다는 것을 보장하지는 못한다. 각 프레임 마다 참조 비트(reference bit) 를 두어 사용한다. 해당 프레임의 페이지가 참조될 때 하드웨어에 의해 1로 자동 세팅된다. 교체 대상 페이지를 찾을 때는 1인 페이지는 0으로 만들고 지나가고, 0인 페이지를 만나면 교체한다. 즉, 시곗바늘이 한 바퀴 도는 동안 다시 참조되지 않은 페이지를 교체하는 것이다. modified bit(dirty bit) 를 둘 수도 있다. 참조 비트는 Read한 페이지라면, 이것은 최근에 Write로 변경된 페이지(I/O를 동반하는 페이지)를 1로 세팅한다. modified bit이 1인 페이지를 교체하려면 수정된 내용을 디스크에 쓰고 교체해야한다. 그래서 0인 페이지를 교체하는 것이 더 효율적이다. 페이지 프레임의 할당 각 프로세스에 얼마만큼의 메모리 공간을 할당할 것인가? 예를 들어, 반복문을 실행 중인 프로세스의 경우 반복문을 구성하는 페이지들을 한꺼번에 메모리에 올려 놓는 것이 페이지 부재가 덜 발생한다. 혹은 명령을 실행할 때 프로세스의 주소 공간에서 코드, 데이터, 스택 등의 각기 다른 영역을 참조하기 때문에 적어도 일정 수준 이상의 프레임을 할당해야 한다. 할당 알고리즘 균등할당(equal allocation) 모든 프로세스에게 균일하게 할당 비례할당(proportional allocation) 프로세스 크기에 비례해서 할당 우선순위 할당(priority allocation) 프로세스의 우선순위에 따라 할당 전역교체와 지역교체 교체 대상이 될 프레임의 범위를 어떻게 정할 것인가? 전역교체(global replacement) 모든 프레임이 교체 대상이 된다. 교체할 프레임은 다른 프로세스에게 할당된 것일 수 있다. 즉, 페이지 교체 시 다른 프로세스에 할당된 프레임을 빼앗아올 수 있는 방식이다. 다시 말하면, 전체 메모리를 각 프로세스가 공유해서 사용하고 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방법이다. 워킹 셋, PFF 알고리즘 지역교체(local replacement) 현재 수행 중인 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정할 수 있다. 스레싱 스레싱(thrashing) 잦은 페이지 부재로 CPU 이용률이 급격히 저하되는 현상 프로세스의 원활한 수행을 위해 필요한 최소한의 페이지 만큼 메모리를 할당받지 못하면? 페이지 부재율이 높아진다. CPU 이용률(CPU utilization)이 낮아진다. 운영체제는 다중 프로그래밍의 정도(multi-programming degree; MPD; 메모리에 동시에 올라가 있는 프로세스의 수) 를 높인다. 또 다시 새로운 프로세스가 시스템에 추가된다. 그러면 프로세스 당 할당된 프레임의 수가 더욱 감소한다. 페이지 부재가 빈번히 발생하여, 프로세스들은 서로의 페이지를 교체하며 스왑 인과 스왑 아웃을 지속적으로 발생시킨다. 따라서 대부분의 시간에 CPU는 할일이 없게된다. MPD를 적절히 조절해서, CPU 이용률을 높이는 동시에 스레싱 발생을 방지하는 방법 아래\u0026hellip; (1) 워킹셋 알고리즘 참조의 지역성(locality of reference) 프로세스는 일정 시간 동안 특정 주소 영역을 집중적으로 참조하는 경향이 있다. 지역성 집합(locality set) 집중적으로 참조되는 페이지들의 집합. 워킹셋 알고리즘(working-set algorithm) 지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘이다. 프로세스가 일정 시간 동안 원활히 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합을 워킹셋(working-set) 이라고 정의한다. 이 워킹셋이 한꺼번에 메모리에 올라갈 수 있는 경우에만 그 프로세스에게 메모리를 할당한다. 그렇지 못한다면 할당된 모든 프레임을 반납하고 디스크로 스왑 아웃시킨다. 워킹셋을 결정하는 법 윈도우의 크기가 $\\Delta$인 경우, 페이지가 참조된 시점부터 $\\Delta$시간 동안은 메모리에 유지하고, 그 시점이 지나면 메모리에서 지워버린다. $t_i$ 시각에서의 워킹셋 $WS(t_i)$ $=$ 시간간격 $[t_i - \\Delta, t_i]$ 사이에 참조된 서로 다른 페이지들의 집합 (2) 페이지 부재 빈도 알고리즘 페이지 부재 빈도 알고리즘(page-fault frequency scheme) 페이지 부재율의 상한값과 하한값을 두어서, 상한값을 넘기면 프레임을 추가로 할당하고, 하한값 이하로 떨어지면 프레임 수를 줄이는 방법이다. ","date":"2022-07-13T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-10/","title":"[OS] Chapter 10. 가상 메모리"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n주소 바인딩 논리적 주소(Logical address) = Virtual address 프로세스마다 독립적으로 가지는 주소 공간이다. 각 프로세스마다 0번지부터 시작한다. CPU가 보는 주소는 이 논리적 주소이다. 물리적 주소(Physical address) 메모리에 실제로 올라가는 위치이다. 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다. 주소 바인딩 논리적 주소를 물리적 주소로 연결시켜주는 것이다. Symbolic address → Logical address →(이 시점이 언제인가?) Physical address 여기서 Symbolic address는 프로그래머가 사용하는, 숫자가 아닌 심볼로 된 주소를 의미한다. 이것이 컴파일이 되면 숫자로 된 Logical address로 바뀌겠다. 주소 바인딩의 종류 컴파일 타임 바인딩(compile time binding) 물리적 메모리의 주소가 컴파일 시에 결정된다. 컴파일러가 절대 코드(absolute code) 를 생성하는 방식이다. 로드 타임 바인딩(load time bining) 물리적 메모리의 주소가 프로그램의 실행이 시작될 때 결정된다. 컴파일러가 재배치 가능 코드(relocatable code) 를 생성한 경우 가능하다. 런타임 바인딩(runtime binding = executione time binding) 프로그램을 시작한 후에도 물리적 메모리의 주소를 변경할 수 있는 방식이다. CPU가 주소를 참조할 때마다 주소 매핑 테이블(address mapping table) 을 이용해서 바인딩을 점검한다. 하드웨어적 지원이 필요하다. 기준 레지스터(base register), 한계 레지스터(limit register), MMU(Memory Management Unit) MMU 메모리 관리 유닛 (Memory Management Unit; MMU)\n논리적 주소를 물리적 주소로 바인딩 해주는 하드웨어 장치이다. CPU가 사용자 프로세스의 논리적 주소를 참조하려고 할 때, 그 주소값에 기준 레지스터(base register)의 값을 더해서 물리적 주소값을 얻어낸다. 그래서 사용자 프로세스는 논리적 주소만 다루고, 실제 물리적 주소를 다루지 못하면 알 필요가 없다. 기준 레지스터 = 재배치 레지스터 (base register = relocation register)\n해당 프로세스의 물리적 메모리 시작 주소를 가지고 있다. 따라서 논리적 주소는 일종의 오프셋(offset) 개념으로 생각할 수 있다. 한계 레지스터 (limit register)\n논리적 주소값에 기준 레지스터 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우를 방지하기 위해서, 해당 프로세스의 논리적 주소의 최댓값(프로세스의 크기)을 가지고 있다. 만약 주소 공간을 벗어나는 경우에는 트랩을 발생시켜 해당 프로세스를 강제종료시킨다. 메모리 관리와 관련된 용어 동적로딩(Dynamic loading) 의미 프로세스 주소 공간 전체를 메모리에 올리는 것이 아니라 해당 부분이 불릴 때, 그 일부분만을 메모리에 적재하는 방식이다. 목적 여러 프로그램이 메모리에 올라가는 다중 프로그래밍 방식에서 더 많은 프로세스를 동시에 올려놓기 위함이다. 사용되지도 않는 많은 양의 코드가 메모리에 올라가는 것을 막아서 메모리를 효율적으로 쓸 수 있게 한다. 사용 방법 운영체제의 특별한 지원 없이, 프로그램 자체에서 구현이 가능하다. 운영체제가 라이브러리를 통해 지원할 수도 있다. 중첩(Overlays) 의미 동적로딩과 같다. 하지만 역사적인 목적이 다르다. 목적 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이었다. 사용 방법 프로그래머가 수작업으로 구현해서 수작업 중첩(Manual Overlays)이라고도 불렸다. 동적연결(Dynamic linking) 연결(linking) 소스 코드를 컴파일해서 생성된 목적 파일(object file)과, 이미 컴파일 된 라이브러리 파일(library file)들을 묶어서 하나의 실행 파일을 생성하는 과정을 말한다. 의미 연결을 실행 시간까지 미루는 기법이다. 라이브러리 호출 부분에 스텁(stub) 이라는 작은 코드를 두고, 프로그램이 실행되고 라이브러리 함수를 호출하면, 그 때가 되어서야 라이브러리에 대한 연결이 이루어진다. 라이브러리가 메모리에 있으면 불러오고, 없으면 디스크에서 읽어온다. 목적 정적연결(Static linking) 라이브러리가 프로그램의 실행 파일에 포함된다. (예: printf 함수의 라이브러리 코드) 따라서 실행 파일이 커진다. 동일한 라이브러리를 각각의 프로세스가 메모리에 올려서 메모리의 낭비가 있다. 동적연결의 경우 공통으로 사용하는 라이브러리를 한 번만 적재하므로 메모리 효율성을 높일 수 있다. 사용 방법 운영체제의 도움이 필요하다. 스와핑(Swapping) 의미 프로세스의 주소 공간 전체를 메모리에서 디스크에 있는 스왑 영역(swap area)으로 쫒아내는 것이다. 스왑 영역은 백킹 스토어(backing store) 라고도 부르며, 디스크 안에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다. 이것은 프로세스가 종료되어서가 아니라, 특정 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미한다. 중기 스케줄러에 의해 스왑 아웃될 프로세스가 선정된다. 목적 메모리에 존재하는 프로세스의 수를 조절하기 위함이다. 바인딩과 연관해서 생각해보면\u0026hellip; 컴파일, 로드 타임 바인딩 방식 돌아올 때는 원래 있던 메모리 위치로 스왑 인해야한다. 런타임 바인딩 방식 빈 메모리 아무 곳에나 프로세스를 올릴 수 있다. 물리적 메모리의 할당 방식 물리적 메모리의 낮은 주소 영역에는 운영 체제가 올라가고, 인터럽트 벡터, 운영체제 커널이 여기 위치한다. 물리적 메모리의 높은 주소 영역에는 여러가지 사용자 프로세스들이 올라간다. 여기서는 사용자 프로세스 영역의 관리 방법에 대해 살펴본다. 연속할당(Contiguous allocation) 방식 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식이다. 물리적 메모리를 다수의 분할로 나누어서 하나의 분할에 하나의 프로세스가 적재되도록 한다. (1) 고정 분할(Fixed partition allocation) 방식 물리적 메모리를 주어진 개수만큼 영구적인 분할로 미리 나누어두는 방식이다. 분할의 크기는 모두 동일하게 할 수도 있고, 서로 다르게 할 수도 있다. 하나의 분할에는 하나의 프로그램만을 적재할 수 있다. 단점 동시에 메모리에 올릴 수 있는 프로그램 수가 고정되어 있으므로 유통성이 떨어진다. 외부 단편화와 내부 단편화가 발생할 수 있다. 외부 단편화(external fragmentation) 해당 분할이 비어 있지만 프로그램의 크기가 더 커서 할당할 수 없어 낭비되는 공간이 생긴 것이다. 내부 단편화(internal fragmentation) 할당된 분할이 프로그램 크기에 비해 더 커서 낭비되는 공간이 생긴 것이다. (2) 가변 분할(Variable partition allocation) 방식 물리적 메모리를 미리 나누어 두지 않고, 프로그램 크기에 따라서 동적으로 분할의 크기, 개수가 변하는 방식이다. 동적 메모리 할당 문제(dynamic storage-allocation problem) 주소 공간의 크기가 $n$인 프로세스를 메모리에 올릴 때, 물리적 메모리 내 가용 공간(hole) 중에 어떤 위치에 올릴 것인가? 방법1. 최초적합(first-fit) 크기가 $n$이상인 가용 공간 중, 가장 먼저 찾아지는 곳에 프로세스를 할당한다. 방법2. 최적적합(best-fit) 크기가 $n$이상인 가용 공간 중, 가장 작은 곳에 프로세스를 할당한다. 많은 수의 작은 가용 공간들이 생성되겠다. 방법3. 최악적합(worts-fit) 가용 공간 중에서 크기가 가장 큰 곳에 프로세스를 할당한다. 상대적으로 큰 가용 공간들이 생성되겠다. 단점 외부 단편화가 발생할 수 있다. 해결 방법: 컴팩션(compaction) 사용 중인 메모리 영역을 한쪽으로 몰고, 가용 공간을 다른 한쪽으로 몰아서, 하나의 큰 가용 공간을 만드는 방법이다. 비용이 매우 많이 드는 작업이다. 물리적 메모리 위치를 옮겨야 하므로, 런타임 바인딩 방식에서만 사용 가능하다. 불연속할당(Noncontiguous allocation) 방식 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해서 적재하는 방식이다. (1) 페이징(Paging) 기법 각 프로세스의 주소 공간을 동일한 크기의 페이지로 자르고, 물리적 메모리도 프레임(frame)으로 잘라서 적재시키는 방식이다. 논리적 메모리 주소를 가진 페이지를 물리적 메모리의 몇 번째 프레임에 있는지로 변환하기 위한 페이지 테이블(page table) 이 필요하다. 따라서 페이지의 개수만큼의 entry(항목; 페이지 테이블의 레코드)가 필요하다. 각 프로세스 마다 페이지 테이블이 존재한다. 주소 변환 기법 논리적인 페이지 번호 p로 페이지 테이블에 접근한다. 거기에서 물리적인 프레임 번호 f를 얻는다. 프레임 내에서의 위치(오프셋 d)는 프레임 내에서의 주소로 그대로 사용된다. f + d로 물리적 메모리에 접근한다. 페이지 테이블의 구현 현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다. 페이지 테이블 기준 레지스터(page-table base register; PTBR) 페이지 테이블은 메인 메모리에 상주하는데, PTBR은 이 물리적 메모리에서 페이지 테이블이 존재하는 시작 위치를 가리킨다. 페이지 테이블 길이 레지스터(page-table length register; PTLR) 페이지 테이블의 크기를 보관한다. 모든 메모리 접근 연산에는 2번의 메모리 접근이 필요하다. 페이지 테이블 접근 1번, 실제 데이터 접근 1번. 따라서 메모리 접근 속도 향상을 위해, TLB(Translation Look-aside Buffer; 고속의 주소 변환용 하드웨어 캐시 메모리) 를 사용하기도 한다. 이것은 빈번히 참조되는 페이지에 대한 주소 변환 정보를 가지고 있다. 페이지 테이블을 참조하기 전에 이 캐시를 먼저 살펴보고 없으면 페이지 테이블을 참조한다. 페이지 테이블 처럼 모든 주소를 가지고 있는 게 아니라서, 저장되어 있는 순서에 따라 페이지 번호 p를 알 수 없다. 따라서 페이지 번호 p가 함께 프레임 번호 f가 쌍으로 저장되어 있다. 각 프로세스마다 주소 변환 정보가 다르기 때문에 페이지 테이블이 따로 존재하고, TLB도 마찬가지이다. 그래서 문맥교환 시에 TLB의 entry는 비워진다. TLB의 모든 entry를 다 찾아보는 오버헤드를 줄이기 위해서 일반적으로 병렬탐색(parallel search)이 가능한 연관 레지스터(associative register) 를 사용한다. 병렬탐색이란 TLB 내의 모든 entry를 동시에 탐색할 수 있는 기능을 말한다. 메모리 접근 시간(Effective Access Time; EAT) $ EAT = (1 + \\epsilon)\\alpha + (2 + \\epsilon)(1 - \\alpha)$ $ EAT = 2 + \\epsilon - \\alpha $ $1$ : 메모리 접근 시간 $\\epsilon$ : 연관 레지스터에 접근하는 시간 $\\alpha$ : 요청된 페이지에 대한 주소 변환 정보가 연관 레지스터에 존재할 확률 (Hit ratio) $ (1 + \\epsilon)\\alpha $ : hit. TLB에 존재하는 경우 $ (2 + \\epsilon)(1 - \\alpha) $ : miss. TLB에 존재하지 않는 경우 계층적 페이징 컴퓨터가 $32bit$ 주소 체계를 사용한다면, $2^{32}byte(4GB)$의 주소 공간을 갖는 프로그램을 지원할 수 있다.\n페이지 하나의 크기가 $4KB$라고 한다면, $4GB / 4KB = 1M$ 개의 페이지 테이블 entry가 필요하다. 페이지 테이블 안에 한 entry의 크기가 $4byte$ 정도인데 그러면 총 $4byte \\times 1M = 4MB$라는 공간이 필요하다. 프로세스 마다 $4MB$의 페이지 테이블을 모두 메모리에 집어 넣으면 공간 낭비가 심할 것이다. 실제로 프로그램이 사용하는 부분은 메모리의 지극히 일부분이므로, 2단계 페이징(two-level paging) 기법을 사용해서 메모리의 낭비를 줄인다. 2단계 페이징(two-level paging)\n외부 페이지 테이블(outer page table) 과 내부 페이지 테이블(inner page table) 의 두 단계를 걸쳐 주소를 변환한다. 사용되지 않는 주소 공간에 대해서는 외부 페이지 테이블의 entry를 NULL로 설정해서 내부 페이지 테이블을 생성하지 않는 것이다. 외부 페이지 테이블 번호 P1과 내부 페이지 테이블 번호 P2, 프레임 내에서의 오프셋 d로 주소를 변환한다.\n페이지 하나의 크기가 $4KB(2^{12}byte)$이므로, 그 내부에서 오프셋을 결정하기 위해서 d는 $12bit$이어야 한다. 내부 페이지 테이블은 페이지화되어서 페이지 하나의 크기인 $4KB$의 공간을 차지한다. 여기서 각 entry는 $4byte$이므로 entry의 총 수는 $4KB / 4byte = 1K$ 개이다. 이것은 $2^{10}$개 이므로, 내부 페이지 테이블의 P2는 $10bit$가 된다. 그리고 전체 주소 크기 $32it$에서 $12bit$, $10bit$를 뺀 $10bit$가 P1의 크기가 된다. 공유 페이지 공유 코드(shared code) = 재진입 가능 코드(re-entrant code) = 순수 코드(pure code) 여러 프로세스에서 공통으로 사용될 수 있도록 작성된 코드이다. 읽기 전용(read-only) 의 특징을 가지고 있다. 공유 페이지(shread page) 공유 코드를 담고 있는 페이지이다. 여러 프로세스에 의해 공유되므로, 물리적 메모리에 하나만 적재되어 사용된다. 예를 들어, 문서 편집기 프로그램을 공유 페이지를 사용해서 작성한 경우, 이 프로세스를 여러 개 수행시키더라도 공유 코드를 담은 페이지는 메모리에 하나만 올라가고 여러 프로세스가 코드를 공유해서 사용하게 된다. 이것을 사용하는 모든 프로세스의 논리적 주소 공간에서 동일한 페이지 번호를 갖고 있어야만 한다. 물리적 주소가 같은 것은 당연하다. 사유 페이지(private page) 공유 페이지와 반대로, 프로세스들이 독자적으로 사용하는 페이지이다. 사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어떠한 위치에 있어도 무방하다. 메모리 보호 페이지 테이블의 각 entry에는 주소 변환 정보뿐만 아니라 메모리 보호를 위한 비트를 두고 있다. 보호비트(protection bit) 각 페이지에 대한 접근 권한을 담고 있다. 한 프로세스의 주소 공간은 다른 프로세스에 의해 접근될 수 없으므로 \u0026lsquo;누구\u0026rsquo;에 해당하는 접근 권한을 설정할 필요는 없다. 각 페이지에 \u0026lsquo;어떠한\u0026rsquo; 접근을 허용하는지의 정보가 저장된다. 유효-무효 비트(valid-invalid bit) valid는 해당 주소의 메모리에 그 페이지가 존재함을 뜻한다. 유효한 내용이 있으므로 접근을 허용한다. invalid는 해당 주소의 메모리에 유효한 내용이 없음을 뜻한다. 유효한 내용이 없으므로 접근을 불허한다. 프로세스가 그 주소 부분을 사용하지 않고 있거나, 해당 페이지가 메모리에 올라와 있지 않고 백킹스토어에 존재하는 경우이다. 역페이지 테이블 페이지 테이블로 인한 공간의 낭비 모든 프로세스 별로 그 논리적 주소에 대응하는 모든 페이지에 대해 페이지 테이블 entry가 존재한다. entry는 그 페이지가 물리적 메모리에 있든 없든간에 존재한다. 그래서 대안으로 역페이지 테이블이 등장했다. 역페이지 테이블(Inverted page table) 논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라, 물리적 주소에 대해 페이지 테이블을 만드는 것이다. 그래서 물리적 주소의 페이지 프레임 하나당 페이지 테이블의 entry 하나를 둔다. 즉, 시스템 전체(system-wide)에 페이지 테이블을 하나만 두는 방법이다. entry에는 프로세스의 id와 논리적 페이지 번호(p)가 들어있다. 단점 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해 페이지 테이블 전체를 탐색해야 한다. 조치 연관 레지스터를 사용해서 페이지 테이블 전체 entry를 병렬탐색 할 수 있게 한다. (2) 세그먼테이션(Segmentation) 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어서 세그먼트 단위로 적재하는 방식이다. 논리적 단위(logical unit)로 나누었기 때문에 그 크기가 균일하지 않다. 세그먼트를 함수 단위로 정의할 수도 있다. (main(), function, global variables, stack, symbol table, arrays) 주소 변환 기법 논리적인 세그먼트 번호 s는 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트인지를 알려준다. 이것을 사용해서 세그먼트 테이블에 접근한다. 물리적 메모리의 세그먼트 내에서의 위치(오프셋 d)는 그대로 사용된다. base + d 로 물리적 메모리에 접근한다. 세그먼트 테이블의 각 entry는 기준점 base와 한계점 limit를 가지고 있다. base는 물리적 메모리에서 그 세그먼트의 시작 위치를 나타낸다. limit은 그 세그먼트의 길이를 나타낸다. 페이징에서는 이것이 필요 없었다. 길이가 모두 일정하기 때문이다. 세그먼트 테이블 기준 레지스터(Segment-Table Base Register; STBR) 물리적 메모리에서 세그먼트 테이블이 존재하는 시작 위치를 가리킨다. 세그먼트 테이블 길이 레지스터(Segment-Table Length Register; STLR) 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 세그먼트의 개수를 나타낸다. 세그먼테이션 기법에서는 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확인한다. (1) 요청된 세그먼트 번호 s가 STLR에 저장된 세그먼트 길이 값보다 작은 값인가? (2) 오프셋 값 d가 세그먼트의 길이 limit보다 작은 값인가? 공유, 보호, 할당 공유, 보호 공유 세그먼트(shared segment) 개념을 지원한다. 세그먼테이션 기법에서도 페이징 기법과 마찬가지로 entry에 보호비트와 유효-무효 비트를 둔다. 페이징에 비해 공유와 보안 측면에서 효과적이다. 페이지는 동일 크기로 무조건 자르기 때문에 한 페이지에 읽기 전용 접근 권한을 주더라도 코드영역과 데이터영역이 같이 들어가 있을 수 있다. 하지만 세그먼트는 의미적인 단위로 나뉘므로, 공유나 보안 처럼 의미적인 단위에 대해 수행하는 업무에서는 훨씬 효과적이다. 햘당 최초적합(first-fit), 최적적합(best-fit) 방식을 사용해서 세그먼트를 가용 공간에 할당할 수 있다. 세그먼트의 크기가 모두 균일하지 않으므로 외부 조각이 발생한다. (3) 페이지드 세그먼테이션(Paged segmentation) 페이징 기법과 세그먼테이션 기법의 장점만을 취하는 주소 변환 기법이다. 프로그램의 주소 공간을 의미 단위인 세그먼트로 나누되, 세그먼트를 임의의 길이가 아닌 동일한 크기의 페이지들의 집합으로 구성하는 방식이다. 따라서 하나의 세그먼트는 페이지 크기의 배수가 된다. 그리고 물리적 메모리에 적재하는 단위는 페이지 단위로 한다. 외부조각의 문제점을 해결하며, 의미 단위로 프로세스 간의 공유나 접근권한 보호가 이루어지도록 해서 각각의 단점을 보완한다. 주소 변환 기법 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용한다. 세그먼트 번호 s로 세그먼트 테이블에 접근해서, 세그먼트 길이 segment-length와 페이지 테이블의 시작 주소 page-table base를 얻는다. 오프셋 값 d가 세그먼트 길이값 segment-length보다 작은지 검사한다. 오프셋 값 d를 상위(p), 하위(d') 비트로 나눈다. 상위 비트로 페이지 테이블에 접근(page-table base + p)하고, 하위 비트로 물리적 메모리의 페이지 내 변위(f + d')로 사용한다. ","date":"2022-07-06T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-09/","title":"[OS] Chapter 9. 메모리 관리"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n데드락 교착상태(deadlock) 둘 이상의 프로세스가 서로 상대방이 가진 자원을 얻기 위해 무한히 기다리며 block된 상태이다. 여기서 자원이란 하드웨어, 소프트웨어 등을 포함하는 개념이다. (예: I/O device, CPU cycle, memory space, semaphore 등) 프로세스가 자원을 사용하는 절차: Request → Allocate → Use → Release 데드락 발생의 4가지 조건 조건 설명 상호 배제 (Mutual exclusion) 매 순간 하나의 프로세스만 자원을 획득할 수 있다. 보유 대기 (Hold and wait) 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유 자원을 놓지 않고 계속 가지고 있다. 비선점 (No preemption) 프로세스의 자원을 강제로 빼앗을 수 없다. 순환 대기 (Circular wait) 자원을 기다리는 프로세스 간에 사이클이 형성되어 있다. 데드락 해결 방법 데드락 예방 (Deadlock Prevention) 자원 할당 시 데드락 발생의 4가지 조건 중 어느 하나가 만족되지 않도록 하는 것이다.\n만족되지 않도록 배제 할 수 있는 조건 살펴보기\n조건 설명 상호 배제 (Mutual exclusion) 공유하면 안 되는 자원은 이 조건을 반드시 성립해야 해서 배제 불가능. 보유 대기 (Hold and wait) 자원을 요청할 때 자원을 가지지 않도록 하면 된다. 방법1. 프로세스 시작 시 모든 필요한 자원을 할당받게 한다. 방법2. 자원이 필요한 경우 보유 자원을 모두 놓고 다시 요청한다. 비선점 (No preemption) 다른 자원을 요청할 때 자원을 보유한 자원을 빼앗을 수 있도록 한다. (선점) 상태를 쉽게 저장하고 복구할 수 있는 자원에서 주로 사용한다. (CPU, memory) 순환 대기 (Circular wait) 모든 자원 유형에 할당 순서를 정해서 정해진 순서대로만 자원을 할당한다. 예를 들어, 1번, 3번 자원을 획득해야지만 5번 자원을 획득할 수 있는 것이다. 자원 A(순서 3)을 보유 중인데 자원 B(순서 1)을 할당받으려면 우선 자원 A를 해제해야한다. 하지만, 자원에 대한 이용률(Utilization)이 낮아지고, Throughput 감소, Starvation이 발생할 수 있다. 데드락 회피 (Deadlock Avoidance) 자원 요청에 대한 부가적인 정보를 이용해서 자원 할당을 하면 데드락의 가능성이 없는지를 동적으로 검사해서 안전한 경우에만 자원을 할당하는 것이다. 가장 단순하고 일반적인 모델은, 프로세스들이 시작될 때, 평생 필요로 하는 자원별 최대 사용량을 미리 선언하도록 하는 것이다. safe state 데드락이 없는 안전한 상태이다. safe sequence 특정한 순서로 자원의 할당, 실행, 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서라고 부른다. unsafe state 데드락이 있을 가능성이 있는 상태이다. 2가지 회피 알고리즘 자원의 인스턴스가 1개일 때 (1) 자원 할당 그래프 알고리즘(Resource Allocation Grapeh algorithm) 사용 자원의 인스턴스가 여러개 일 때 (2) 은행원 알고리즘(Banker\u0026rsquo;s algorithm) 사용 (1) 자원 할당 그래프 알고리즘 $P_2$가 $R_2$자원을 할당받으면 사이클이 생기므로, $P_1$이 먼저 할당받는다. (2) 은행원 알고리즘 가정 모든 프로세스는 자원의 최대 사용량을 미리 명시한다. 그리고 자원을 최대 사용량만큼 할당 받은 프로세스는 작업이 끝나면 자원을 반납한다. 방법 현재 가용 자원(Available) 과 각 프로세스들이 작업을 완료하기 위해 필요한 자원(Need) 을 비교하여, 당장 작업을 마칠 수있는 프로세스부터 자원을 할당하여, 프로세스가 작업을 완료하고 반환하는 자원을 다른 프로세스에게 다시 할당하는 것이다. 프로세스명 Max Allocation Need P0 10 5 5 P1 4 2 2 P2 9 2 7 여기서 총 자원의 양이 12라고 한다면, 현재 Allocation은 9이므로, Available은 3이다. 이 때, Need가 Available을 넘지 않는 P1이 2만큼 할당 받을 수 있겠다. P1의 작업이 끝나고, 자원이 해제되어서 Available이 5가 되면, P0이 할당 받을 수 있다. P0의 작업이 끝나고, 자원이 해제되어서 Available이 10이 되면, P2가 할당 받을 수 있다. 데드락 탐지 및 회복 (Deadlock Detection and Recovery) 데드락 발생은 허용하되, 그에 대한 detection 루틴을 두어 데드락 발생 시 recover하는 것이다. 2가지 탐지 및 회복 알고리즘 자원의 인스턴스가 1개일 때 (1) 자원 할당 그래프의 변형인 대기 그래프(Wait-for graph) 사용 자원의 인스턴스가 여러개 일 때 (2) 은행원 알고리즘과 유사한 방법 사용 (1) 대기 그래프(Wait-for graph) 자원 타입의 노드를 제거하고 프로세스만으로 노드를 구성해서 사이클이 존재하는지 조사한다. ($n^2$) (2) 은행원 알고리즘과 유사한 방법\n은행원 알고리즘과 다른 것\n각 프로세스가 실제로 요청한 자원(Request) 개수를 사용한다. 이것은 추가적으로 요청할 수 있는 것(Need)과 다르다. 현재 상태가 안전 상태(safe state)인지 확인하고, 불안정 상태(unsafe state)라면 데드락이라고 판단한 후 recovery 한다. Recovery 방법 1. Process Termination 데드락과 연루된 프로세스를 모두 종료시킨다. 혹은 데드락과 연루된 프로세스를 하나씩 종료시킨다. 방법 2. Resource Preemption 비용을 최소화하는 프로세스 희생양을 하나 찾아서, 자원을 뺏는다. (safe state로 rollback해서 프로세스를 다시 시작한다. ) 동일한 프로세스가 희생양이 되는 starvation 문제가 발생할 수 있다. 따라서 rollback 횟수도 고려해서 선정해야 한다. 데드락 무시 (Deadlock Ignorance) 데드락을 시스템이 책임지지 않는 것이다. 데드락이 일어나지 않는다고 생각하고 아무런 조취도 취하지 않는다. 만약 데드락이 발생하면, 시스템이 비정상적으로 작동한다는 것을 사람이 느끼고 직접 프로세스를 죽이도록 한다. UNIX, Windows 등의 대부분의 운영체제가 채택한 방법이다. ","date":"2022-06-30T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-08/","title":"[OS] Chapter 8. 데드락"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n프로세스 동기화 문제 데이터 접근 방식 한 저장 공간(메모리, 주소 공간)에 있는 데이터를 연산 실행 주체(CPU, 프로세스)가 읽어와서 연산을 한 후, 다시 저장 공간에 연산 결과를 저장한다. 연산 주체 저장 공간 컴퓨터 하드디스크 CPU 메모리 프로세스 프로세스의 주소 공간 하나의 저장 공간을 여러 주체가 접근하려고 할 때 경쟁 상태(Race Condition) 가 생길 가능성이 있다. 운영체제에서 Race Condition이 발생하는 경우 (1) 커널 모드 수행 중에 인터럽트가 발생해서 인터럽트 처리 루틴을 수행할 때 양쪽 모두 커널 코드를 수행하므로 커널 주소 공간을 공유하고 있다. 해결책: 커널 모드 수행 중일 때는 인터럽트를 비활성화한다. (2) 커널 모드 수행 중에 다른 프로세스가 시스템 콜을 해서 문맥교환이 일어나고, 다른 프로세스가 커널 모드를 수행할 때 두 프로세스는 데이터를 공유하지 않지만, 시스템 콜을 하는 동안에는 커널 주소 공간에 접근할 수 있다. 해결책: 커널 모드 수행 중일 때는 CPU를 선점하지 않는다. (3) 멀티 프로세서에서 공유 메모리 내의 커널 데이터 해결책: 커널 내부의 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 한다. 프로세스 동기화(procee synchronization) 문제 = 병행 제어(concurrency control) 문제 공유 데이터에 여러 프로세서가 동시에 접근하는 상황(race condition) 은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있다. 일관성 유지를 위해서는 동시에 접근하는 프로세스 간에 실행 순서를 정하는 메커니즘이 필요하다. 즉, 동기화가 필요하다. 크리티컬 섹션 크리티컬 섹션(critical section) 각 프로세스의 코드 영역에 있는, 공유 데이터를 접근하는 코드이다. 크릴티컬 섹션 문제의 해결법 충족 조건 상호 배제(Mutual Exclusion) 어떤 프로세스 하나가 크리티컬 섹션을 수행 중이면 다른 모든 프로세스가 크리티컬 섹션에 들어갈 수 없어야 한다. 진행(Progress) 아무도 크리티컬 섹션에 없을 때, 어떤 프로세스가 크리티컬 섹션에 들어가고자 한다면, 들어갈 수 있어야 한다. 유한 대기(Bounded Waiting) 어떤 프로세스가 크리티컬 섹션에 들어가려고 요청하고 기다릴 때, 다른 모든 프로세스가 크리티컬 섹션에 들어갈 수 있는 횟수가 제한되어야 한다. 알고리즘 1 1 2 3 4 5 6 7 8 9 10 do { while(turn != 0); // 내차례(turn == 0)일 때까지 대기한다. critical section turn = 1; // 다른 프로세스 차례(turn == 1)로 만든다. // ... } while(1); turn이 내 차례이면 크리티컬 섹션에 들어간다. 문제점 교대로만 들어갈 수 있다. 그래서 어떤 프로세스가 한 번만 크리티컬 섹션에 들어갈 때에는 다른 프로세스가 여러번 들어가길 원한다고 해도 들어갈 수가 없게 된다. (Progress 조건에 부합하지 않게 된다.) 알고리즘 2 1 2 3 4 5 6 7 8 9 10 11 do { flag[me] = true; while(flag[other] == true); // 상대방의 플래그가 false일 때까지 대기한다. critical section flag[me] = false; // 내 작업이 끝났음을 알린다. // ... } while(1); flag를 만들어서 상대방 값을 확인하고 크리티컬 섹션에 들어간다. 문제점 두 프로세스 모두가 flag[me] = true 인 상태로 무한정 대기할 수 있다. 알고리즘 3 (Peterson\u0026rsquo;s Algorithm) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 do { flag[me] = true; // 크리티컬 섹션에 들어가겠다는 의사표명을 한다. turn = other; // 상대방의 턴으로 바꾼다. // 상대방이 의사를 표명했고, 상대방 턴일 때 대기한다. while(flag[other] == true \u0026amp;\u0026amp; turn = other); critical section flag[me] = false; // 내 작업이 끝났음을 알린다. // ... } while(1); turn과 flag를 둘 다 사용한다. 세 가지 조건을 모두 충족한다. 문제점: Busy Waiting(= Spin Lock) while(flag[other] == true \u0026amp;\u0026amp; turn = other)에서 계속 CPU와 메모리를 쓰면서 기다리게 된다. 이런 과정을 하드웨어적으로 수행할 수 있도록 지원한다면 간단하게 해결 가능하다. (1) lock의 값을 읽고 (2) lock의 값을 true로 설정하는 것을 한 번에 수행한다. 1 2 3 4 5 6 7 8 9 10 do { while(Test_and_set(lock)); // lock이 false이면 true로 설정하고 들어간다. critical section lock = false; // ... } while(1); 세마포어 세마포어(Semephores) 추상 자료형으로써, integer 값을 가지며 자원의 개수를 나타낸다. 두 가지 연산으로만 접근이 가능하다. 세마포어 S가 있을 때 (1) P(S) 연산: 자원을 가져간다. 1 2 while(S \u0026lt;= 0); // 자원이 없으면 기다린다. S--; (2) V(S) 연산: 자원을 내놓는다. 1 S++; Busy Waiting(= Spin Lock) 방식 크리티컬 섹션 문제를 세마포어로 해결하면\u0026hellip; 1 2 3 4 5 6 7 8 9 10 semaphore mutex; do { P(mutex); critical section V(mutex); //... } while(1); Block \u0026amp; Wakeup(= Sleep Lock) 방식 세마포어를 다음과 같이 정의한다. value, L → PCB → PCB → PCB \u0026hellip; 1 2 3 4 5 typedef struct { int value; // 세마포어 struct proces * L // 프로세스 대기(wait) 큐 } semaphore; Block() 그 프로세스를 suspend 시키고 PCB를 세마포어의 대기(wait) 큐에 넣는다. Wakeup(P) 프로세스 P를 wakeup 시키고 PCB를 준비(ready) 큐로 옮긴다. (1) P(S) 연산 1 2 3 4 5 6 S.value--; // 자원을 가져가기로 한다. if (S.value \u0026lt; 0) // 근데 자원이 없다. { add process to S.L // 대기 큐에 넣고 block(); // 대기한다. } (2) V(S) 연산 1 2 3 4 5 6 S.value++; // 자원을 내놓기로 한다. if (S.value \u0026lt;= 0) // 내놓아도 자원이 없다. 즉 자원이 없어서 잠들어 있는 프로세스가 있다. { remove process P from S.L // 대기 큐에서 빼서 Wakeup(P); // 깨운다. } 두 방식의 비교 일반적으로 Block \u0026amp; Wakeup이 좋다. 크리티컬 섹션의 길이가 긴 경우, 그동안 기다리지 않는 Block \u0026amp; Wakeup이 더 좋다. 하지만 크리티컬 섹션의 길이가 짧은 경우에는, block과 wakeup 상태를 바꾸는 데 오버헤드가 들기 때문에 Busy Wait가 더 좋을 수 있다. 세마포어의 종류 (1) Counting Semaphore 도메인이 0이상인 임의의 정수값이다. 자원을 카운팅하는 데 쓰인다. (2) Binary Semaphore(=mutex) 0과 1값만 가질 수 있는 세마포어이다. 주로 상호 배제 (lock/unlock)에 쓰인다. 교착상태와 기아 교착상태(Deadlock)\n둘 이상의 프로세스가 서로 상대방이 가진 자원을 얻기 위해 무한히 기다리는 현상이다. 예: Dining-Philosophers problem 해결책: 자원을 얻을 수 있는 순서를 설정한다. 기아(Starvation)\n프로세스가 suspend 당하고 세마포어 큐에서 영원히 나갈 수 없는 현상을 말한다. 고전적인 동기화 문제들 Bounded-Buffer problem (Producer-Consumer problem) 공유되는 메모리의 버퍼 크기가 유한한 환경에서, 자원을 생산하는 Producer와 사용하는 Consumer가 여럿일 때 발생하는 문제이다. 공유 데이터 버퍼 및 버퍼 조작 변수(empty/full 버퍼의 시작 위치) 동기화 변수 mutex: 상호 배제 필요 동일 버퍼에 작업하지 않기 위해 Binary Semaphore가 필요하다. full/empty: 가용 자원을 세는 것이 필요 한정적인 버퍼가 모두 사용되었을 때를 대비해서 Counting Semaphore가 필요하다. 1 semaphore full = 0, empty = n, mutex = 1; Producer 코드 1 2 3 4 5 6 7 8 9 10 11 12 do { produce an item in x // 자원 x를 만든다. P(empty); // 자원을 만들만한 빈 버퍼가 있는지 확인하고 획득한다. P(mutex); // 해당 버퍼에 lock을 건다. add x to buffer V(mutex); // 버퍼에 lock을 푼다. V(full); // 생산된 자원의 개수를 늘린다. } while(1); Consumer 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 do { P(full); // 자원이 만들어진 버퍼가 있는지 확인하고 획득한다. P(mutex); // 해당 버퍼에 lock을 건다. remove an item from buffer to y V(mutex); // 버퍼에 lock을 푼다. V(empty); // 사용한 자원의 개수를 늘린다. consume the item in y } while(1); Readers and Writers problem 한 프로세스가 공유 데이터 DB를 Write 중일 떄는 다른 모든 프로세스가 접근할 수 없다. 하지만 Read는 여럿이서 동시에 해도 되는 경우에 발생하는 문제이다. 공유 데이터 DB 자체 readCount: 현재 DB에 접근 중인 Reader의 수 동기화 변수 mutex: 공유 데이터 readCount에 접근 제어를 위해 db: Reader와 Writer가 DB에 올바르게 접근하도록 하기 위해 1 2 3 4 int readCount = 0; DB 자체; semaphore mutes = 1, db = 1; Writer 코드 1 2 3 4 5 P(db); // 공유 데이터를 사용하기 위해 lock을 건다. writing DB V(db); // lock을 푼다. Reader 코드 1 2 3 4 5 6 7 8 9 10 11 P(mutex); // readCount를 사용하기 위해 lock을 건다. readCount++; // 읽기로 한다. if (readCount == 1) P(db); // 최초의 Reader라면 Write를 금하기 위해 공유 데이터에 lock을 건다. V(mutex); // readCount lock을 푼다. reading DB P(mutex); readCount--; if (readCount == 0) V(db); // 모든 Reader가 다 읽었으면 Writer가 쓸 수 있게 공유 데이터의 lock을 푼다. V(mutex); 기아(Starvation) 문제가 발생할 수 있다. Reader가 계속해서 들어오면 Writer는 영영 DB에 접근할 수 없다. Reader의 수를 제한해서 해결할 수 있겠다. Dining-Philosophers problem 생각하다가 배고프면 밥을 먹는 5명의 철학자들이 원탁에 둘러 앉았다. 젓가락을 양쪽 사람과 하나씩 공유하고 있을 때 발생하는 문제이다. 동기화 변수 1 2 // 1로 초기화되어 있다. 즉, 한 번에 한 명만 쓸 수 있다. semaphore chopstick[5]; Philosopher 코드 1 2 3 4 5 6 7 8 9 10 11 12 do { P(chopstick[i]); // 왼쪽 젓가락을 잡는다. P(chopstick[(i + 1) % 5]); // 오른쪽 젓가락을 잡는다. eat(); V(chopstick[i]); V(chopstick[(i + 1) % 5]); think(); }while(1); 교착상태(Deadlock) 문제가 발생할 수 있다. 모든 Philosopher가 동시에 배가 고파서 왼쪽 젓가락을 집은 경우. 아무도 식사를 할 수 없다. 해결 방법 (1) 5명 중에 배고픈 4명만 동시에 식탁에 앉을 수 있게 한다. (2) 젓가락 2개를 모두 집을 수 있을 때만 젓가락을 집을 수 있게 한다. (3) 짝수 Philosopher는 왼쪽, 홀수 Philosopher는 오른쪽 젓가락부터 집을 수 있게 한다. 동기화 변수 1 2 3 enum {thinking, hungry, eating} state[5]; semaphore self[5] = 0; // 젓가락 2개를 모두 집을 수 있는가 (처음은 권한 없음) semaphore mutex = 1; // Philosopher의 상태를 바꿀 수 있는 권한 Philosopher 코드 1 2 3 4 5 6 7 do { pickup(i); eat(); putdown(i); think(); } while(1); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void pickup(int i) { P(mutex); // 상태를 변경하기 위해 mutex에 lock을 건다. state[i] = hungry; test(i); V(mutex); // 상태 변경을 완료해서 mutex를 unlock 한다. P(self[i]); // 젓가락 2개를 집을 수 없다면 기다린다. 가능하면 lock을 건다. } void putdown(int i) { P(mutex); state[i] = thinking; test((i + 4) % 5); // 왼쪽 철학자에 대해 test를 해서 젓가락을 준다. test((i + 1) % 5); // 오른쪽 철학자에 대해 test를 해서 젓가락을 준다. V(mutex); } // 젓가락 2개를 모두 집을 수 있는지 테스트한다. void test(int i) { if (state[(i + 4) % 5] != eating \u0026amp;\u0026amp; // 왼쪽 철학자가 밥을 먹지 않고 state[i] == hungry \u0026amp;\u0026amp; // 내가 지금 배고프고 state[(i + 1) % 5] != eating) // 오른쪽 철학자가 밥을 먹지 않을 때 { state[i] = eating; V(self[i]); // 밥먹는 권한을 갖는다. unlock을 한다. } } 모니터 세마포어의 문제점 코딩하기 힘들다. 한번의 실수가 모든 시스템에 치명적인 영향을 준다. 정확성을 검증하는 것이 어렵다. 자발적 협력이 필요하다. 모니터(Monitor) 동시 수행중인 프로세스 사이에서 추상 데이터 형식의 안전한 공유를 보장하기 위해 만들어진, high-level synchronization construct이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 monitor monitor_name { // 공유 변수 shared variable declaration // 공유 변수에 접근할 수 있는 함수를 구현한다. procedure body P1 (...) { ... } procedure body P2 (...) { ... } procedure body P3 (...) { ... } // 초기화 함수 { initialization code } } 모니터 내에서는 한 번에 하나의 프로세스만 활동 가능하다. 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없다. 프로세스가 모니터 안에서 기다릴 수 있게 하기 위해서 condition variable을 사용한다. condition variable은 wait()과 signal() 연산으로만 접근 가능하다. wait() signal()로 빠져나갈 수 있을 때까지 계속 suspend되게 한다. signal() suspend된 프로세스 중에 하나의 프로세스가 빠져나갈 수 있게 한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다. Bounded-Buffer problem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 monitor bounded_buffer { int buffer[N]; condition full, empty; // 자신의 큐에 프로세스를 매달아서 wait() 혹은 signal()을 한다. void produce(int x) { if there is no empty buffer empty.wait(); // 비어 있는 버퍼를 줄서서 기다린다. add x to an empty buffer full.signal(); // 혹시 생성된 버퍼가 없어서 기다리는 프로세스가 있는지 알아보고 깨워준다. } void consume(int *x) { if there is no full buffer full.wait(); remove an item from buffer and store it to *x empty.signal(); } } Dining-Philosophers problem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 monitor dining_philosopher { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait(); // 밥 먹을 수 없으면 대기. } void putdown(int i) { state[i] = thinking; test((i + 4) % 5); // 왼쪽 철학자에게 젓가락을 준다. test((i + 1) % 5); // 오른쪽 철학자에게 젓가락을 준다. } // 젓가락 2개를 모두 집을 수 있는지 테스트한다. void test(int i) { if (state[(i + 4) % 5] != eating \u0026amp;\u0026amp; // 왼쪽 철학자가 밥을 먹지 않고 state[i] == hungry \u0026amp;\u0026amp; // 내가 지금 배고프고 state[(i + 1) % 5] != eating) // 오른쪽 철학자가 밥을 먹지 않을 때 { state[i] = eating; self[i].signal(); // 밥을 먹을 수 있게 한다. } } void init() { for (int i = 0; i \u0026lt; 5; i++) state[i] = thinking; } } // Each Philosopher: do { pickup(i); eat(); putdown(i); think(); } while(1); ","date":"2022-06-23T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-07/","title":"[OS] Chapter 7. 프로세스 동기화"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n프로그램 실행과 관련된 기계어 명령들 CPU 내에서 수행되는 명령: Add 명령 메모리 접근을 수행하는 명령: Load, Store 명령 메모리를 접근하는 명령 입출력을 동반하는 명령 → 운영체제를 통해서만 가능한 특권명령 사용자 프로그램이 수행되는 과정은 CPU 작업와 I/O 작업의 반복으로 구성된다.\nCPU 버스트: 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 단계 I/O 버스트: I/O 요청이 발생해서 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계 CPU 바운드 프로세스: I/O 작업이 거의 없어서 CPU 버스트가 길게 나타나는 프로세스이다. → 대화형 프로그램(interactive program) I/O 바운드 프로세스: I/O 요청이 빈번해서 CPU 버스트가 짧게 나타나는 프로세스이다. → 계산 위주의 프로그램 동일한 시스템 내부에서 CPU 바운드 프로세스와 I/O 바운드 프로세스가 함께 섞여서 실행되기 때문에 CPU 스케줄링이 필요하다.\n대부분의 프로세스는 짧은 CPU 바운드를 가진다. 따라서 I/O 바운드 프로세스의 우선순위를 높여주면, 대화형 프로세스의 빠른 응답성 제공과 I/O 장치의 이용률을 높일 수 있다. CPU 스케줄러 CPU 스케줄러(scheduler) 준비 상태에 있는 프로세스들 중에서 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다. CPU 스케줄러가 호출되는 경우 (1) Running → Blocked : I/O 요청하는 시스템 콜 (2) Running → Ready : 타이머 인터럽트 (3) Blocked → Ready : I/O 완료로 인터럽트 (우선순위가 높아서 바로 CPU를 얻는 경우) (4) Terminate 비선점형(nonpreemptive) 방식 프로세스가 CPU를 스스로 반납하기 전까지는 빼앗기지 않는다. (1), (4) 선점형(preemptive) 방식 프로세스에게 할당된 CPU를 강제로 빼앗을 수 있다. (2), (3) 디스패처 디스패처(dispatcher) CPU 스케줄러가 어떤 프로세스에게 CPU를 할당할지 결정하고 나면, 실제로 CPU를 이양하기 위해 환경설정을 하는 운영체제의 코드를 말한다. 현재 수행 중이던 프로세스의 문맥(context)을 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한다. 그리고 시스템 상태를 사용자 모드로 전환해서 사용자 프로그램에게 CPU의 제어권을 넘긴다. 디스패치 지연시간(dispatch latency) 디스패쳐가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 말한다. 이것은 대부분 문맥교환의 오버헤드에 해당한다. 스케줄링의 성능 평가 시스템 관점 (1) CPU 이용률(CPU utilization) 전체 시간에서 CPU가 일을 한 시간의 비율 (2) 처리량(throughput) 주어진 시간 동안 프로세스 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스의 개수) 사용자 관점 (3) 소요 시간(turnaround time) 프로세스가 CPU를 요청한 시점 ~ CPU 버스트를 완료하는데까지 걸린 시간 (4) 대기 시간(waiting time) CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합 시분할 시스템에서는 타이머 인터럽트를 사용하므로, 한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러번 발생할 수 있다. (5) 응답 시간(response time) 프로세스가 준비 큐에 들어온 후 ~ 첫 번째 CPU를 획득하기까지 기다린 시간 타이머 인터럽트가 빈번히 발생할 수록 처음 CPU를 획득하기까지 걸리는 시간은 줄어들겠다. 스케줄링 알고리즘 선입선출(First-Come First-Served; FCFS) 스케줄링 준비 큐에 도착한 시간 순서대로( CPU를 먼저 요청한 프로세스에게) CPU를 할당하는 방식이다. 단점 콘보이 현상(Convoy effect) CPU 버스트가 긴 작업이 먼저 들어오면, CPU를 잠깐만 사용하면 준비 큐를 떠나 I/O작업을 수행할 수 있는 다수의 프로세스들이 계속 기다려야 하는 상황이 생긴다. 먼저 도착한 프로세스의 CPU 버스트 기간에 따라 평균 대기시간이 크게 달라진다. 평균 대기시간(waiting time)이 길어진다. I/O 장치의 이용률이 하락한다. 프로세스 CPU 버스트 시간 $P_1$ $12$ $P_2$ $3$ $P_3$ $3$ 대기 시간: $P_1 = 0$, $P_2 = 12$, $P_3 = 15$ 평균 대기 시간: $(0 + 12 + 15) / 3 = 9$ 최단작업 우선(Shortest-Job First; SJF) 스케줄링 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다. 선점형(Shortest Remaining Time First; SRTF) 과 비선점형 방식으로 구현할 수 있다. 선점형의 경우, 어떤 프로세스가 CPU를 할당받고 수행 중이더라도, CPU 버스트 시간이 더 짧은 프로세스가 도착하면 빼앗기는 방식이다. 프로세스들이 준비 큐에 도착하는 시간이 불규칙한 환경에서는 선점형 방식이 평균 대기시간을 최소화하는 최적의 알고리즘이 된다. 프로세스 도착 시간 CPU 버스트 시간 $P_1$ $0$ $14$ $P_2$ $4$ $8$ $P_3$ $8$ $2$ $P_4$ $10$ $8$ 비선점형 방식 평균 대기시간: $(0 + 12 + 6 + 14) / 4 = 8$ 선점형 방식 평균 대기시간: $(18 + 2 + 0 + 4) / 4 = 6$ 장점 평균 대기시간을 가장 짧게 하는 최적 알고리즘(optimal algorithm)이다. 단점 기아 현상(starvation) 이 발생한다. CPU 버스트가 짧은 프로세스가 계속 도착하면 CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못하는 것이다. CPU 버스트 시간을 미리 예측할 수 없다. CPU 버스트 시간 예측 방법 과거의 CPU 버스트 시간을 통해 계산된다. 더 오래된 과거일 수록 그 영향력이 적어지도록 반영한다. $$ T_n+1 = \\alpha t_n + (1 - \\alpha)T_n$$ $t_n$은 $n$번째 실제 CPU 버스트 시간이고, $T_n$은 $n$번째 CPU 버스트의 예측시간이다. $\\alpha$는 $0 ~ 1$ 사이의 상수로 위의 두 요소를 어느 정도씩 반영할지 조절하는 매개변수이다. 우선순위(priority) 스케줄링 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다. 우선순위 값(priority number)은 그 값이 작을수록 우선순위가 높다. SJF 스케줄링은 우선순위 스케줄링의 일종이라고 볼 수 있다. 선점형과 비선점형 방식으로 구현할 수 있다. 단점 기아 현상이 발생할 수 있다. 해결 방안: 노화(aging) 기법 기다리는 시간이 길어지면 우선순위를 조금씩 높여서 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법이다. 라운드 로빈(Round Robin) 스케줄링 각 프로세스가 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간( 할당시간; timequantum)을 주는 방식이다. 할당 시간이 너무 길면, FCFS와 같은 결과를 나타내며, 할당 시간이 너무 짧으면, 프로세스가 빈번하게 교체되어 문맥교환의 오버헤드가 커진다. 일반적으로 $10$ ~ $100 ms$(밀리초) 정도로 설정한다. 타이머 인터럽트를 사용해서 CPU를 회수한다. SJF보다 평균 대기 시간은 길지만, 응답시간은 더 짧다. 장점 CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록한다. (공정하다) 대화형 프로세스의 빠른 응답시간을 보장한다. $n$개의 프로세스가 준비 큐에 있고 할당 시간이 $q$라고 하면, 모든 프로세스는 $(n-1)q$시간 이내에 적어도 한 번은 CPU를 할당 받는다. 다단계 큐(muti-level queue) 준비 큐를 여러 개로 분할해서 관리하는 방식이다.\n일반적으로, 전위 큐(foreground queue)와 후위 큐(background queue)로 분할하여 운영한다.\n전위 큐: 대화형 작업을 담는다. 라운드 로빈 스케줄링을 사용한다. 후위 큐: 계산 위주의 작업을 담는다. FCFS 스케줄링을 사용한다. 어느 큐에게 먼저 CPU를 할당할 것인가?\n고정 우선순위 방식(fixed priority scheduling) 큐에 고정적인 우선순위를 적용한다. 항상 전위 큐에 있는 프로세스에게 CPU가 먼저 할당된다. 타임 슬라이스(time slice) 방식 각 큐에 CPU 시간을 적절한 비율로 할당한다. 예를 들면 전위 큐는 80%, 후위 큐는 20%이다. 다단계 피드백 큐(multi-level feedback queue) 준비 큐를 여러 개로 둔다는 점은 다단계 큐와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능하다는 점이 다르다. 대표적인 방식은, 라운드 로빈을 사용하면서 할당시간이 5, 10인 준비 큐가 있고, 그다음에 FCFS 준비 큐가 있는 것이다. 프로세스의 CPU 작업시간을 다단계로 분류함으로써, 작업시간이 짧은 프로세스일 수록 더 빠른 서비스가 가능해지며, 작업시간이 긴 프로세스에 대해서는 문맥교환 없이 CPU 작업에만 열중할 수 있는 FCFS 방식을 채택할 수 있다. 정의 요소들 큐의 수 각 큐의 스케줄링 알고리즘 프로세스를 상위 큐로 승격시키는 기준 프로세스를 하위큐로 강등시키는 기준 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준 다중처리기(multi-processor system) 스케줄링 CPU가 여러 개인 시스템인 다중처리기 시스템에서 사용하는 스케줄링이다. Homogeneous processor인 경우 큐에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 한다. 특정 CPU에서 수행되어야 하는 프로세스가 있는 경우 각 CPU별로 줄 세우기를 할 수 있겠다. 하지만 그렇게 되면 특정 CPU에 작업이 편중되는 현상이 발생할 수 있다. 그래서 각 CPU별로 부하가 적절히 분산되도록 하는 부하균형(load balancing) 메커니즘을 필요로 한다. 대칭형 다중처리(symmetric multi-processing; SMP) 각 CPU가 알아서 스케줄링을 결정하는 방식이다. 비대칭형 다중처리(asymmetric multi-processing) 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고, 나머지 CPU는 거기에 따라 움직이는 방식이다. 실시간 스케줄링 작업의 데드라인이 정해져 있어서 그 안에 반드시 처리해야하는 실시간 시스템(real-time system)에 사용하는 방식이다. 경성 실시간 시스템(hard real-time system): 데드라인 안에 반드시 끝내야 하는 시스템 연성 실시간 시스템(soft real-time system): 데드라인을 지키지 못했다고 해서 위험한 상황이 발생하는 건 아닌 시스템 EDF(Earlist Deadline First) 스케줄링을 주로 사용한다. 데드라인이 얼마 남지 않은 요청을 먼저 처리하는 것이다. 스레드 스케줄링 Global scheduling Kernel level thread의 경우 일반적인 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 스레드를 스케줄링할지 결정한다. Local scheduling User level thread의 경우 사용자 수준의 스레드 라이브러리에 의해 어떤 스레드를 스케줄링할지 결정한다. 스케줄링 알고리즘의 평가 (1) 큐잉모델(queueing model) 이론가들이 수행하는 방식이다. 확률 분포로 주어지는 도착률(arrival rate)과 처리율(service rate)을 가지고 수학적 계산을 통해 각종 성능지표를 확인한다. (2) 시뮬레이션(simulation) 구현가들이 수행하는 방식이다. 실제로 코드를 수정해서 커널을 컴파일한 후 수행시켜보고 실행시간을 측정한다. (3) 구현 및 실측(implementation \u0026amp; measurement) 가상으로 CPU 스케줄링 프로그램(모의 프로그램)을 작성해서 어떤 결과가 나오는지 확인하는 방식이다. 입력값은 가상일 수도 있고, 실제 시스템에서 추출한 입력값(트레이스; trace)일 수도 있다. ","date":"2022-06-16T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-06/","title":"[OS] Chapter 6. CPU 스케줄링"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n프로세스 프로세스(process) 실행 중인 프로그램(program in execution)을 뜻한다. 프로세스의 문맥(context) 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보이다. 프로세스가 CPU를 다시 획득해서 명령 수행을 재개하려면 문맥이 필요하다. 종류 내용 하드웨어 문맥 프로그램 카운터값 각종 레지스터에 저장하고 있는 값 프로세스의 주소 공간 코드, 데이터, 스택으로 구성된 자신만의 독자적 주소 공간 커널 상의 문맥 PCB 커널 스택 프로세스의 상태 상태 설명 준비\n(ready) 메모리를 획득해서, CPU만 보유하면 당장 명령을 실행할 수 있는 상태 실행\n(running) CPU를 보유하고 기계어 명령을 실행하고 있는 상태 봉쇄\n(blocked, wait, sleep) CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태 (예: 입출력 작업 진행 중) 시작\n(new) 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태 완료\n(terminated) 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태 중지\n(suspended, stopped) (이어서\u0026hellip;) 프로세스 제어블록 프로세스 제어블록(Process Control Block; PCB) 운영체제가 프로세스들을 관리하기 위해 프로세스의 정보를 담는 커널 내의 자료구조이다. 종류 내용 운영체제가 관리상 사용하는 정보 프로세스 번호 : 프로세스 고유 번호 프로세스 상태 : 준비, 실행, 봉쇄 등의 상태 스케줄링 정보, 우선순위 : CPU 스케줄링을 위해 CPU 수행 관련 하드웨어 값 프로그램 카운터 값 : 다음에 수행할 명령의 위치 레지스터 값 : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지 메모리 관련 코드, 데이터, 스택의 위치 정보 : 메모리 할당을 위해 파일 관련 프로세스가 오픈한 파일 정보 문맥 교환 문맥 교환(context switch) 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 것이다. 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 작업이 이루어진다. 한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록에 기록되어 있다. 문맥 교환에 소요되는 시간은 오버헤드이기 때문에 적절한 타이머의 CPU 할당 시간을 정하는 것이 중요하겠다. 발생하는 경우 타이머 인터럽트 발생 실행 중이던 프로세스의 입출력 요청 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우 문맥교환이 아닌 경우 사용자 프로세스 A의 인터럽트 또는 시스템 콜에 의해 사용자 모드에서 커널 모드로 실행 모드가 바뀐다. 커널 모드에서 인터럽트 처리루틴 또는 시스템 콜 함수를 실행한다. 그리고 다시 문맥 교환 없이 사용자 프로세스 A의 사용자 모드로 되돌아 온다. 상태 관리 큐들 커널의 주소 영역 중 데이터 영역에 다양한 큐(queue)를 두어 프로세스들의 상태를 관리한다. 이름 설명 작업 큐\n(job queue) 시스템 내의 모든 프로세스를 관리하기 위한 큐 가장 넓은 개념이다. 준비 큐\n(ready queue) CPU를 할당 받기 위해 준비 상태에 있는 프로세스들을 줄세우기 위한 큐 장치 큐\n(device queue) 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 있는 큐 (예: 디스크 입출력 서비스를 받기 위해 기다리는 프로세스들) 자원 큐 소프트웨어 자원을 기다리는 경우 (예: 공유 데이터에 대한 접근 제어를 위한 큐) 스케줄러들 스케줄러(scheduler) 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드이다. 스케줄러 설명 장기 스케줄러 = 작업 스케줄러 (job scheduler) 어떤 프로세스를 준비 큐에 진입시킬지 결정한다. 즉, 프로세스에게 메모리를 할당하는 문제에 관여하므로, 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절하는 역할을 한다. 현대의 시분할 시스템에서는 장기 스케줄러가 없고, 실행되면 무조건 ready 상태로 된다. degree of multiprogramming은 중기 스케줄러가 대신한다. 단기 스케줄러 = CPU 스케줄러 어떤 프로세스를 실행 상태로 만들지 결정한다. 즉, 프로세스에게 CPU를 할당하는 문제에 관여한다. 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다. 중기 스케줄러 = swapper 여유공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫒아낸다. (스왑 아웃; swap out) 0순위로 스왑 아웃되는 프로세스는 봉쇄 상태에 있는 프로세스들이다. (이어서\u0026hellip;) 중기 스케줄러의 등장으로 프로세스의 상태가 추가된다. 중지(suspended, stopped) 외부적인 이유로 프로세스의 수행이 정지된 상태이다. 메모리를 조금도 보유하지 않고 디스크에 통째로 스왑 아웃된 상태로 존재한다. 예: 사용자가 프로그램을 일시 정지한 경우, 메모리에 너무 많은 프로세스가 올라와 있어서 시스템이 프로세스를 잠시 중단시킨 경우 중지준비(suspended ready) 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되었을 때 중지봉쇄(suspended block) 봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되었을 때 봉쇄: 자신이 요청한 event가 만족되면 Ready 상태가 된다. 중지: 외부에서 resume해주어야 Active 된다. 스레드 스레드(thread; lightweight process) CPU를 수행하는 단위 스레드가 가지고 있는 것 구분 내용 스레드가 독자적으로 갖고 있는 것들 = CPU 수행을 위한 것들 프로그램 카운터 값 레지스터 값 스택 스레드가 동료 스레드와 공유하는 부분 코드 영역\n데이터 영역 운영체제 자원들 다중 스레드의 장점 응답성(Responsiveness) 하나의 스레드가 봉쇄 상태인 동안(예: 웹 페이지에서 네트워크를 통해 이미지를 불러온다)에도 동일한 프로세스 내 다른 스레드가 실행(예: 이미지는 나중에 출력하고, 나머지 웹 페이지를 화면에 출력한다)되어 작업을 처리할 수 있다. 자원 공유(Resource sharing) 하나의 프로세스 내에서 CPU 수행 단위만 여러개(스레드를 여러개)두게 되면 서로 자원을 공유하므로 효율적으로 사용할 수 있다. 경제성(Economy) 프로세스를 하나 만드는 것보다 스레드를 하나 만드는 것이 오버헤드가 적다. 프로세스 간 문맥교환보다 스레드 간 문맥 교환이 오버헤드가 적다. 멀티 프로세서 환경에서의 활용(Utilization of Multi Processor Architectures) CPU가 여러개인 컴퓨터에서는 병렬성을 높일 수 있다. 스레드의 구현 커널의 지원을 받는 스레드(kernel level thread) 운영체제 커널이 스레드가 여러개 있다는 사실을 알고 있다. 라이브러리의 지원을 받는 스레드(user level thread) 운영체제가 스레드의 존재를 모르고, 사용자의 프로세스가 직접 스레드를 관리한다. 실시간(real-time) 기능을 지원하는 스레드 프로세스의 생성 프로세스의 생성 (process creation) 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음 부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성한다. 각각을 부모 프로세스, 자식 프로세스라고 하며, 트리와 같은 계층 구조을 형성하게 된다. 생성된 프로세스가 자원을 획득하는 방법 경우 1. 운영체제로 부터 직접 할당받는다. 경우 2. 부모 프로세스와 자원을 공유한다. (모든 자원을 or 일부를 or 공유하지 않음) 생성된 프로세스가 수행(execution)되는 방법 경우 1. 부모와 자식이 공존하며 수행된다. 경우 2. 자식이 종료(terminate)될 때까지 부모 프로세스가 기다린다(wait). 프로세스와 관련된 시스템 콜들 fork() 시스템 콜 프로세스 ID를 제외한 부모 프로세스의 모든 내용을 그대로 복제해서 자식 프로세스를 생성한다. 프로그램 카운터 값도 복제되므로, 부모 프로세스가 실행한 그 다음 위치 부터 실행하게 된다. 자식 프로세스는 자신만의 독자적인 주소 공간을 갖지만, 처음에 내용은 부모 프로세스의 내용을 그대로 복사해서 생성한다. 구분하는 법: fork() 함수의 결괏값이 양수이면 부모 프로세스이고, 0이면 복제된 자식 프로세스이다. exec() 시스템 콜 프로세스의 주소 공간을 완전히 새로운 프로그램으로 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행을 시작하도록 한다. wait() 시스템 콜 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 한다. 부모 프로세스와 자식 프로세스 간의 동기화(synchronization)가 가능해진다. 프로세스가 종료되는 방법 경우 1. 자발적 종료 exec() 시스템 콜로 운영체제에게 자신이 종료됨을 알린다. 프로그래머가 명시적으로 호출하지 않아도 컴파일러가 자동으로 삽입해서 프로세스의 종료 직전에 호출한다. 경우 2. 비자발적 종료 abort() 시스템 콜로 부모 프로세스가 자식 프로세스의 수행을 강제로 종료 시킨다. (1) 자식 프로세스가 한계치를 넘어서는 자원을 요구할 때 (2) 자식 프로세스의 작업이 더 이상 필요하지 않을 때 (3) 부모 프로세스가 종료될 때. 부모 프로세스가 종료될 경우에는 자식 프로세스들을 연쇄적으로 종료 시킨 후에야 본인이 종료될 수 있다. 사용자가 키보드로 kill, break 등을 친 경우. 프로세스 간의 협력 프로세스는 독립적인 주소 공간을 가지기 때문에 각자 독립적인 관계가 된다. 하지만 경우에 따라서는 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있다. 프로세스 간 협력 매커니즘 (Inter-Process Communication; IPC) 1. 메시지 전달 방식(message passing) 공유 데이터를 일절 사용하지 않고, 메시지를 주고받으면서 통신하는 방식이다. 메시지는 시스템 콜 방식으로 운영체제의 커널에게 요청해서 주고받는다. (1) 직접 통신(direct communication) 통신하려는 프로세스의 이름을 명시적으로 표시한다. 예: send(P, message), receive(Q, message) (2) 간접 통신(indirect communication) 메일박스(mail box) 또는 포트(port)를 통해 메시지를 간접적으로 전달한다. 예: send(M, message), receive(M, message) 2. 공유 메모리 방식(shared memory) 프로세스들이 주소 공간의 일부를 공유하는 방식이다. ","date":"2022-06-09T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-05/","title":"[OS] Chapter 5. 프로세스 관리"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n프로그램의 주소 영역 (1) 코드(code) CPU에서 수행할 수 있는 기계어 명령(machine instruction)을 저장하는 부분. (2) 데이터(data) 전역 변수(global variable) 등, 프로그램이 사용할 데이터를 저장하는 부분. (3) 스택(stack) 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 부분. 프로그램이 실행되었을 때, 프로그램의 주소 영역 중에서 당장 실행에 필요한 부분만 메모리에 올려놓고, 나머지 부분은 메모리의 연장 공간으로 사용되는 스왑 영역에 내려놓는다. 프로그램은 각각 독자적으로 주소 공간을 가지는 데, 이것을 가상 메모리(virtual memory) 혹은 논리적 메모리(logical memory) 라고 한다. 커널의 주소 영역 커널도 주소 공간을 가지고 있다. (1) 코드(code) 자원을 관리하기 위한 코드. 사용자에게 편리한 인터페이스를 제공하기 위한 코드. 시스템 콜, 인터럽트를 처리하기 위한 코드. (2) 데이터(data) 각종 자원을 관리하기 위한 자료구조가 저장된다. CPU나 메모리같은 하드웨어 자원을 관리하기 위한 자료구조(큐 등), PCB. (3) 스택(stack) 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 부분. 각 프로세스 마다 별도의 스택을 두어서 관리한다. 프로그램 수행중에 다른 함수호출이 이루어졌다 → 복귀 정보는 프로그램의 스택에 담긴다. 인터럽트로 CPU의 수행 주체가 운영체제로 바뀌었다. → 복귀 정보는 PCB에 담긴다. 커널의 코드가 수행되던 중간에 다른 함수호출이 이루어졌다. → 복귀 정보는 커널의 스택에 담긴다. 사용자 프로그램이 사용하는 함수 프로그램이 사용하는 함수 (1) 사용자 정의 함수 프로그래머 본인이 직접 작성한 함수 (2) 라이브러리 함수 누군가 작성해 놓은 함수 (3) 커널 함수 운영체제 커널의 코드에 정의된 함수 인터럽트의 우선순위 더 높은 우선순위의 인터럽트가 발생하면 현재 처리 중이던 인터럽트 코드의 수행 지점을 저장하고 우선순위가 높은 인터럽트를 처리히게 된다. 프로세스의 두 가지 실행 상태 프로세스 A가 CPU에서 실행되고 있다. 자신의 주소 공간에 정의된 코드를 실행하였다. 사용자모드에서의 실행상태(user mode running) 라고 한다. 커널의 시스템 콜 함수를 실행하였다. 커널모드에서의 실행상태(kernel mode running) 라고 한다. ","date":"2022-06-02T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-04/","title":"[OS] Chapter 4. 프로그램의 구조와 실행"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n컴퓨터 시스템의 구조 컴퓨터 내 연산과 I/O 연산 컴퓨터 내에서 수행되는 연산 CPU 담당 CPU는 매 시점에 메모리에서 명령(instruction) 하나를 읽어서 수행한다. 프로그램 카운터(program counter) 라는 레지스터가 CPU가 어떤 명령을 수행할 지에 대한 주소를 알고 있다. CPU 옆에는 인터럽트 라인(interrupt line) 이 있다. 명령을 수행할 때마다 인터럽트 라인에 신호가 들어왔는지를 확인한다. 입출력 장치들의 I/O 연산 입출력 장치 컨트롤러 담당 장치 컨트롤러는 들어오고 나가는 데이터를 임시로 저장하기 위해 로컬버퍼(local buffer) 라는 작은 메모리를 가지고 있다. 인터럽트 운영체제의 커널이 인터럽트 처리를 위해 갖고 있는 것들 인터럽트 벡터(interrupt vector) 해당 인터럽트 처리루틴의 주소. 각 인터럽트 종류마다 번호를 정해 놓았다. 인터럽트 처리루틴(interrupt service routine) 혹은 인터럽트 핸들러(interrupt handler) 인터럽트가 들어왔을 때 처리해야 할 커널 함수. 인터럽트의 종류 (1) 하드웨어 인터럽트 장치 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 설정한다. (2) 소프트웨어 인터럽트(트랩) 소프트웨어가 CPU의 인터럽트 라인을 설정한다. 즉, CPU의 제어권이 사용자 프로세스로부터 운영체제로 이양된다. 예외 상황(exception) 비정상적인 작업을 시도(0으로 나누기)하거나 권한이 없는 작업(자신의 메모리 영역을 벗어난 접근)을 시도할 때 이에 대한 처리를 하기 위해 발생시키는 인터럽트. 시스템 콜(system call) 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하기 위해 발생시키는 인터럽트. 운영체제는 인터럽트가 발생했을 때만 CPU의 제어권을 점유한다.\n프로세스 제어블록 프로세스 제어블록(Process Control Block: PCB) 운영체제가 프로세스들을 관리하기 위해 프로세스의 정보를 담는 커널 내의 자료구조이다. CPU는 새로운 명령을 실행하면 레지스터에 데이터를 읽고 쓰면서 작업을 한다. 인터럽트가 발생하면 현재 실행되던 기존 레지스터 값들이 모두 날아가기 때문에, 현재 실행되던 프로세스의 상태를 저장해두어야 한다. 그래서 프로세스마다 PCB를 갖고 있고, 여기에는 실행 중이던 코드의 메모리 주소와 레지스터 값 등이 담긴다. 입출력 구조 (1) 동기식 입출력(synchronous I/O) 어떤 프로그램이 입출력 요청을 하면, 그 입출력 작업이 완료된 다음에야 다음 후속 작업을 할 수 있는 것이다. 이렇게 되면 한 입출력 작업이 끝날 때까지 CPU가 아무일도 하지 않게된다. 관리방법 1 운영체제는 프로그램을 몇 가지 상태로 나누고, 입출력 중인 프로그램를 봉쇄 상태(blocked state) 로 전환시킨다. 그리고 봉쇄 상태인 프로그램에게는 CPU를 할당하지 않고, 다른 프로그램에게 할당해준다. 관리방법 2 만약에 여러 프로그램의 입출력 요청이 여러번 있다면, 그 순서는 어떻게 지킬 것인가? 장치별로 큐(queue)를 두어서 요청한 순서대로 처리할 수 있도록한다. (2) 비동기식 입출력(asynchronous I/O) 입출력 연산이 끝나기를 기다리지 않고, CPU 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 것이다. 동기식 입출력 예시 디스크나 키보드에서 데이터를 읽어오는 경우의 동기식 입출력 예시\u0026hellip; 프로그램 A를 실행하던 중에, 디스크에서 데이터를 읽어오는 명령을 만나게 되면, 그 프로그램은 시스템 콜(소프트웨어 인터럽트) 을 통해 CPU에게 인터럽트를 발생시킨다. CPU는 인터럽트가 발생하면, 하던 일을 멈추고 현재 실행 중이던 프로그램의 상태를 PCB에 저장한다. 그리고 CPU의 제어권이 운영체제로 이양된다. 운영체제 커널에서 인터럽트 처리루틴을 찾아서 장치 컨트롤러에게 입출력 연산을 요청한다. 장치 컨트롤러가 물리적인 장치에서 로컬버퍼로 데이터를 읽어온다. (읽어오는 동안 해당 프로그램은 운영체제에 의해 봉쇄 상태로 설정되었으므로 CPU를 할당 받지 못한다.) (그동안 CPU는 다른 프로그램 B에게 할당된다.) 그러고 나서, 다 읽었다고 인터럽트를 발생시킨다. (하드웨어 인터럽트) 인터럽트 처리루틴에 의해서 요청한 데이터를 해당 메모리 영역으로 읽어오고, 봉쇄 상태를 해제한다. 그리고 다음 차례를 기다린다. PCB에 담긴 저장 상태를 레지스터로 복원해서 작업을 이어나간다. CPU 대신 메모리에 접근하는 DMA DMA(Direct Memory Access) CPU만이 메모리에 접근해서 연산을 처리할 수 있다. 하지만 이렇게 되면 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU 업무가 방해를 받게된다. 따라서 DMA라는 장치를 두어 로컬버퍼에서 메모리로 읽어오는 작업을 대행할 수 있게했다. DMA는 바이트(byte) 단위가 아니라 블록(block) 이라는 큰 단위로 데이터를 로컬버퍼에서 읽어온다. 그리고 나서 CPU에게 인터럽트를 발생시켜서 작업이 완료되었음을 알린다. 저장장치의 구조 주기억장치 휘발성(volatile) 보조기억장치 비휘발성(nonvolatile) 보조기억장치의 용도 (1) 파일 시스템(file system) 용 주기억장치의 내용은 전원이 꺼지면 모두 날아가므로, 전원이 나가도 유지할 정보를 저장하기 위해 사용한다. (2) 스왑 영역(swap area) 용 주기억장치의 크기가 한정적이기 떄문에, 주기억장치에는 당장 필요한 부분만 올려놓고 나머지는 디스크의 스왑영역에 내려놓는다. 스왑 아웃(swap out): 디스크에 내려놓는 일. 저장장치의 계층 구조 빠른 순서 레지스터 → 캐시 메모리 → 메인 메모리 → 마그네틱 디스크 → 광디스크 → 마그네틱 테이프 캐싱 기법 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장해서, 두 저장장치 사이의 속도를 완충하는 것이다. 하드웨어 보안 CPU가 수행하는 명령의 종류 (1) 일반 명령 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 명령들 (2) 특권 명령 보안이 필요한 명령 입출력 장치, 타이머 장치 등 각종 장치에 접근하는 명령. 하드웨어 보안을 위한 운영체제의 모드 (1) 사용자 모드(user mode) 일반 명령만 수행할 수 있다. (2) 커널 모드(kernel mode) 운영체제가 CPU의 제어권을 가지고 운영체제의 코드를 실행하는 모드이다. 이 모드에서는 모든 명령을 다 실행할 수 있다. 사용자 프로그램이 이상한 명령으로 다른 프로그램의 메모리 영역이나 파일 시스템에 접근하면 위험한 상황이 발생할 수 있다. 따라서 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행되도록 했다. 만약에 CPU의 제어권을 다른 프로그램이 갖고 있을 때 중요한 연산을 실행시켜버리면 어떡할까? CPU 내부에 모드 비트(mode bit) 를 두어서 사용자 프로그램을 감시하도록 했다. 모드 비트가 1이면 사용자 모드이고, 0이면 커널 모드이다. 그래서 CPU는 보안과 관련된 명령을 수행하기 전에 모드 비트를 살펴보고 커널 모드일 때만 그 명령을 수행한다. 메모리 보안 메모리 보안을 위한 2개의 레지스터 (1) 기준 레지스터(base register) 해당 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다. (2) 한계 레지스터(limit register) 해당 프로그램이 합법적으로 접근할 수 있는 메모리의 범위를 보관한다. 따라서 메모리 접근 연산이 있을 때마다, \u0026lsquo;기준 레지스터 ~ 기준 레지스터 + 한계 레지스터\u0026rsquo;의 범위에 있는지를 체크해서 보안을 한다. 이것은 프로그램이 연속적으로 메모리에 위치한다는 것을 가정한 것이다. 페이징과 같이 여러영역에 나뉘어 위치할 경우에는 다른 메모리 관리 기법이 필요하다. 이것은 다음에 살펴본다. CPU 보호 타이머 CPU가 하나의 프로그램에 의해서 독점되는 것을 막기 위해, 운영체제는 타이머(timer)라는 하드웨어를 사용한다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜서 운영체제가 CPU의 제어권을 획득할 수 있도록 한다. 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용한다. 로드 타이머(load timer) 타이머의 값을 세팅하는 명령이다. 이것은 특권명령이다. ","date":"2022-06-02T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-03/","title":"[OS] Chapter 3. 컴퓨터 시스템의 동작 원리"},{"content":" 운영체제와 정보기술의 원리 강의을 듣고 공부한 노트입니다.\n운영체제의 정의 운영체제란?\n사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어이다. 운영체제도 하나의 소프트웨어이기 때문에 컴퓨터 전원이 켜짐과 동시에 메모리에 올라간다.\n모두 다 올라가면 메모리 공간의 낭비가 심하기 때문에 항상 필요한 부분만을 올리고, 나머지는 필요할 때 메모리로 올린다. 여기서 항상 필요한 부분을 커널(kernel) 이라고 한다. 운영체제의 기능 (1) 컴퓨터 시스템 내의 자원(resource)을 효율적으로 관리하는 것 여기서 자원이란, 하드웨어인 CPU, 메모리, 하드디스크 등과 소프트웨어 자원까지를 통칭하는 것이다. (2) 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하는 것 편리한 인터페이스 제공 (3) 사용자와 운영체제 자신을 보호하는 것 악의성 프로그램이 사용자의 사적인 파일에 접근하는 것을 막는 등의 일을 한다. 운영체제의 분류 동시 작업을 지원하는가? (1) 단일작업(single tasking) 용 운영체제 한 번에 하나의 프로그램만 실행시킬 수 있다. (2) 다중작업(multi tasking) 용 운영체제 동시에 2개 이상의 프로그램을 처리할 수 있다. 즉, 인터넷과 문서작성을 동시에 띄워놓고 할 수 있다. 다중작업과 유사한 의미의 용어들\u0026hellip; 시분할 시스템(time sharing system) CPU의 작업 시간을 여러프로그램이 나누어서 쓰는 것이다. 짧은 시간 규모로 여러 프로그램들이 CPU에서 번갈아 실핼되면 사용자는 동시에 실행되는 것처럼 보인다. 다중 프로그래밍 시스템(multi-programming system) 메모리 공간을 분할해서 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템이다. 대화형 시스템(interactive system) 사용자의 키보드 입력 결과를 곧바로 화면에 보여주는 시스템이다. 다중작업과 비교되는 용어\u0026hellip; 다중 처리기 시스템(multi-processor system) 하나의 컴퓨터 안에 CPU가 여러개 설치된 경우이다. 다중 사용자를 지원하는가? (1) 단일 사용자용 운영체제 한 번에 한 명의 사용자만이 사용하도록 허용하는 운영체제이다. 예: Windows (2) 다중 사용자용 운영체제 여러 사용자가 동시에 접속해 사용할 수 있도록 하는 운영체제이다. 예: 서버 작업을 처리하는 방식에 따라 (1) 일괄처리(batch processing) 작업을 모아서 일정량이 쌓이면 한꺼번에 처리한다. 예: 초창기 컴퓨터의 펀치 카드(punch card) (2) 시분할(time sharing) 방식 작업을 짧은 시간 단위로 번갈아가며 처리한다. (3) 실시간(real time) 운영체제 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템에서 사용한다. 경성(hard) 실시간 시스템 주어진 시간을 지키지 못할 경우 매우 위험한 결과를 초래할 가능성이 있는 경우. 예: 로켓, 원자로 제어. 연성(soft) 실시간 시스템 정해진 시간 단위로 전달되어야 올바른 기능을 수행할 수 있는 경우. 예: 멀티미디어 스트리밍 시스템. 운영체제의 예 MS Windows GUI 기반 플러그 앤 플레이(plug and play) 새로운 하드웨어를 시스템에 장착하면 운영체제가 자동으로 하드웨어를 감지하여 그에 맞게 설정한다. 유닉스 대부분의 코드가 C언어로 작성되었다. 이식성(portability)이 좋다. 운영체제 커널의 크기가 작다. 소스 코드가 공개된다. 그래서 여러 집단에서 개발한 다양한 종류가 있다. 운영체제의 자원 관리 기능 CPU 자원 관리 : CPU 스케줄링(CPU scheduling) 매 시점 어떤 프로세스에게 CPU를 할당할 것인가? 선입선출, 라운드 로빈, 우선순위 스케줄링\u0026hellip; 메모리 자원 관리 고정분할(fixed partition) 방식, 가변분할(variable partition)방식, 가상메모리(virtual memory) 방식\u0026hellip; 주변장치 및 입출력 장치 자원 관리 인터럽트(interrupt) 를 통해 관리가 이루어진다. 주변장치들은 CPU의 서비스가 필요해지면 신호(인터럽트)를 발생시켜서 서비스를 요청한다. 그러면 CPU가 잠시 하던 일을 멈추고 인터럽트에 의한 요청 서비스를 수행한다. ","date":"2022-06-02T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/os-it-principles-02/","title":"[OS] Chapter 2. 운영체제 개요"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n복소수 체의 구조를 가지는 수 집합은 실수 외에도 복소수(Complex number) 가 있다. 복소수는 다음과 같이 실수(Real number) 와 허수(Imaginary number) 의 독립된 2개 요소로 구성된 수 집합이다. 허수 허수 단위(Imaginary unit) $i$라는 기호를 사용한다. 제곱했을 때 $-1$이 되는 수를 말한다. $$ i^2 = -1 $$ 복소수는 실수부(Real part)와 허수부(Imaginary part)로 분리되어 있으며 허수부는 항상 $i$를 사용해서 표기한다. 그래서 실수부가 $a$, 허수부가 $b$인 복소수는 다음과 같이 표기한다. $$ a + bi $$ $$ (a, b) $$ 복소수의 구조 복소수의 덧셈 결합법칙 $(a, b) + ((c, d) + (e, f)) = ((a, b) + (c, d)) + (e, f)$ 교환법칙 $(a, b) + (c, d) = (c, d) + (a, b)$ 항등원 $(a, b) + (0, 0) = (a, b)$ 역원 $(a, b) + (-a, -b) = (0, 0)$ 복소수 덧셈 연산의 성질 연산의 성질 만족 여부 덧셈에 대해 닫혀 있음 O 덧셈에 대한 결합법칙이 성립함 O 덧셈에 대한 교환법칙이 성립함 O 덧셈에 대한 항등원의 존재함 O 덧셈에 대한 역원이 존재함 O 복소수의 곱셈 결합법칙 $(a, b) \\cdot ((c, d) \\cdot (e, f)) = ((a, b) \\cdot (c, d)) \\cdot (e, f)$ 교환법칙 $(a, b) \\cdot (c, d) = (c, d) \\cdot (a, b)$ 분배법칙 $(a, b) \\cdot ((c, d) + (e, f)) = (a, b) \\cdot (c, d) + (a, b) \\cdot (e, f)$ 항등원 $(a, b) \\cdot (1, 0) = (a, b)$ 복소수 곱셈 연산의 성질 연산의 성질 만족 여부 곱셈에 대해 닫혀 있음 O 곱셈에 대한 결합법칙이 성립함 O 곱셈에 대한 교환법칙이 성립함 O 덧셈과 곱셈에 대한 분배법칙이 성립함 O 곱셈에 대한 항등원의 존재함 O 곱셈에 대한 역원이 존재함 O (알아보자.) 복소수의 크기\n2차원 벡터와 동일하게 실수부와 허수부를 제곱해 더한 다음 제곱근을 취한다. 절댓값 기호를 써서 나타내며 복소수의 노름(Norm) 이라고도 부른다. $$ |(a, b)| = |(a, -b)| = \\sqrt{a^2 + b^2} $$ 단위 복소수(Unit complex number)\n크기가 1인 복소수이다. 켤레(Conjugate) 복소수 임의의 복소수를 $c$라고 하면 켤레 복소수는 $c^*$나 $\\bar{c}$로 표시한다. $$ c = a + bi = (a, b) $$ $$ c^* = a - bi = (a, -b) $$ 켤레 복소수는 다음곽 같은 성질이 있다. $$ (c^*)^* = c $$ $$ c^*c = c^* $$ $$ (c_1c_2)^* = c_2^*c_1^* $$ 어떤 복소수에 그 켤레 복소수를 곱하면 해당 복소수의 크기를 제곱한 값을 얻을 수 있다. $$ cc^* = (a + bi) \\cdot (a - bi) = a^2 + b^2 = |c|^2 $$ 그러면 켤레 복소수를 이용해서 복소수의 역원을 구해보자. $c$의 역원인 $c^{-1}$에 켤레 복소수를 곱해보자. $$ c^{-1} = \\frac{1}{c} = \\frac{c^*}{cc^*} $$ $$ (a + bi)^{-1} = \\frac{1}{(a + bi)} = \\frac{(a - bi)}{(a + bi)(a - bi)} = \\frac{(a - bi)}{(a^2 + b^2)} $$ 즉, $c$의 역원인 $c^{-1}$은 켤레 복소수에 복소수 크기에 관한 식으로 나타낼 수 있다. $$ c^{-1} = \\frac{c^*}{|c|^2} $$ 만약 단위 복소수라면? 단위 복소수는 크기가 $1$이므로, 곱셈역원은 바로 켤레 복소수가 된다. 복소평면 복소평면(Complex plane) 아래 그림 (a)와 같이 2차원 실벡터 공간 $\\mathbb{R}^2$의 벡터 $(a, b)$를 표현하기 위해서 서로 직교하는 $x$, $y$축을 사용한 것처럼, 복소수 역시 (b)와 같이 실수축과 허수축을 직각으로 교차시키는 방식으로 표현할 수 있다. 이것을 복소평면이라고 한다. 여기에 복소수 $(a, b)$를 평면 상에 다음과 같이 표현할 수 있겠다. 크기가 $1$인 단위 복소수를 모아 복소평면에서 표현하면 단위원이 만들어진다. 단위 복소수와의 곱 허수부가 $0$인 임의의 복소수 $(a, 0)$에 $i$라는 단위 복소수를 곱해보자. $$ (a + 0i) \\cdot (0 + i) = (0 + ai) = (0, a) $$ 이것을 평면 상에 나타내보면, $(0, a)$는 복소수 $(a, 0)$를 $90^{\\circ}$ 회전시킨 결과다. 이 결과에 또 다시 단위 복소수 $(0, i)$를 곱하면 계속 $90^{\\circ}$씩 회전한다. 따라서 임의의 복소수 $(a, b)$에 단위 복소수 $i$를 곱한 결과는 해당 복소수를 $90^{\\circ}$ 회전시킨 결과와 같다. $$ (a, b) \\cdot (0, 1) = (-b, a) $$ 이것은 Chapter 5에서 보았던 좌표 평면에서의 $90^{\\circ}$ 회전과 동일하다. 삼각함수 공식 $\\cos^2\\theta + \\sin^2\\theta = 1$를 이용해서 단위 복소수를 다음과 같이 표현할 수 있겠다. (참고로, 삼각함수를 사용하는 경우에는 허수의 $i$가 앞에 오는게 일반적이다.) $$ \\cos\\theta + i\\sin\\theta = (\\cos\\theta, \\sin\\theta) $$ 이렇게 삼각함수로 나타낸 단위 복소수에다가 임의의 복소수 $(x, y)$를 곱하면? $$ (\\cos\\theta, \\sin\\theta) \\cdot (x, y) = (x\\cos\\theta - y\\sin\\theta, y\\cos\\theta + x\\sin\\theta) $$ 이것은 Chapter 5에서 다룬 2차원 공간의 회전행렬 R에 2차원 벡터 $(x, y)$를 곱한 결과와 같다. $$ R = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix} $$ $$ \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} x\\cos\\theta - y\\sin\\theta \\\\ y\\cos\\theta + x\\sin\\theta \\end{bmatrix} $$ 따라서, 임의의 복소수에 단위 복소수를 곱하는 것은 복소평면에서의 회전변환을 의미한다. 이번에는 서로 다른 각을 갖는 2개의 복소수를 곱한 결과를 보자. $$ (\\cos\\alpha, \\sin\\alpha) \\cdot (\\cos\\beta, \\sin\\beta) = (\\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta, \\sin\\alpha\\cos\\beta + \\sin\\beta\\cos\\alpha) $$ Chapter 5에서 살펴본 삼각함수의 덧셈 정리를 사용하면 다음과 같이 정리할 수 있다. $$ (\\cos(\\alpha + \\beta), sin(\\alpha + \\beta)) $$ 따라서, 서로 다른 두 각을 회전 변환한 후 곱셈 연산을 하는 것은 두 각의 합을 회전 변환하는 것과 동일하다는 것을 알 수 있다. 이번에는 복소수 곱셈의 항등원인 $(1, 0)$의 의미를 생각해보자. 이것은 실수에서 곱셈의 항등원인 $1$과 동일하다. 복소수 $1$은 단위 복소수이다. 삼각함수로 표현하면 다음과 같이 각 $0^{\\circ}$에 대응하는 수다. $$ (1, 0) = (\\cos0^{\\circ}, \\sin0^{\\circ}) $$ 따라서, 곱셈의 항등원을 곱한다는 것은 아무런 변환가 일어나지 않는 $0^{\\circ}$의 회전 변환이라고 해석할 수 있다. 켤레 복소수의 회전 변환 복소평면에서 켤레 복소수를 시각화해보자. 임의의 복소수 $(a, b)$의 켤레 복소수 $(a, -b)$는 다음과 같다. 이것은 실수부 축($Re$)을 중심으로 서로 대칭된 형태이다. 이번에는 단위 복소수의 켤레 복소수를 생각해보자. 단위 복소수 $(\\cos\\theta, \\sin\\theta)$의 켤레 복소수는 $(\\cos\\theta, -\\sin\\theta)$이다. 여기에 삼각함수의 성질을 활용하면 켤레 복소수를 다음과 같이 나타낼 수 있다. $$ (\\cos\\theta, -\\sin\\theta) = (\\cos(-\\theta), \\sin(-\\theta)) $$ 즉, 단위 복소수가 실수 축에 위치한 $(1, 0)$을 각 $\\theta$만큼 회전한 수를 의미한다면, 켤레 복소수는 반대 방향인 $-\\theta$만큼 회전한 수를 의미한다. 따라서, 임의의 복소수 $(a, b)$에 단위 복소수를 곱하면 반시게 방향으로 회전이 발생하는데, 단위 복소수의 켤레 복소수를 곱하면 시계 방향의 회전이 발생한다. 단위 복소수와 켤레 복소수를 곱한 값은 복소수 크기의 제곱이므로 $1$이 된다. $$ c \\dot c^* = a^2 + b^2 = \\sin^2\\theta + \\cos^2\\theta = 1 $$ 이 식을 변환의 관점에서 보면 각 $\\theta$만큼 회전한 후 바로 $-\\theta$만큼 거꾸로 회전하는 변환을 의미한다. 이 결과는 아무런 변화 없는 $0^{\\circ}$ 회전 변환을 의미하므로 복소수 곱셈의 항등원 $(1, 0)$이 됨을 다시 한 번 확인할 수 있다. 복소수와 행렬의 관계 복소수를 수의 관점이 아닌 변환에 관점에서 보자. 2차원 복소펼면 상의 복소수를 2차원 행렬에 대응할 수 있다. 단위 복소수가 2차원의 회전 변환행렬과 같다고 해보자. $$ \\cos\\theta + i\\sin\\theta = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix} $$ 회전 변환행렬을 분리해 정리하면 다음과 같다. $$ \\cos\\theta + i\\sin\\theta = \\cos\\theta \\cdot \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} + \\sin\\theta \\cdot \\begin{bmatrix} 0 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}$$ 실수부에 대응하는 행렬을 $I$로 하고, 허수에 대응하는 행렬을 $J$라고 하자. $$ I = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} $$ $$ J = \\begin{bmatrix} 0 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} $$ 실수부 행렬 $I$는 항등행렬이지만, 허수부 행렬 $J$는 $90^{\\circ}$ 회전 변환행렬이다. $J$를 두 번 곱하면 $-I$가 나오며 이것은 $-1$에 대응한다. $$ J \\cdot J = \\begin{bmatrix} -1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\end{bmatrix} = -I $$ 이는 두 번 곱하면 $-1$이 나오는 허수 단위의 성질과도 일치한다. $$ i \\cdot i = -1 $$ ","date":"2022-05-02T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-14/","title":"[Game Math] Chapter 14. 복소수: 2차원 평면의 수"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n바운딩 볼륨 절두체 컬링에서 게임 오브젝트가 절두체 영역에 걸쳐 있다면 그려줘야한다. 따라서 이 문제를 해결하기 위해서 게임 오브젝트의 위치를 대상으로 하지 않고, 메시가 차지하는 영역을 감안해 절두체 컬링을 해야한다. 바운딩 볼륨(Bounding volume)\n메시가 차지하는 영역을 효과적으로 관리하기 위해 구(Sphere)나 박스(Box)같은 원시 도형(Primitive shape)을 사용한다. 이렇게 원시 도형으로 설정한 공간 데이터를 바운딩 볼륨이라고 한다. 구 바운딩 볼륨의 판정 바운딩 볼륨에서 가장 손쉽게 사용되는 것은 구(Sphere) 다. 어떤 점이 구의 외부에 있는지(a)와 두 구의 영역이 서로 떨어져 있는지(b)의 여부는 반지름을 이용해서 쉽게 알 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Sphere { public: FORCEINLINE constexpr Sphere() = default; FORCEINLINE constexpr Sphere(const Circle\u0026amp; InCircle) : Center(InCircle.Center), Radius(InCircle.Radius) {}; Sphere(const std::vector\u0026lt;Vector3\u0026gt;\u0026amp; InVertices); FORCEINLINE constexpr bool IsInside(const Vector3\u0026amp; InVector) const; FORCEINLINE constexpr bool Intersect(const Sphere\u0026amp; InCircle) const; public: Vector3 Center = Vector3::Zero; float Radius = 0.f; }; // (a) FORCEINLINE constexpr bool Sphere::IsInside(const Vector3\u0026amp; InVector) const { return ((Center - InVector).SizeSquared() \u0026lt;= (Radius * Radius)); } // (b) FORCEINLINE constexpr bool Sphere::Intersect(const Sphere\u0026amp; InCircle) const { float radiusSum = Radius + InCircle.Radius; return (Center - InCircle.Center).SizeSquared() \u0026lt;= (radiusSum * radiusSum); } 다음은 메시의 모든 영역을 감쌀 수 있는 구 영역을 생성하는 로직이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Sphere::Sphere(const std::vector\u0026lt;Vector3\u0026gt;\u0026amp; InVertices) { size_t cnt = InVertices.size(); if (cnt == 0) { return; } Vector3 sum; for (const auto\u0026amp; v : InVertices) { sum += v; } // 모든 점의 좌표를 더한 값을 수로 나눠서, 중점을 계산한다. Center = sum / (float)cnt; // 중점으로부터 모든 점의 거리를 구하고, 이 중에서 가장 큰 값을 반지름으로 한다. Radius = (*std::max_element(InVertices.begin(), InVertices.end(), [\u0026amp;](Vector3 const\u0026amp; lhs, Vector3 const\u0026amp; rhs) { return (Center - lhs).SizeSquared() \u0026lt; (Center - rhs).SizeSquared(); })).Size(); } 그렇다면 구를 이용해서 어떻게 절두체 컬링을 할 수 있을까? 앞서 보았던 평면의 방정식의 법선 벡터 $(a, b, c)$와 구의 중점 좌표의 내적값에 $d$값을 더한 값인 $p + d$가 양수이면 구는 평면의 바깥쪽에 위치한다. 거리에 해당하는 $|p + d|$가 반지름 $r$보다 작거나 같다면 구는 절두체 평면과 겹쳐져 있다. 나머지 경우라면 구는 절두체 안에 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 FORCEINLINE constexpr BoundCheckResult Frustum::CheckBound(const Sphere\u0026amp; InSphere) const { for (const auto\u0026amp; p : Planes) { // 양수이고, 반지름보다 크면 -\u0026gt; 절두체 밖에 있다. if (p.Distance(InSphere.Center) \u0026gt; InSphere.Radius) { return BoundCheckResult::Outside; } // 반지름보다 작거나 같으면 -\u0026gt; 절두체 평면에 걸쳐있다. else if (Math::Abs(p.Distance(InSphere.Center)) \u0026lt;= InSphere.Radius) { return BoundCheckResult::Intersect; } } // 나머지 -\u0026gt; 절두체 안에 있다. return BoundCheckResult::Inside; } 절두체 컬링에 사용하는 구 바운딩 볼륨은 로컬 좌표를 기준으로 생성된 데이터다. 하지만 우리는 절두체 컬링을 뷰 공간에서 진행하기 때문에 변환이 필요하겠다. 로컬 공간의 바운딩 볼륨 정보로 바로 절두체 컬링을 진행할 순 없을까? 클립 좌표는 다음과 같이 만들어진다. $\\vec{v_{clip}} = (P) \\cdot \\vec{v_{view}}$ 만약 $\\vec{v_{view}}$대신 $\\vec{v_{local}}$을 사용한다면? 다음과 같이 모델링 행렬과 뷰 행렬을 사용할 수 있다. $\\vec{v_{clip}} = (PVM) \\cdot \\vec{v_{local}}$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); // 절두체 컬링 테스트를 위한 통계 변수 size_t totalObjects = g.GetScene().size(); size_t culledObjects = 0; size_t intersectedObjects = 0; size_t renderedObjects = 0; for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 최종 행렬 계산 PVM Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); LinearColor finalColor = gameObject.GetColor(); // 최종 변환 행렬로부터 평면의 방정식과 절두체 생성 Matrix4x4 finalTransposedMatrix = finalMatrix.Transpose(); std::array\u0026lt;Plane, 6\u0026gt; frustumPlanesFromMatrix = { Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[1])), // up Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[1])), // bottom Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[0])), // right Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[0])), // left Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[2])), // far Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[2])), // near }; Frustum frustumFromMatrix(frustumPlanesFromMatrix); // 바운딩 영역을 사용해 절두체 컬링을 구현 Sphere sphereBound = mesh.GetSphereBound(); auto checkResult = frustumFromMatrix.CheckBound(sphereBound); if (checkResult == BoundCheckResult::Outside) { culledObjects++; continue; } else if (checkResult == BoundCheckResult::Intersect) { // 겹친 게임 오브젝트를 통계에 포함 intersectedObjects++; finalColor = LinearColor::Red; } // 메시 그리기 DrawMesh3D(mesh, finalMatrix, finalColor); // 그린 물체를 통계에 포함 renderedObjects++; } r.PushStatisticText(\u0026#34;Total GameObjects : \u0026#34; + std::to_string(totalObjects)); r.PushStatisticText(\u0026#34;Culled GameObjects : \u0026#34; + std::to_string(culledObjects)); r.PushStatisticText(\u0026#34;Intersected GameObjects : \u0026#34; + std::to_string(intersectedObjects)); r.PushStatisticText(\u0026#34;Rendered GameObjects : \u0026#34; + std::to_string(renderedObjects)); } AABB와의 판정 구 영역 대신 박스(Box) 영역을 사용해서 좀 더 정교한 절두체 컬링 작업을 수행해보자.\n구 바운딩 볼륨에 비해 계산량은 많지만, 좀 더 정교하게 절두체 컬링을 할 수 있어서 보편적으로 게임 엔진에서 활용된다. AABB(Axis aligned bounding box)\n박스 영역을 생성할 때, 기저 축에 평행한 박스 영역이 형성되는데 이것을 AABB라고 한다. 다음은 로컬 공간에서 AABB 영역을 생성하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Box { public: // ... FORCEINLINE constexpr Box operator+=(const Vector3\u0026amp; InVector); public: Vector3 Min; Vector3 Max; }; // 박스 영역의 최솟값과 최댓값을 저장한다. FORCEINLINE constexpr Box Box::operator+=(const Vector3\u0026amp; InVector) { Min.X = Math::Min(Min.X, InVector.X); Min.Y = Math::Min(Min.Y, InVector.Y); Min.Z = Math::Min(Min.Z, InVector.Z); Max.X = Math::Max(Max.X, InVector.X); Max.Y = Math::Max(Max.Y, InVector.Y); Max.Z = Math::Max(Max.Z, InVector.Z); return *this; } 1 2 3 4 5 6 7 Box::Box(const std::vector\u0026lt;Vector3\u0026gt; InVertices) { for (const auto\u0026amp; v : InVertices) { *this += v; } } 그렇다면 로컬 공간에서 생성한 AABB 영역과 평면과의 판정은 어떻게 할까? (a) 평면의 법선 벡터의 모든 요소가 양수인 상황, AABB 영역이 평면의 바깥에 위치해 있다. AABB영역의 최솟값이 평면과 가장 가깝다. (b) 평면의 법선 벡터의 모든 요소가 음수인 상황, AABB 영역이 평면의 안쪽에 위치해 있다. AABB영역의 최댓값이 평면과 가장 까깝다. AABB 영역과 법선 벡터의 $x$, $y$, $z$축은 서로 직교하고 있으므로 각 축의 데이터는. 독립적으로 동작한다. 따라서, 각 법선 벡터의 요소가 양수인 경우에는 최솟값을, 음수인 경우에는 최댓값을 사용하는. 것으로 평면에서 가장 가까운 AABB의 점을 구할 수 있다. 이 가장 가까운 점과 평면과의 $p + d$가 양수라면 바깥에 있는 것이겠다. 그렇다면 겹치는 경우에는? 위 그림과 같이 가장 가까운 점과 평면과의 $p + d$가 음수라면, 정반대의 점으로 다시 테스트를 진행해서, 양수라면 교차하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 FORCEINLINE constexpr BoundCheckResult Frustum::CheckBound(const Box\u0026amp; InBox) const { for (const auto\u0026amp; p : Planes) { Vector3 pPoint = InBox.Min, nPoint = InBox.Max; if (p.Normal.X \u0026gt;= 0.f) { pPoint.X = InBox.Max.X; nPoint.X = InBox.Min.X; } if (p.Normal.Y \u0026gt;= 0.f) { pPoint.Y = InBox.Max.Y; nPoint.Y = InBox.Min.Y; } if (p.Normal.Z \u0026gt;= 0.f) { pPoint.Z = InBox.Max.Z; nPoint.Z = InBox.Min.Z; } // 가장 가까운 점과의 결과가 양수이면 -\u0026gt; 바깥쪽에 있다. if (p.Distance(nPoint) \u0026gt; 0.f) { return BoundCheckResult::Outside; } // 음수인데, 정반대의 점과의 결과가 양수이면 -\u0026gt; 겹쳐있다. if (p.Distance(nPoint) \u0026lt;= 0.f \u0026amp;\u0026amp; p.Distance(pPoint) \u0026gt;= 0.f) { return BoundCheckResult::Intersect; } } // 나머지 -\u0026gt; 안쪽에 있다. return BoundCheckResult::Inside; } 다음은 AABB영역을 사용해서 절두체 컬링을 하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); // 절두체 컬링 테스트를 위한 통계 변수 size_t totalObjects = g.GetScene().size(); size_t culledObjects = 0; size_t intersectedObjects = 0; size_t renderedObjects = 0; for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 최종 행렬 계산 Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); LinearColor finalColor = gameObject.GetColor(); // 최종 변환 행렬로부터 평면의 방정식과 절두체 생성 Matrix4x4 finalTransposedMatrix = finalMatrix.Transpose(); std::array\u0026lt;Plane, 6\u0026gt; frustumPlanesFromMatrix = { Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[1])), // up Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[1])), // bottom Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[0])), // right Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[0])), // left Plane(-(finalTransposedMatrix[3] - finalTransposedMatrix[2])), // far Plane(-(finalTransposedMatrix[3] + finalTransposedMatrix[2])), // near }; Frustum frustumFromMatrix(frustumPlanesFromMatrix); // 바운딩 영역을 사용해 절두체 컬링을 구현 Box boxBound = mesh.GetBoxBound(); auto checkResult = frustumFromMatrix.CheckBound(boxBound); if (checkResult == BoundCheckResult::Outside) { culledObjects++; continue; } else if (checkResult == BoundCheckResult::Intersect) { // 겹친 게임 오브젝트를 통계에 포함 intersectedObjects++; finalColor = LinearColor::Red; } // 메시 그리기 DrawMesh3D(mesh, finalMatrix, finalColor); // 그린 물체를 통계에 포함 renderedObjects++; } r.PushStatisticText(\u0026#34;Total GameObjects : \u0026#34; + std::to_string(totalObjects)); r.PushStatisticText(\u0026#34;Culled GameObjects : \u0026#34; + std::to_string(culledObjects)); r.PushStatisticText(\u0026#34;Intersected GameObjects : \u0026#34; + std::to_string(intersectedObjects)); r.PushStatisticText(\u0026#34;Rendered GameObjects : \u0026#34; + std::to_string(renderedObjects)); } 삼각형 클리핑 지금까지 구현한 것에 문제가 있다. 카메라를 좌우로 움직이면 깨짐 현상이 일어난다. 이 문제의 발생 원인은? 거대한 삼각형이 카메라 앞뒤에 있다고 한다면, 카메라 뒤에 있는 점은 무한 원점을 중심으로 뒤집혀서 투영되기 때문이다. 삼각형 클리핑(Triangle clipping) 원근 투영 행렬을 곱해 생성된 클립 좌표계의 $w$값은 뷰 공간에서의 깊이 값을 의미한다. 따라서 카메라 정면의 위치한 점은 $w$값이 $0$보다 크고, 카메라 뒤에 있는 점의 $w$값은 $0$보다 작으며, 카메라 초점에 위치한 점의 $w$값은 $0$이 된다. 올바르게 보이려면 카메라 뒤쪽에 있는, 음의 $w$ 영역에 걸쳐 있는 삼각형을 파악하고 잘라내야 한다. 이것을 삼각형 클리핑이라고 한다. 이 상황을 위에서 내려다 보자. 점 하나가 카메라 뒤에 있는 경우이다. Chapter 6에서 보았던 것을 사용해서 점 $P_{c1}$의 좌표는 다음과 같이 구할 수 있겠다. $$ P_{c1} = P_1 \\cdot (1- t_1) + P_2 \\cdot t_1 $$ 점 $P_{c1}$은 $w = 0$인 직선에 위치하므로 점 $P_1$, $P_2$의 $w$값을 각각 $w_1$, $w_2$라고 표기하면 다음의 수식이 성립한다. $$ w_1 (1 - t_1) + w_2t_1 = 0 $$ $$ t_1 = \\frac{w_1}{w_1 - w_2} $$ 이 영역은 사각형이므로 두 개의 삼각형으로 분할해야 한다. 방향이 동일하도록 정점의 순서도 자르기 전의 삼각형의 순서와 동일해야 한다. 이번에는 두 점이 카메라 뒤에 있는 경우이다. 이 경우에는 결과가 언제나 삼각형이므로, 두 점의 위치 값만 갱신하면 되겠다. 세 점이 뒤에 있다면 안 그리면 된다. 이러한 클리핑 규칙은 절두체를 구성하는 모든 평면에 적용할 수 있다. 한 점이 카메라 뒤에 있는 경우, 그 다음 상황을 생각해보자. 오른쪽 절두체 영역을 잘라내면 다음과 같을 것이다. 절두체의 오른쪽 평면은 NDC좌표의 x값이 언제나 $1$인 평면이다. 따라서 이것을 클립 좌표계로 표현하면 $\\frac{x}{w} = 1$이며, 이는 $w = x$를 의미한다. 따라서 다음과 같은 식을 사용해서 잘라내는 영역을 파악할 수 있겠다. $$ \\frac{x}{w} \u0026gt; 1 $$ $$ \\therefore x \u0026gt; w $$ 잘라낼 평면 상에 위치한 점의 좌표를 계산하는 방법도 변경된다. 점 $P_1$, $P_2$의 $x$값을 각각 $x_1$, $x_2$로 지정하고, 잘라내는 점의 $x$값을 $x_{c1}$이라고 할 때 $x_{c1}$을 구하는 수식은 다음과 같다. $$ x_{c1} = x_1(1 - t_1) + x_2 t_1 $$ 이것은 $w$값에 대해서도 동일하게 성립된다. $$ w_{c1} = w_1(1- t_1) + w_2t_1 $$ 오른쪽 절두체 평면에서는 $x$, $w$값이 동일하므로 다음과 같이 구할 수 있다. $$ x_1(1 - t_1) + x_2 t_1 = w_1(1- t_1) + w_2t_1 $$ $$ t_1 = \\frac{(w_1 - x_1)}{(w_1 - x_1) - (w_2 - x_2)} $$ 따라서 다음과 같이 각 평면에 대한 방정식을 정리할 수 있겠다. 각 평면의 방정식과 외부 영역에 대한 판별식, 그리고 아핀 결합의 계수를 구하는 수식은 다음과 같다.\n순서 평면 외부 판별식 아핀 결합의 계수 1 $w = 0$ $w\u0026lt;0$ $$\\frac{w_1}{w_1 - w_2}$$ 2 $w = y$ $y\u0026gt;w$ $$\\frac{(w_1 - y_1)}{(w_1 - y_1) - (w_2 - y_2)} $$ 3 $w = -y$ $y\u0026lt;-w$ $$\\frac{(w_1 + y_1)}{(w_1 + y_1) - (w_2 + y_2)} $$ 4 $w = x$ $x\u0026gt;w$ $$\\frac{(w_1 - x_1)}{(w_1 - x_1) - (w_2 - x_2)} $$ 5 $w = -x$ $x\u0026lt;-w$ $$\\frac{(w_1 + x_1)}{(w_1 + x_1) - (w_2 + x_2)} $$ 6 $w = z$ $z\u0026gt;w$ $$\\frac{(w_1 - z_1)}{(w_1 - z_1) - (w_2 - z_2)} $$ 7 $w = -z$ $z\u0026lt;-w$ $$\\frac{(w_1 + z_1)}{(w_1 + z_1) - (w_2 + z_2)} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // w = 0 static auto TestFuncW0 = [](const Vertex3D\u0026amp; InVertex) { return InVertex.Position.W \u0026lt; 0.f; }; static auto EdgeFuncW0 = [](const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex) { float p1 = InStartVertex.Position.W; float p2 = InEndVertex.Position.W; float t = p1 / (p1 - p2); return InStartVertex * (1.f - t) + InEndVertex * t; }; // w = -y static auto TestFuncNY = [](const Vertex3D\u0026amp; InVertex) { return InVertex.Position.Y \u0026lt; -InVertex.Position.W; }; static auto EdgeFuncNY = [](const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex) { float p1 = InStartVertex.Position.W + InStartVertex.Position.Y; float p2 = InEndVertex.Position.W + InEndVertex.Position.Y; float t = p1 / (p1 - p2); return InStartVertex * (1.f - t) + InEndVertex * t; }; // w = -z static auto TestFuncNear = [](const Vertex3D\u0026amp; InVertex) { return InVertex.Position.Z \u0026lt; -InVertex.Position.W; }; static auto EdgeFuncNear = [](const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex) { float p1 = InStartVertex.Position.W + InStartVertex.Position.Z; float p2 = InEndVertex.Position.W + InEndVertex.Position.Z; float t = p1 / (p1 - p2); return InStartVertex * (1.f - t) + InEndVertex * t; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 struct PerspectiveTest { std::function\u0026lt;bool(const Vertex3D\u0026amp; InVertex)\u0026gt; ClippingTestFunc; std::function\u0026lt;Vertex3D(const Vertex3D\u0026amp; InStartVertex, const Vertex3D\u0026amp; InEndVertex)\u0026gt; GetEdgeVertexFunc; std::array\u0026lt;bool, 3\u0026gt; TestResult; void ClipTriangles(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InTriangleVertices) { size_t nTriangles = InTriangleVertices.size() / 3; for (size_t ti = 0; ti \u0026lt; nTriangles; ++ti) { size_t si = ti * 3; size_t testNotPassedCount = 0; std::vector\u0026lt;Vertex3D\u0026gt; sub(InTriangleVertices.begin() + si, InTriangleVertices.begin() + si + 3); // 테스트에 실패한 점 정보 얻기 for (size_t ix = 0; ix \u0026lt; 3; ++ix) { bool testResult = ClippingTestFunc(sub[ix]); TestResult[ix] = testResult; if (testResult) testNotPassedCount++; } GetNewVertices(sub, testNotPassedCount); // 카메라 뒤에 아무 점도 없다. -\u0026gt; 그린다. if (testNotPassedCount == 0) { continue; } // 한 개의 점이 카메라 뒤에 있다. else if (testNotPassedCount == 1) // 삼각형 추가 { DivideIntoTwoTriangles(InOutVertices, startIndex, nonPassCount); } // 두 개의 점이 카메라 뒤에 있다. else if (testNotPassedCount == 2) // 삼각형 정보 변경 { ClipTriangle(InOutVertices, startIndex, nonPassCount); } // 세 개의 점이 카메라 뒤에 있다. -\u0026gt; 안 그린다. else { InTriangleVertices.erase(InTriangleVertices.begin() + si, InTriangleVertices.begin() + si + 3); nTriangles--; ti--; } } } private: // 점 하나가 평면의 바깥에 있어 삼각형이 2개로 쪼개지는 경우 void DivideIntoTwoTriangles(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InOutVertices, size_t StartIndex, size_t NonPassCount) { // 평면의 바깥에 위치한 점 찾기 BYTE index = 0; if (!TestResult[0]) { index = TestResult[1] ? 1 : 2; } size_t v1Index = StartIndex + (index + 1) % 3; size_t v2Index = StartIndex + (index + 2) % 3; // 안 쪽의 점 두 개 Vertex3D v1 = InOutVertices[v1Index]; Vertex3D v2 = InOutVertices[v2Index]; // 교차 지점 Vertex3D clipped1 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v1); Vertex3D clipped2 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v2); InOutVertices[StartIndex] = clipped1; InOutVertices[StartIndex + 1] = v1; InOutVertices[StartIndex + 2] = v2; InOutVertices.push_back(clipped1); InOutVertices.push_back(v2); InOutVertices.push_back(clipped2); } // 점 두 개가 평면의 바깥에 있어 삼각형의 두 점이 변하는 경우 void ClipTriangle(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InOutVertices, size_t StartIndex, size_t NonPassCount) { // 평면의 안쪽에 위치한 점 찾기 BYTE index = 0; if (TestResult[0]) { index = !TestResult[1] ? 1 : 2; } size_t v1Index = StartIndex + (index + 1) % 3; size_t v2Index = StartIndex + (index + 2) % 3; // 바깥쪽 점 두 개 Vertex3D v1 = InOutVertices[v1Index]; Vertex3D v2 = InOutVertices[v2Index]; // 교차 지점 Vertex3D clipped1 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v1); Vertex3D clipped2 = GetEdgeVertexFunc(InOutVertices[StartIndex + index], v2); InOutVertices[v1Index] = clipped1; InOutVertices[v2Index] = clipped2; } }; 다음은 대형 평면 메시를 배치해서 원근 투영 문제를 발생시키고, 삼각형 클래핑을 통해 해결하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 메시를 그리는 함수 void SoftRenderer::DrawMesh3D(const Mesh\u0026amp; InMesh, const Matrix4x4\u0026amp; InMatrix, const LinearColor\u0026amp; InColor) { size_t vertexCount = InMesh.GetVertices().size(); size_t indexCount = InMesh.GetIndices().size(); size_t triangleCount = indexCount / 3; // 렌더러가 사용할 정점 버퍼와 인덱스 버퍼로 변환 std::vector\u0026lt;Vertex3D\u0026gt; vertices(vertexCount); std::vector\u0026lt;size_t\u0026gt; indice(InMesh.GetIndices()); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = Vector4(InMesh.GetVertices()[vi]); if (InMesh.HasColor()) { vertices[vi].Color = InMesh.GetColors()[vi]; } if (InMesh.HasUV()) { vertices[vi].UV = InMesh.GetUVs()[vi]; } } // 정점 변환 진행 VertexShader3D(vertices, InMatrix); // 삼각형 별로 그리기 for (int ti = 0; ti \u0026lt; triangleCount; ++ti) { int bi0 = ti * 3, bi1 = ti * 3 + 1, bi2 = ti * 3 + 2; std::vector\u0026lt;Vertex3D\u0026gt; tvs = { vertices[indice[bi0]] , vertices[indice[bi1]] , vertices[indice[bi2]] }; if (useHomogeneousClipping) { // 동차좌표계에서 클리핑을 위한 설정 std::vector\u0026lt;PerspectiveTest\u0026gt; testPlanes = { { TestFuncW0, EdgeFuncW0 }, { TestFuncNY, EdgeFuncNY }, { TestFuncPY, EdgeFuncPY }, { TestFuncNX, EdgeFuncNX }, { TestFuncPX, EdgeFuncPX }, { TestFuncFar, EdgeFuncFar }, { TestFuncNear, EdgeFuncNear } }; // 동차좌표계에서 클리핑 진행 for (auto\u0026amp; p : testPlanes) { p.ClipTriangles(tvs); } } size_t triangles = tvs.size() / 3; for (size_t ti = 0; ti \u0026lt; triangles; ++ti) { size_t si = ti * 3; std::vector\u0026lt;Vertex3D\u0026gt; sub(tvs.begin() + si, tvs.begin() + si + 3); DrawTriangle3D(sub, InColor, FillMode::Color); } } } ","date":"2022-05-01T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-13-2/","title":"[Game Math] Chapter 13. 절두체: 최적화된 3차원 공간 (2) "},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n절두체 컬링 절두체 컬링(Frustum culling) 절두체를 구성하는 6개의 평면에 대해 각각 평면의 방정식을 세우고, 그것을 활용해서 게임 오브젝트가 평면의 바깥에 있는지 확인한다. 바깥에 있다면, 그리지 않는다. 평면의 방정식 절두체를 구성하는 평면의 방정식\nChapter 8에서 살펴본 것처럼, 주어진 세 점으로 두 벡터를 생성해서 평면 상의 모든 점을 생성할 수 있다. 하지만 3차원 공간의 평면은 앞면과 뒷면이 존재하기 때문에 이를 구분할 수 있어야 하겠다. 따라서 평면이 바라보는 방향을 알려주는 법선 벡터와 평면 상에 위치한 한 점을 제공하는 방법을 사용한다. 이 때 법선 벡터는 크기를 1로 정규화한다. 법선벡터와 평면 위의 두 점을 지나는 벡터는 서로 직교하기 때문에 두 벡터의 내적은 $0$이 된다.\n따라서 법선벡터 $\\hat{n} = (a, b, c)$와 점 $P_0 = (x_0, y_0, z_0)$에서 $P = (x, y, z)$로 향하는 벡터를 내적하면 다음과 같다. $$ \\hat{n} \\cdot (P - P_0) = (a, b, c) \\cdot (x - x_0, y - y_0, z - z_0) = 0 $$ $$ = ax + by + cz - (ax_0 + by_0 + cz_0) = 0 $$ 여기서 법선벡터 $\\hat{n} = (a, b, c)$와 점 $P_0 = (x_0, y_0, z_0)$은 사전에 주어진 값이므로 $- (ax_0 + by_0 + cz_0)$는 미리 계산할 수 있는 상수 값이다. 이것을 간단히 $d$로 치환하면 다음과 같다. 평면의 방정식(The equation of plane) $$ ax + by + cz + d = 0 $$ 여기서 $d$의 의미를 찾아보자. $$d = -(ax_0 + by_0 + cz_0)$$ $$ d = -\\hat{n} \\cdot (x_0, y_0, z_0)$$ $$ d = -\\hat{n} \\cdot \\vec{OP_0} = -\\hat{n} \\cdot \\vec{p}$$ 그렇다면 $\\hat{n} \\cdot \\vec{p}$는 무엇을 의미할까? Chapter 7에서 배운 벡터 내적의 $\\cos$공식을 떠올려보자. $\\hat{n} \\cdot \\vec{p} = | \\hat{n} | | \\vec{p} | \\cos\\theta$ 법선 벡터의 크기는 $1$이므로 다음과 같이 정리된다. $\\hat{n} \\cdot \\vec{p} = | \\vec{p} | \\cos\\theta$ 따라서 $\\hat{n} \\cdot \\vec{p}$이란 $\\vec{p}$벡터를 법선 벡터 $\\hat{n}$에 투영한 벡터의 크기를 의미한다. 즉, 원점에서 평면까지의 최단 거리인 것이다. $d$의 값은 마이너스를 붙인 $-\\hat{n} \\cdot \\vec{p}$이므로 원점으로부터 평면의 최단 거리에 음의 부호를 설정한다. 그래서 $d$는 최단 거리와 방향이라는 두 가지 정보를 담고 있다. $d$의 부호 $d$의 값이 양수이다. 평면이 바라보는 방향은 원점을 향한다. 즉, 원점은 평면의 바깥에 있다. $d$의 값이 음수이다. 평면이 바라보는 방향은 원점에서 멀어지는 방향을 가진다. 즉, 원점은 평면의 안쪽에 있다. $d$의 절댓값 평면에서 원점까지의 최단 거리. $d$의 값이 $0$ 이다. 평면이 원점을 품었다. 주어진 점이 평면의 안쪽에 있는지 바깥쪽에 있는지 판별하기. $d$값의 성질을 응용해보자. 위 그림과 같이 벡터 $\\vec{p}$를 법선 벡터에 내적한 값을 $p$라고 하자. $p$가 양수면? 벡터 $\\vec{p}$는 법선 벡터와 같은 방향을 향한다. $p$가 음수면? 벡터 $\\vec{p}$는 법선 벡터와 반대 방향을 향한다. 위 그림에서는 $p$가 양수이겠다. 그렇다면 $p$와 $d$를 더한 값은 어떨까? $p + d$가 음수면? 점 $P$는 평면의 안쪽에 있다. $p + d$가 양수면? 점 $P$는 평면의 바깥쪽에 있다. 따라서 법선 벡터 $(a, b, c)$와 $d$를 사용해 주어진 점 $P = (x_1, y_1, z_1)$이 평면의 바깥쪽에 있는지 판단하는 수식은 다음과 같다. $$(a, b, c) \\cdot (x_1, y_1, z_1) + d \u0026gt; 0 $$ 그리고 평면에서 해당 점까지의 최단 거리는 다음과 같다. $$distance = |(a, b, c) \\cdot (x_1, y_1, z_1) + d | $$ 평면의 방정식의 정규화 크기가 $1$이 아닌 주어진 법선 벡터를 구성하는 세 계수 $(a, b, c)$를 정규화해서 $(a\u0026rsquo;, b\u0026rsquo;, c\u0026rsquo;)$를 만들어 보자. 이것은 법선 벡터의 크기로 나누면 구할 수 있다. $$ (a\u0026rsquo;, b\u0026rsquo;, c\u0026rsquo;) = \\frac{(a, b, c)}{\\sqrt{a^2 + b^2 + c^2}} $$ $d$를 정규화한 $d\u0026rsquo;$를 만들어 보자. $$ d = -\\hat{n} \\cdot \\vec{p} = - |\\hat{n}||\\vec{p}|\\cos\\theta $$ $$ d\u0026rsquo; = -|\\vec{p}|\\cos\\theta $$ 따라서 다음과 같은 관계가 나온다. $$ d\u0026rsquo; = \\frac{d}{|\\vec{n}|} $$ 즉, $d$의 경우에도 동일하게 법선 벡터의 크기로 나누면 되는 것이다. $$ \\frac{ax + by + cz + d}{\\sqrt{a^2 + b^2 + c^2}} = 0 $$ 2차원 직선의 방정식에서의 최단 거리 임의의 한 점 $(x_1, y_1)$에서 임의의 직선 $ax + by + c = 0$ 까지의 최단 거리는 어떻게 구할 수 있을까? 평면의 방정식을 정규화한 값과 내적을 활용해 구할 수 있겠다. $$ \\frac{ | ax_1 + by_1 + c | }{ \\sqrt{a^2 + b^2 } } $$ 평면의 방정식을 활용한 절두체 표현 절두체 상단 평면을 무한하게 확장하면, 그 평면은 원점을 품게 된다. 이것은 근평면, 원평면을 제외한 나머지 평면에 대해서도 동일하다. 따라서 근평면, 원평면을 제외한 나머지 평면을 구성하는 평면의 방정식 $d$값은 $0$이겠다. 상단 평면의 경우 아래 그림과 같이 구할 수 있으므로, 같은 방식으로 네 평면의 방정식을 구할 수 있다. 절두체 상단 평면의 방정식 $$ \\cos\\frac{\\theta}{2}y + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 절두체 하단 평면의 방정식 $$ -\\cos\\frac{\\theta}{2}y + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 절두체 좌측 평면의 방정식 $$ \\cos\\frac{\\theta}{2}x + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 절두체 우측 평면의 방정식 $$ -\\cos\\frac{\\theta}{2}x + \\sin\\theta\\frac{\\theta}{2}z = 0 $$ 근평면의 경우, 원점으로부터의 거리는 $n$이므로, 평면의 방정식의 $d$의 값은 $n$이 된다. 그리고 법선 벡터의 값은 $(0, 0, 1)$이 된다. $$(0, 0, 1) \\cdot (x, y, z) - (0, 0, 1) \\cdot (0, 0, -n) = 0 $$ $$ \\therefore z + n = 0 $$ 원평면의 경우에는 거리가 $f$가 되며, 법선 벡터의 값은 $(0, 0, -1)$이 된다. $$(0, 0, -1) \\cdot (x, y, z) - (0, 0, 1) \\cdot (0, 0, f) = 0 $$ $$ \\therefore -z -f = 0 $$ 이 때, 함부로 수식을 옮기면 안 된다. 만약 $0 = z + f$와 같이 옮긴다면, 평면의 방향은 원평면의 반대 방향인 원점을 향한다. 따라서 $-z -f = 0 $와 $0 = z + f$는 서로 다른 평면이다. 원근 투영 행렬로부터 평면의 방정식 만들기 원근 투영 행렬을 사용해서 절두체 컬링을 좀 더 간편하게 구현할 수 있다. 뷰 공간의 점이 NDC좌표까지 변환됐을 때, NDC좌표를 구성하는 $x$, $y$, $z$ 세 축의 값이 $[-1, 1]$ 범위에 있다면 해당 점은 절두체 영역 안 쪽에 있다는 것을 의미한다. $$ -1 \\leq n_x \\leq 1 $$ $$ -1 \\leq n_y \\leq 1 $$ $$ -1 \\leq n_z \\leq 1 $$ 이 때 NDC좌표는 클립 좌표의 마지막 차원 $w$로 나눈 결과값이므로 다음과 같다. $$ -1 \\leq \\frac{x}{w} \\leq 1 $$ $$ -1 \\leq \\frac{y}{w} \\leq 1 $$ $$ -1 \\leq \\frac{z}{w} \\leq 1 $$ $$ -w \\leq x \\leq w $$ $$ -w \\leq y \\leq w $$ $$ -w \\leq z \\leq w $$ 여기서 $x$, $y$, $z$란? $$ P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{n + f}{n - f} \u0026amp; \\frac{2nf}{n - f} \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} $$ 이것은 원근 투영 행렬의 4개의 행벡터와 $\\vec{v}$의 내적으로 바꿔 쓸 수 있다. $$ \\begin{bmatrix} P_{row1} \\cdot \\vec{v} \\\\ P_{row2} \\cdot \\vec{v} \\\\ P_{row3} \\cdot \\vec{v} \\\\ P_{row4} \\cdot \\vec{v} \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} $$ 이것을 부등식에 치환하면 다음과 같다. $$ -P_{row4} \\cdot \\vec{v} \\leq P_{row1} \\cdot \\vec{v} \\leq P_{row4} \\cdot \\vec{v} $$ $$ -P_{row4} \\cdot \\vec{v} \\leq P_{row2} \\cdot \\vec{v} \\leq P_{row4} \\cdot \\vec{v} $$ $$ -P_{row4} \\cdot \\vec{v} \\leq P_{row3} \\cdot \\vec{v} \\leq P_{row4} \\cdot \\vec{v} $$ 이것을 분리해 6개의 부등식으로 표현할 수 있겠다. $$ (P_{row4} + P_{row1} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} - P_{row1} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} + P_{row2} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} - P_{row2} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} + P_{row3} \\cdot \\vec{v}) \\geq 0 $$ $$ (P_{row4} - P_{row3} \\cdot \\vec{v}) \\geq 0 $$ 이 부등식이 모두 참이면 점 $\\vec{v}$는 절두체 영역 내부에 있음을 의미한다. 여기서 행벡터가 $P_{rown} = (a, b, c, d)$라고 하고, 뷰 공간의 점이 $\\vec{v} = (x, y, z, 1)$라고 할 때 내적의 결과는 다음과 같다. $$ ax + by + cz + d \\geq 0 $$ 하지만 법선벡터 $(a, b, c)$의 크기가 $1$이 아니므로, 정규화 해야 한다. $$ \\frac{ ax + by + cz + d }{ \\sqrt{ a^2 + b^2 + c^2 } } = 0 $$ 이 결과는 모두 절두체 내부를 향할 것이다. 따라서 외부에 있는지를 검출하기 위해서는 부호를 반전시켜 주어야 한다. $$ - ( \\frac{ ax + by + cz + d }{ \\sqrt{ a^2 + b^2 + c^2 } } ) \u0026gt; 0 $$ 원근 투영 행렬을 사용해서 절두체 컬링하는 예제이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct Plane { public: FORCEINLINE constexpr float Distance(const Vector3\u0026amp; InPoint) const; FORCEINLINE constexpr bool IsOutside(const Vector3\u0026amp; InPoint) const; Vector3 Normal = Vector3::UnitY; // (a, b, c) float D = 0.f; // 상수 d의 값 }; Plane::Plane(const Vector4\u0026amp; InVector4) { Normal = InVector4.ToVector3(); // (a, b, c) D = InVector4.W; // 상수 d의 값 Normalize(); } // 정규화 한다. void Plane::Normalize() { // a^2 + b^2 + c^2 float squaredSize = Normal.SizeSquared(); // 크기가 1이면 정규화할 필요 없다. if (Math::EqualsInTolerance(squaredSize, 1.f)) { return; } // 1 / sqrt(a^2 + b^2 + c^2)을 고속 역제곱근(Fast inverse square root) 함수로 구한다. float invLength = Math::InvSqrt(squaredSize); // 곱해서 정규화한다. Normal *= invLength; D *= invLength; } // p + d를 리턴한다. FORCEINLINE constexpr float Plane::Distance(const Vector3\u0026amp; InPoint) const { return Normal.Dot(InPoint) + D; } // Distance의 반환값이 양수이면 그 점은 평면의 바깥에 있다. FORCEINLINE constexpr bool Plane::IsOutside(const Vector3\u0026amp; InPoint) const { return Distance(InPoint) \u0026gt; 0.f; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 FORCEINLINE constexpr BoundCheckResult Frustum::CheckBound(const Vector3\u0026amp; InPoint) const { // 6개의 평면에 대해 테스트를 진행한다. for (const auto\u0026amp; p : Planes) { // 한 평면이라도 밖에 있으면 점은 외부에 있음으로 판별하고 함수를 종료한다. if (p.IsOutside(InPoint)) { return BoundCheckResult::Outside; } // 오차 범위 내의 거리가 0에 근접하면 겹치는 것으로 판별하고 종료한다. else if (Math::EqualsInTolerance(p.Distance(InPoint), 0.f)) { return BoundCheckResult::Intersect; } } // 모든 평면에 대해 위 테스트를 통과하면 안쪽으로 판별한다. return BoundCheckResult::Inside; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 vMatrix = mainCamera.GetViewMatrix(); const Matrix4x4 pMatrix = mainCamera.GetPerspectiveMatrix(); // 원근 투영 행렬을 가져온다. const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); // 절두체 구축을 위한 투영 행렬의 설정 Matrix4x4 ptMatrix = pMatrix.Transpose(); // 절두체를 구성하는 평면의 방정식 // 절두체를 구성하는 6개의 평면을 생성한다. std::array\u0026lt;Plane, 6\u0026gt; frustumPlanes = { Plane(-(ptMatrix[3] - ptMatrix[1])), // +Y Plane(-(ptMatrix[3] + ptMatrix[1])), // -Y Plane(-(ptMatrix[3] - ptMatrix[0])), // +X Plane(-(ptMatrix[3] + ptMatrix[0])), // -X Plane(-(ptMatrix[3] - ptMatrix[2])), // +Z Plane(-(ptMatrix[3] + ptMatrix[2])), // -Z }; // 절두체 선언 Frustum frustumFromMatrix(frustumPlanes); // 평면의 배열을 인자로 넣어 절두체를 구축한다. // 절두체 컬링 테스트를 위한 통계 변수 size_t totalObjects = g.GetScene().size(); // 씬에 속한 전체 게임 오브젝트 수를 파악한다. size_t culledObjects = 0; // 렌더링이 진행된 게임 오브젝트 수를 파악한다. size_t renderedObjects = 0; // 렌더링이 진행된 게임 오브젝트 수를 파악한다. for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 절두체 컬링 구현 // 게임 오브젝트의 위치를 뷰 공간으로 변환한다. Vector4 viewPos = vMatrix * Vector4(transform.GetPosition()); // 뷰 공간의 위치가 절두체 영역의 외부에 있는지 검사한다. if (frustumFromMatrix.CheckBound(viewPos.ToVector3()) == BoundCheckResult::Outside) { // 그리지 않고 건너뜀 culledObjects++; continue; } // 최종 행렬 계산 Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); // 메시 그리기 DrawMesh3D(mesh, finalMatrix, gameObject.GetColor()); // 그린 물체를 통계에 포함 renderedObjects++; } r.PushStatisticText(\u0026#34;Total GameObjects : \u0026#34; + std::to_string(totalObjects)); r.PushStatisticText(\u0026#34;Culled GameObjects : \u0026#34; + std::to_string(culledObjects)); r.PushStatisticText(\u0026#34;Rendered GameObjects : \u0026#34; + std::to_string(renderedObjects)); } ","date":"2022-04-30T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-13-1/","title":"[Game Math] Chapter 13. 절두체: 최적화된 3차원 공간 (1)"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n원근 투영 변환의 원리 투시 원근법(Perspective projection drawing)\n시선을 한 점에 고정시키고, 고정된 점으로부터 화폭까지 곧게 뻗은 실을 활용해서 그림을 그려나가는 것이다. 원근 투영 변환(Perspective projection transformation)\n투시 원근법의 원리를 적용하기 위해서 공간의 모든 점이 한 점을 향해 모이는 형태로 변환하는 것이다. 즉, $x$, $y$, $z$축이 모두 직교하는 정육면체 형태를 가진 뷰 공간을 카메라의 한 점으로 모이는 사각뿔 형태를 가진 공간으로 변환하는 작업이다. 화각(Field of view)\n카메라를 통해서 이미지를 담을 수 있는 각을 말한다. 카메라에 화각을 설정하면 좌우와 위아래가 균등한 사각뿔 영역이 만들어진다. 투영 평면(Projection plane)\n3차원 공간을 원근 투영 변환한 후에는 그것을 2차원의 모니터 평면에 담아내야 한다. 이를 위해서 모든 물체의 상이 맺히는 가상의 평면을 생성해야 하는데 이것을 투영 평면이라고 한다. 초점 거리(Focal length)\n카메라로부터 투영 평면까지의 거리이다. NDC(Normalized device coordinate)\n원근 투영 변환을 위해서는 먼저 투영 평면의 위치를 지정해야 한다. 일반적으로 투영 평면의 위치는 계산의 편의를 위해서 위 아래의 크기가 각각 $1$이 되는 지점으로 결정한다. 따라서 다음과 같이 좌우와 상하가 $[-1, 1]$의 범위를 가지는 정사각형의 모습을 띤다. 이 정사각형 영역은 2차원 평면의 좌표 시스템을 가지는데 이를 NDC라고 한다. NDC는 가운데 중점을 원점으로 설정한다. NDC가 언제나 일정한 값을 가진다면, 화각에 따라 초점 거리가 달라질 수밖에 없다.\n화각이 커질 수록 초점 거리는 가까워지고, 화각이 작아질 수록 초점 거리는 멀어지겠다. $$\\tan(\\frac{\\theta}{2}) = \\frac{1}{d}$$ $$ d = \\frac{1}{\\tan(\\frac{\\theta}{2})} $$ 사영 공간(Projective space) 지금까지의 공간 변환은 $x$, $y$, $z$축이 모두 직교하고 정육면체 형태의 3차원 공간이었다. 하지만 원근 투영 변환을 거치면 사각뿔 형태로 바뀌게 된다. 이것을 사영 공간이라고 한다. $x$, $y$축은 여전히 직교하므로 유클리드 공간과 동일한 성질을 가진다. 하지만 $z$축은 독립적으로 행동하지 않고 $x$, $y$축에 모두 영향을 준다. 이것이 초점 거리에 따라 투영 평면의 면적이 달라지는 이유이기도 하겠다. 그렇다면 원근 투영 변환에 대응하는 행렬은 어떻게 설계할 수 있을까? $x$축을 배제하고 $y$, $z$축으로 공간을 설정하고 투영 평면에 상이 맺히는 과정을 생각해보자. 뷰공간의 점 $P_{view}$가 투영 평면에 투영된 점을 $P_{ndc}$라고 한다면 좌표는 다음과 같다. $P_{view} = (0, v_y, v_z)$ $P_{ndc} = (0, n_y)$ 두 점의 관계를 닮은꼴 삼각형 두개로 알아보면 다음과 같은 비가 성립된다. $n_y : d = v_y : -v_z$ $n_y = \\frac{d \\cdot v_y}{-v_z}$ 카메라의 좌우 상하 시야각은 동일하므로 NDC의 $x$값 또한 $y$값을 $0$으로 고정한 후 $x$, $z$축의 평면을 사용하는 방식으로 구할 수 있다. 따라서 초점 거리와 뷰 좌표로부터 $P_{ndc}$를 구할 수 있다. $$P_{ndc} = (n_x, n_y) = (\\frac{d \\cdot v_x}{-v_z}, \\frac{d \\cdot v_y}{-v_z}) = -\\frac{d}{v_z}(v_x, v_y)$$ 이제 NDC좌표를 계산했으니, 이 좌표를 모니터 해상도 만큼 가로 세로로 늘려주면 최종 스크린 좌표가 완성된다. 근데 가로 세로 해상도가 다르기 때문에 늘리면 물체가 찌그러지겠다. 가로 세로의 비를 종횡비(Aspect ratio) 라고 한다. 종횡비를 파악해서 미리 NDC영역에서 찌그러트린 다음에 펼치면 문제 해결이 가능하겠다. 예를 들어, $800 \\times 600$해상도에서 세로 크기를 기준으로 잡은 종횡비는 $1.3333$이다. 이 종횡비를 $a$라고 하자. 그러면 좌우로 찌그러트리기 위해서 $x$축에 종횡비의 역수 $\\frac{1}{a}$를 곱하면 되겠다. $$P_{ndc} = -\\frac{d}{v_z}(\\frac{v_x}{a}, v_y)$$ 이렇게 최종 NDC값을 계산하는 원근 투영 행렬 $P$를 다음과 같이 설계할 수 있겠다. $$P_{ndc} = P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{1}{a} \\cdot \\frac{d}{-v_z} \u0026amp; 0 \\\\ 0 \u0026amp; \\frac{d}{-v_z} \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\end{bmatrix}$$ 하지만 한 가지 아쉽다. 변환할 점의 $z$값이 행렬에 사용되다보니 변환할 점마다 항상 행렬을 새롭게 생성해야 한다. Chapter 5에서 본것처럼 미리 곱해둔 행렬을 계속 사용한다면 굉장히 연산량을 줄일 수 있겠다. 이건 어떨까? $-\\vec{v_z}$값을 행렬에서 제거하고 대신 행렬의 결괏값에서 $-\\vec{v_z}$를 나누어 주는 거다. $$P_{ndc} = P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; d \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\end{bmatrix} = \\begin{bmatrix} \\frac{d}{a} \\cdot v_x \\\\ d \\cdot v_y \\\\ -v_z\\end{bmatrix}$$ 클립 좌표(Clip coordinate) 이렇게 원근 투영 행렬 $P$로 변환되는 좌표계를 클립 좌표라고 부르며 다음과 같이 계산한다. $$P_{clip} = (\\frac{d}{a} \\cdot v_x , d \\cdot v_y , -v_z)$$ 이 클립좌표를 세 번째 값인 $-v_z$로 나누면 NDC좌표를 얻을 수 있다. $$P_{ndc} = (\\frac{d \\cdot v_x}{-v_z \\cdot a}, \\frac{d \\cdot v_y}{-v_z}, 1)$$ 동차 좌표계 동차 좌표계(Homogenous coordinate system) 동차란? 모든 항의 차수가 같음을 의미한다. 한 차원 높인 벡터를 사용하는 것을 동차 좌표계라고 한다. 사영 공간이 사용하는 좌표계는 동차 좌표계이다. 왜냐하면\u0026hellip; 3차원의 사영 공간에서 평행하게 점을 이동시키면?\n카메라에 멀어질 수록 투영된 좌푯값이 투영 평면의 원점에 가까워지고, 카메라에 가까워질수록 커진다. 즉, 사영 공간의 점과 투영된 점의 좌표는 반비례 관계이다. 사영 공간의 점을 $(x\u0026rsquo;, y\u0026rsquo;, z\u0026rsquo;)$라고 하고, 해당 점이 투영된 NDC좌표를 $(x, y)$라고 하자. 그러면 NDC 좌푯값은 마지막 차원값 $z\u0026rsquo;$에 반비례로 영향을 받으므로 다음과 같은 관계가 성립한다. $$ x = \\frac{x\u0026rsquo;}{z\u0026rsquo;}, y = \\frac{y\u0026rsquo;}{z\u0026rsquo;}$$ 사영 공간의 좌표로 직선의 방정식을 표현해보자. 위의 $x$, $y$를 직선의 방정식 $y = ax + b$에 대입해보자.\n$$\\frac{y\u0026rsquo;}{z\u0026rsquo;} = a\\frac{x\u0026rsquo;}{z\u0026rsquo;} + b$$ $$ y\u0026rsquo; = ax\u0026rsquo; + bz\u0026rsquo;$$ 위와 같이 세 미지수의 차수가 모두 1차식으로 동일한 방정식이 만들어진다. 이렇게 미지수에 대한 차수가 동일한 방정식을 동차 방정식이라고 한다. 그래서 사영 공간이 사용하는 좌표계는 동차좌표계라고 부른다. NDC의 원점 $(0, 0)$\n카메라로 멀어질수록 투영된 NDC 좌푯값은 원점 $(0, 0)$에 가까워진다. 이런 NDC의 원점은 회화의 투시 원근 기법에서 사용하는 소실점(Vanishing point) 에 해당한다. 다음은 원근 투영 변환행렬을 사용해서 원근감을 준 코드이다. 또한 입력에 따라 화각을 달리하여 변화되는 모습을 볼 수 있다.\n클립 좌표 값 얻기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class CameraObject { public: FORCEINLINE Matrix4x4 GetPerspectiveMatrix() const; private: float _FOV = 60.f; // 시야각 }; // 원근 투영 행렬 P를 생성한다. FORCEINLINE Matrix4x4 CameraObject::GetPerspectiveMatrix() const { float invA = 1.f / _ViewportSize.AspectRatio(); float d = 1.f / tanf(Math::Deg2Rad(_FOV) * 0.5f); return Matrix4x4( Vector4::UnitX * invA * d, Vector4::UnitY * d, Vector4(0.f, 0.f, -1.f, 0.f), Vector4(0.f, 0.f, 0, 1.f) ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 게임 로직을 담당하는 함수 void SoftRenderer::Update3D(float InDeltaSeconds) { // 게임 로직에서 사용하는 모듈 내 주요 레퍼런스 GameEngine\u0026amp; g = Get3DGameEngine(); const InputManager\u0026amp; input = g.GetInputManager(); // 게임 로직의 로컬 변수 static float moveSpeed = 500.f; static float fovSpeed = 100.f; // 시야각 조절 속도 static float minFOV = 15.f; // 최소 시야각 static float maxFOV = 150.f; // 최대 시야각 // 게임 로직에서 사용할 게임 오브젝트 레퍼런스 GameObject\u0026amp; goPlayer = g.GetGameObject(PlayerGo); CameraObject\u0026amp; camera = g.GetMainCamera(); TransformComponent\u0026amp; playerTransform = goPlayer.GetTransform(); // 입력에 따른 플레이어 트랜스폼의 변경 Vector3 inputVector = Vector3(input.GetAxis(InputAxis::XAxis), input.GetAxis(InputAxis::YAxis), input.GetAxis(InputAxis::ZAxis)).GetNormalize(); playerTransform.AddPosition(inputVector * moveSpeed * InDeltaSeconds); // 입력에 따른 카메라 트랜스폼의 변경 // deltaFOV로 시야각 변화량을 계산하고 // 최소, 최댓값 사이로 시야각을 설정한다. camera.SetLookAtRotation(playerTransform.GetPosition()); float deltaFOV = input.GetAxis(InputAxis::WAxis) * fovSpeed * InDeltaSeconds; camera.SetFOV(Math::Clamp(camera.GetFOV() + deltaFOV, minFOV, maxFOV)); } // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 렌더링 로직의 로컬 변수 const Matrix4x4 vMatrix = mainCamera.GetViewMatrix(); const Matrix4x4 pMatrix = mainCamera.GetPerspectiveMatrix(); for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 원근투영행렬 * 뷰행렬 * 모델링행렬 // (1) 결과는 클립 좌표의 값이겠다. Matrix4x4 finalMatrix = pMatrix * vMatrix * transform.GetModelingMatrix(); // 메시 그리기 DrawMesh3D(mesh, finalMatrix, gameObject.GetColor()); if (gameObject == PlayerGo) { // 플레이어의 위치 r.PushStatisticText(\u0026#34;Player: \u0026#34; + transform.GetPosition().ToString()); } } r.PushStatisticText(\u0026#34;Camera: \u0026#34; + mainCamera.GetTransform().GetPosition().ToString()); r.PushStatisticText(\u0026#34;FOV : \u0026#34; + std::to_string(mainCamera.GetFOV())); } 클립 좌표 값을 NDC로 변환하고 해상도 크기로 늘려주기. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get3DGameEngine(); // (2) 클립 좌표를 NDC 좌표로 변경 for (auto\u0026amp; v : InVertices) { // 무한 원점인 경우, 약간 보정해준다. if (v.Position.Z == 0.f) v.Position.Z = SMALL_NUMBER; float invZ = 1.f / v.Position.Z; v.Position.X *= invZ; v.Position.Y *= invZ; v.Position.Z *= invZ; } // 백페이스 컬링 Vector3 edge1 = (InVertices[1].Position - InVertices[0].Position).ToVector3(); Vector3 edge2 = (InVertices[2].Position - InVertices[0].Position).ToVector3(); Vector3 faceNormal = -edge1.Cross(edge2); Vector3 viewDirection = Vector3::UnitZ; if (faceNormal.Dot(viewDirection) \u0026gt;= 0.f) { return; } // (3) NDC 좌표를 화면 좌표로 늘리기 for (auto\u0026amp; v : InVertices) { v.Position.X *= _ScreenSize.X * 0.5f; v.Position.Y *= _ScreenSize.Y * 0.5f; } LinearColor finalColor = _WireframeColor; if (InColor != LinearColor::Error) { finalColor = InColor; } r.DrawLine(InVertices[0].Position, InVertices[1].Position, finalColor); r.DrawLine(InVertices[0].Position, InVertices[2].Position, finalColor); r.DrawLine(InVertices[1].Position, InVertices[2].Position, finalColor); } 깊이 값 깊이(Depth) 값의 필요성 우리에게 보이는 화면은 결국 2차원 평면이므로 가장 카메라에서 멀리 있는 나중에 그린 물체가 앞에 보일 수 밖에 없다. 이 문제를 해결하기 위해서는 카메라로부터 물체가 얼마나 떨어졌는지에 대한 깊이 값이 필요하다. 깊이 값을 추가하면 2차원 평면이었던 NDC영역이 3차원으로 확장된다. 여기서 깊이값의 범위는 동일하게 $[-1, 1]$ 이다. 절두체(Frustum)\n카메라에 가장 가까이 있는, 깊이 값이 $-1$인 평면을 근평면(Near plane) 이라고 한다. 반대로 가장 멀리에 있는, 깊이 값이 $1$인 평면을 원평면(Far plane) 이라고 한다. 사영 공간을 근평면과 원평면으로 잘라서 만들어진 부분을 절두체라고 한다. 절두체로 생성되는 3차원의 NDC영역의 범위는 다음과 같다. NDC 깊이 값은 멀어질수록 증가하기 때문에 왼손좌표계를 사용한다. 원근 투영 행렬에 깊이 값을 넣기 위해 3행을 4행으로 옮기고 3행을 깊이값을 구하는 용도로 변경하자. 뷰 공간의 점이 $\\vec{v} = (v_x, v_y, v_z, 1)$일 때 다음과 같이 구할 수 있다. $$ P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ ? \u0026amp; ? \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{d}{a} \\cdot v_x \\\\ d \\cdot v_y \\\\ ? \\\\ -v_z\\end{bmatrix}$$ 여기서 깊이 값은 뷰 좌표계의 $x$, $y$축과 직교하므로 영향을 받지 않는다. 그러므로 3행의 앞의 두 요소는 $0$으로 설정할 수 있겠다. $$ P \\cdot \\vec{v} = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} v_x \\\\ v_y \\\\ v_z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{d}{a} \\cdot v_x \\\\ d \\cdot v_y \\\\ ? \\\\ -v_z\\end{bmatrix}$$ 이제 여기에서 근평면과 원평면의 값을 사용해보자. 근평면에 있는 점을 $P_1$, 원평면에 있는 점을 $P_2$라고 하자. 그리고 카메라부터 근평면까지의 거리를 $n$, 원평면까지의 거리를 $f$라고 하자. 근평면의 경우 뷰 공간의 좌표는 $(0, 0, -n, 1)$이 된다. 근평면은 깊이 값의 시작부분이므로 NDC좌표의 $(0, 0, -1)$에 대응한다. 따라서 다음과 같이 만들어진다. $$ P_1 = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ -n \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ ? \\\\ n \\end{bmatrix}$$ 클립 좌표의 경우 세번째 원소를 마지막 네번째 원소로 나눈 값이 NDC의 세번째 원소인 $-1$이 되므로, $?$는 $-n$이 된다. $$ P_1 = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ -n \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -n \\\\ n \\end{bmatrix}$$ 원평면의 경우 동일한 방식으로 다음과 같이 구할 수 있겠다. $$ P_2 = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; ? \u0026amp; ? \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ -f \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ f \\\\ f \\end{bmatrix}$$ 여기서 두행렬의 3행과 뷰 공간의 점을 내적한 후 수식을 정리하면 다음과 같이 최종 원근 투영 행렬을 구할 수 있다. $$ P = \\begin{bmatrix} \\frac{d}{a} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; d \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{n + f}{n - f} \u0026amp; \\frac{2nf}{n - f} \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} $$ 위에서 봤던 예제 코드에다가 깊이 값까지 계산하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class CameraObject { public: FORCEINLINE Matrix4x4 GetPerspectiveMatrix() const; FORCEINLINE Matrix4x4 GetPerspectiveViewMatrix() const; private: float _FOV = 60.f; float _NearZ = 5.5f; float _FarZ = 5000.f; }; // 깊이 값을 계산하는 최종 원근 투영 행렬 FORCEINLINE Matrix4x4 CameraObject::GetPerspectiveMatrix() const { // 투영 행렬. 깊이 값의 범위는 -1~1 float invA = 1.f / _ViewportSize.AspectRatio(); float d = 1.f / tanf(Math::Deg2Rad(_FOV) * 0.5f); // 근평면과 원평면에 반대 부호를 붙여서 계산 float invNF = 1.f / (_NearZ - _FarZ); float k = (_FarZ + _NearZ) * invNF; float l = 2.f * _FarZ * _NearZ * invNF; return Matrix4x4( Vector4::UnitX * invA * d, Vector4::UnitY * d, Vector4(0.f, 0.f, k, -1.f), Vector4(0.f, 0.f, l, 0.f) ); } // 원근투영 행렬과 뷰 행렬을 곱한 행렬 FORCEINLINE Matrix4x4 CameraObject::GetPerspectiveViewMatrix() const { // 뷰 행렬 관련 요소 Vector3 viewX, viewY, viewZ; GetViewAxes(viewX, viewY, viewZ); Vector3 pos = _Transform.GetPosition(); float zPos = viewZ.Dot(pos); // 투영 행렬 관련 요소 float invA = 1.f / _ViewportSize.AspectRatio(); float d = 1.f / tanf(Math::Deg2Rad(_FOV) * 0.5f); float dx = invA * d; float invNF = 1.f / (_NearZ - _FarZ); float k = (_FarZ + _NearZ) * invNF; float l = 2.f * _FarZ * _NearZ * invNF; return Matrix4x4( Vector4(dx * viewX.X, d * viewY.X, k * viewZ.X, -viewZ.X), Vector4(dx * viewX.Y, d * viewY.Y, k * viewZ.Y, -viewZ.Y), Vector4(dx * viewX.Z, d * viewY.Z, k * viewZ.Z, -viewZ.Z), Vector4(-dx * viewX.Dot(pos), -d * viewY.Dot(pos), -k * zPos + l, zPos) ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render3D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 const GameEngine\u0026amp; g = Get3DGameEngine(); auto\u0026amp; r = GetRenderer(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 배경에 기즈모 그리기 DrawGizmo3D(); // 원근 투영 행렬 * 뷰행렬의 결과 행렬 const Matrix4x4 pvMatrix = mainCamera.GetPerspectiveViewMatrix(); for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); // 원근 투영 행렬 * 뷰행렬 * 모델링 행렬 Matrix4x4 finalMatrix = pvMatrix * transform.GetModelingMatrix(); // 메시 그리기 DrawMesh3D(mesh, finalMatrix, gameObject.GetColor()); if (gameObject == PlayerGo) { // 플레이어 관련 정보 나타내기 // 플레이어의 클립 좌표 구하기 Vector4 clippedPos = pvMatrix * Vector4(transform.GetPosition()); // 클립 좌표의 네번째 요소 -Vz float cameraDepth = clippedPos.W; // -Vz가 0인 경우 0이 되지 않도록 보완해주기 if (cameraDepth == 0) cameraDepth = SMALL_NUMBER; // NDC의 깊이값 계산: 클립좌표의 세번째 요소 / 클립좌표의 네번째 요소 float ndcZ = clippedPos.Z / cameraDepth; r.PushStatisticText(\u0026#34;Player: \u0026#34; + transform.GetPosition().ToString()); r.PushStatisticText(\u0026#34;Depth: \u0026#34; + std::to_string(ndcZ)); r.PushStatisticText(\u0026#34;Distance: \u0026#34; + std::to_string(clippedPos.W)); } } r.PushStatisticText(\u0026#34;Camera: \u0026#34; + mainCamera.GetTransform().GetPosition().ToString()); r.PushStatisticText(\u0026#34;FOV : \u0026#34; + std::to_string(mainCamera.GetFOV())); } 원근 보정 매핑 문제가 한 가지 있다. 투영 전과 투영 후의 무게중심좌표가 달라져서 텍스처 매핑을 하면 이상하게 나온다. 예를 들어, 사영 공간의 점 $P_1$, $P_3$가 카메라 시야각에 걸쳐 있고, 카메라 정면에 위치한 점 $P_2$가 있다고 하자. 그러면 $P_2$를 투영한 후에 NDC좌표는 투영 평면의 정 중앙에 위치하며 무게중심좌표가 $0.5$가 된다. 하지만 투영 전을 보면 $0.5$보다 더 작은 값이 나올 것이다. 이것은 변환 과정에서 사영 공간의 마지막 요소인 $-v_z$로 나눴기 때문이다. 이런 반비례 관계때문에 이런 문제가 발생하였다. 따라서 NDC에서의 무게중심좌표가 아니라 투영 전 사영 공간의 무게중심좌표를 써야 한다. 만약 NDC에서의 무게중심좌표를 가지고 투영 전 사영 공간의 무게중심좌표를 알아낼 수 있다면 좋을 것이다. 투영 보정 보간(Perspective correction interpolation) 투영 전의 무게중심좌표 값을 계산해서 텍스처를 매핑하는 것이다. 반비례 함수 $y = -\\frac{1}{x}$가 가진 성질을 먼저 살펴보자. $x$축에 위치한 세 수 중에서 가운데 위치한 $4$의 무게중심좌표 $a$는 다음 식에 의해 구할 수 있으며 $a = 0.5$가 된다. $ 4 = a \\cdot 2 + (1-a) \\cdot 6 $ 그리고 $y$축에서 가운데 위치한 $-\\frac{1}{4}$의 경우 다음과 같으며 $a = 0.25$가 된다. $ -\\frac{1}{4} = a \\cdot - \\frac{1}{2} + (1 - a) \\cdot -\\frac{1}{6}$ 이 둘을 다음과 같이 나타내 보자. $$ x\u0026rsquo; = t_1 \\cdot x_1 + t_2 \\cdot x_2 (t_1 + t_2 = 1) $$ $$ y\u0026rsquo; = q_1 \\cdot y_1 + q_2 \\cdot y_2 (q_1 + q_2 = 1) $$ $x\u0026rsquo;$, $y\u0026rsquo;$는 서로 반비례 관계이므로 $y$값을 $\\frac{1}{x}$로 나타낼 수 있다. $$ \\frac{1}{x\u0026rsquo;} = q_1 \\cdot \\frac{1}{x_1} + q_2 \\cdot \\frac{1}{x_2} $$ $$ x\u0026rsquo; = \\frac{1}{ q_1 \\cdot \\frac{1}{x_1} + q_2 \\cdot \\frac{1}{x_2} }$$ 이 식을 다시 변환해보자. $$ q_1 \\cdot \\frac{x\u0026rsquo;}{x_1} + q_2 \\cdot \\frac{x\u0026rsquo;}{x_2} = 1 = t_1 + t_2 $$ 따라서 다음 식을 도출할 수 있다. $$ t_1 = \\frac{x\u0026rsquo;}{x_1}q_1 $$ $$ t_2 = \\frac{x\u0026rsquo;}{x_2}q_2 $$ 위의 식이 올바르게 적용되는지 확인해보자. $y$축에서 $q_1 = \\frac{1}{4}, q_2 = \\frac{3}{4}$ 이다. $x$축에서 $x_1 = 2, x_2 = 6, x\u0026rsquo; = 4$이다. $t_1 = \\frac{x\u0026rsquo;}{x_1}q_1 = \\frac{4}{2} \\cdot \\frac{1}{4} = 0.5$ $t_2 = \\frac{x\u0026rsquo;}{x_2}q_2 = \\frac{4}{6} \\cdot \\frac{3}{4} = 0.5$ 따라서 $t_1$, $t_2$가 $0.5$임을 알 수 있다. 두 점이 아닌 삼각형의 세 점으로 확장하고, $x$를 $-z$로 치환하면 최종 투영 보정 보간식을 얻을 수 있다. $$ z\u0026rsquo; = \\frac{1}{ q_1 \\cdot \\frac{1}{z_1} + q_2 \\cdot \\frac{1}{z_2} + q_3 \\cdot \\frac{1}{z_3}}$$ $$ t_1 = \\frac{z\u0026rsquo;}{z_1}q_1 $$ $$ t_2 = \\frac{z\u0026rsquo;}{z_2}q_2 $$ $$ t_3 = \\frac{z\u0026rsquo;}{z_3}q_3 $$ 다음은 원근 보정 매핑(Perspective correction mapping) 을 하는 코드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { //... // 두 점이 화면 밖을 벗어나는 경우 클리핑 처리 lowerLeftPoint.X = Math::Max(0, lowerLeftPoint.X); lowerLeftPoint.Y = Math::Min(_ScreenSize.Y, lowerLeftPoint.Y); upperRightPoint.X = Math::Min(_ScreenSize.X, upperRightPoint.X); upperRightPoint.Y = Math::Max(0, upperRightPoint.Y); // 각 정점마다 보존된 뷰 공간의 z값: 1/z1, 1/z2, 1/z3 float invZ0 = 1.f / InVertices[0].Position.W; float invZ1 = 1.f / InVertices[1].Position.W; float invZ2 = 1.f / InVertices[2].Position.W; // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { ScreenPoint fragment = ScreenPoint(x, y); Vector2 pointToTest = fragment.ToCartesianCoordinate(_ScreenSize); Vector2 w = pointToTest - InVertices[0].Position.ToVector2(); float wdotu = w.Dot(u); float wdotv = w.Dot(v); float s = (wdotv * udotv - wdotu * vdotv) * invDenominator; float t = (wdotu * udotv - wdotv * udotu) * invDenominator; float oneMinusST = 1.f - s - t; if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { // 투영보정에 사용할 공통 분모: z\u0026#39; float z = invZ0 * oneMinusST + invZ1 * s + invZ2 * t; float invZ = 1.f / z; Vector2 targetUV = ( InVertices[0].UV * oneMinusST * invZ0 + // q1/z1 InVertices[1].UV * s * invZ1 + // q2/z2 InVertices[2].UV * t * invZ2 // q3/z3 ) * invZ; r.DrawPoint(fragment, FragmentShader3D(mainTexture.GetSample(targetUV), LinearColor::White)); } } } } 깊이 버퍼 깊이 테스팅(Depth testing) 이전에 깊이 값을 구해서 멀리 떨어진 물체를 먼저 그렸다. 하지만 물체가 겹쳐 있다면 어떻게 할 것인가? 근본적인 해결방법은 게임 오브젝트 단위가 아니라, 삼각형의 픽셀단위로 깊이를 비교하고, 가까운 곳에 있는 픽셀만 그리는 것이다. 화면의 픽셀마다 깊이 값을 별도로 보관하는 깊이 버퍼(Depth buffer) 를 사용하면 되겠다. 현재 깊이 값을 깊이 버퍼에 저장된 값과 비교해서 현재 깊이 값이 작은 경우에만 픽셀을 찍도록 하면 된다. 이 작업을 깊이 테스팅이라고 한다. 삼각형을 구성하는 세 점의 깊이 값 $z_1$, $z_2$, $z_3$(범위: $[-1, 1]$)으로부터 각 픽셀의 무게중심좌표 $q_1$, $q_2$, $q_3$(범위: $[0, 1]$)을 사용해서 픽셀의 깊이 값을 구할 수 있겠다. $$ z\u0026rsquo; = q_1 \\cdot z_1 + q_2 \\cdot z_2 + q_3 \\cdot z_3$$ $z\u0026rsquo;$ 값의 범위는 $[-1, 1]$이 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { //... // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { //... if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { //... // 깊이 버퍼 테스팅 if (toggleDepthTesting) { // 깊이 테스팅 float newDepth = InVertices[0].Position.Z * oneMinusST + InVertices[1].Position.Z * s + InVertices[2].Position.Z * t; float prevDepth = r.GetDepthBufferValue(fragment); if (newDepth \u0026lt; prevDepth) { // 픽셀을 처리하기 전 깊이 값을 버퍼에 보관 r.SetDepthBufferValue(fragment, newDepth); } else { // 이미 앞에 무언가 그려져있으므로 픽셀그리기는 생략 continue; } } Vector2 targetUV = (InVertices[0].UV * oneMinusST * invZ0 + InVertices[1].UV * s * invZ1 + InVertices[2].UV * t * invZ2) * invZ; r.DrawPoint(fragment, FragmentShader3D(mainTexture.GetSample(targetUV), LinearColor::White)); } } } } 깊이 값은 카메라에서 멀어질 수록 급격히 $1$과 가까워진다. 이것은 NDC공간에서 깊이 값의 변화가 $y = -\\frac{1}{x}$로 비선형 형태를 띠기 때문이다. 따라서 이를 해결하기 위해 이전에 다뤘던 원근 보정 매핑 방식을 이용해서 뷰 공간의 깊이 값을 활용할 수 있겠다. $$ z\u0026rsquo; = \\frac{1}{ q_1 \\cdot \\frac{1}{z_1} + q_2 \\cdot \\frac{1}{z_2} + q_3 \\cdot \\frac{1}{z_3}}$$ 다음은 깊이 값을 $[0, 1]$범위로 바꾸어서 그 값에 따라 흑백 이미지로 출력하는 예제이다. 뷰 공간에서 절두체가 가지는 깊이의 범위는 원평면에서 근평면을 뺀 $f-n$이다. 따라서 이때 사용할 깊이값은 다음과 같다. $$c_{depth} = \\frac{z\u0026rsquo; - n}{f - n}$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get3DGameEngine(); const CameraObject\u0026amp; mainCamera = g.GetMainCamera(); // 카메라의 근평면과 원평면 값 float n = mainCamera.GetNearZ(); float f = mainCamera.GetFarZ(); //... // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { //... if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { //... if (IsDepthBufferDrawing()) { float grayScale = (newDepth + 1.f) * 0.5f; if (useLinearVisualization) { // 카메라로부터의 거리에 따라 균일하게 증감하는 흑백 값으로 변환 grayScale = (invZ - n) / (f - n); } // 뎁스 버퍼 그리기 r.DrawPoint(fragment, LinearColor::White * grayScale); } else { // 최종 보정보간된 UV 좌표 Vector2 targetUV = (InVertices[0].UV * oneMinusST * invZ0 + InVertices[1].UV * s * invZ1 + InVertices[2].UV * t * invZ2) * invZ; r.DrawPoint(fragment, FragmentShader3D(mainTexture.GetSample(targetUV), LinearColor::White)); } } } } } ","date":"2022-04-29T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-12/","title":"[Game Math] Chapter 12. 원근 투영: 화면에 현실감을 부여하는 변환"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n벡터의 외적 벡터의 외적(Cross product) $\\vec{a} = (a_x, a_y, a_z), \\vec{b} = (b_x, b_y, b_z)$ $\\vec{a} \\times \\vec{b} = (a_yb_z - a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x)$ Chapter 10에서 설명했던 회전의 순환 순서 $x$→$y$→$z$→$x$에 맞춰 벡터를 순서대로 나열하는 형태이며, 결과는 언제나 3차원 벡터가 된다. $x$성분의 결과를 만들기 위해 $x$와 관련없는 나머지 두 성분의 $y$와 $z$를 결합해서 만든다. 항상 같은 성분만 사용하는 내적과 대비된다. 외적의 성질 교환법칙이 성립하지 않는다. 위의 식을 살펴보면 교환법칙이 성립하지 않는 뺄셈을 사용한 것을 알 수 있다. $\\vec{a} \\times \\vec{b} \\neq \\vec{b} \\times \\vec{a}$ 뺄셈처럼, 순서를 바꿔서 연산하면 반대 방향이 나온다. $\\vec{a} \\times \\vec{b} = -\\vec{a} \\times \\vec{b}$ 결합법칙이 성립하지 않는다. $\\vec{a} \\times (\\vec{b} \\times \\vec{c}) \\neq (\\vec{a} \\times \\vec{b}) \\times \\vec{c}$ 덧셈에 대한 분배법칙은 성립한다. $\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$ 내적 외적 계산 결과 스칼라 벡터 교환법칙 성립함 성립하지 않음 결합법칙 성립하지 않음 성립하지 않음 분배법칙 성립함 성립함 연산 방법 같은 위치의 요소만 사용 다른 위치의 요소만 사용 평행성 판별 평행한 두벡터를 외적하면 항상 영벡터가 나온다. 동일한 벡터를 내적하면? 벡터 크기를 제곱한 값이 나왔다. 그렇다면 동일한 벡터를 외적하면? 그 결과는 항상 영벡터가 나온다. $\\vec{a} \\times \\vec{a} = (a_ya_z - a_za_y, a_za_x - a_xa_z, a_xa_y - a_ya_x) = (0, 0, 0)$ 이것은 반대 방향의 벡터 $-\\vec{a}$를 외적하는 경우에도 동일하다. $\\vec{a} \\times -\\vec{a} = (-a_ya_z + a_za_y, -a_za_x + a_xa_z, -a_xa_y + a_ya_x) = (0, 0, 0)$ 평행하지만 크기가 다른 벡터 $k \\cdot \\vec{a}$를 사용해도 마찬가지이다. $\\vec{a} \\times (k \\cdot \\vec{a}) = (ka_ya_z - ka_za_y, ka_za_x - ka_xa_z, ka_xa_y - ka_ya_x) = (0, 0, 0)$ 벡터 $\\vec{b}$를 벡터 $\\vec{a}$에 수평인 벡터 $\\vec{b_{\\parallel}}$와 수직인 벡터 $\\vec{b_{\\perp}}$로 분리하여, 그 둘의 덧셈으로 나타낼 수 있다. $\\vec{a} = \\vec{b_{\\parallel}} + \\vec{b_{\\perp}}$ 이것을 $\\vec{a} \\times \\vec{b}$에 적용하면 다음과 같다. $\\vec{a} \\times \\vec{b} = \\vec{a} \\times (\\vec{b_{\\parallel}} + \\vec{b_{\\perp}})= \\vec{a} \\times \\vec{b_{\\parallel}} + \\vec{a} \\times \\vec{b_{\\perp}}$ 여기서 $\\vec{a} \\times \\vec{b_{\\parallel}}$는 서로 평행해서 영벡터이므로 다음과 같아진다. $\\vec{a} \\times \\vec{b} = \\vec{a} \\times \\vec{b_{\\perp}}$ 이처럼 외적은 상대방에 직교하는 벡터 성분만 사용되는 성질이 있다. 외적의 크기는 $\\sin$함수에 비례하며, 두 벡터가 만드는 평행사변형의 넓이와 같다. 아래 그림을 보면, (1)과 같이 두 벡터의 사잇각이 크면 직교 성분 $\\vec{b_{\\perp}}$의 크기는 커지고, 반대로 (2)와 같이 사잇각이 작으면 $\\vec{b_{\\perp}}$의 크기는 작아진다. 따라서, 외적의 크기도 $\\sin$함수에 비례할 것이다. 이것을 수식으로 확인해보기 위해 $|\\vec{a} \\times \\vec{b}|^2$, $(|\\vec{a}||\\vec{b}|)^2$, $(\\vec{a} \\cdot \\vec{b})^2$를 구해보면 다음과 같은 관계를 도출할 수 있다. (풀이 생략) $|\\vec{a} \\times \\vec{b}|^2 = (|\\vec{a}||\\vec{b}|)^2 - (\\vec{a} \\cdot \\vec{b})^2$ $ = (|\\vec{a}||\\vec{b}|)^2 - (|\\vec{a}||\\vec{b}|\\cos\\theta)^2$ $ = (|\\vec{a}||\\vec{b}|)^2 (1 - \\cos^2\\theta)$ $ = (|\\vec{a}||\\vec{b}|)^2 \\sin^2\\theta$ $|\\vec{a} \\times \\vec{b}| = |\\vec{a}||\\vec{b}| |\\sin\\theta|$ 이처럼 벡터 외적의 크기는 $\\sin$함수에 비례하는 것을 알 수 있다. 또한 이것은 두 벡터가 만드는 평행사변형의 넓이와 같다. 내적 외적 판별성($0$이 된다) 직교성 평행성 삼각함수 $\\cos\\theta$ $\\sin\\theta$ 법선 벡터 벡터의 외적은 두 벡터에 직교하는 벡터를 생성한다. 두 벡터의 외적에다가 한 가지 벡터를 내적하면 어떻게 될까? $\\vec{a} \\cdot (\\vec{a} \\times \\vec{b}) = a_xa_yb_z - a_xa_zb_y + a_ya_zb_x - a_ya_xb_z + a_za_xb_y - a_za_yb_x = 0$ $\\vec{b} \\cdot (\\vec{a} \\times \\vec{b}) = b_xa_yb_z - b_xa_zb_y + b_ya_zb_x - b_ya_xb_z + b_za_xb_y - b_za_yb_x = 0$ 그 결과는 늘 $0$이 되며 이것은 외적 결과값이 두 벡터에 직교한다는 의미가 된다. Chapter 3에서 말했듯이, 선형 독립 관계를 가지는 두 벡터의 선형 결합은 평면을 만든다. 그렇다면 벡터의 외적은 그 평면이 향하는 방향(직교)에 대한 벡터를 만드는 것이다. 이 벡터를 법선 벡터(Normal vector) 또는 노멀 벡터라고 한다. 외적은 교환법칙이 성립하지 않는다. 따라서 연산의 순서를 바꾸면 반대방향의 법선 벡터가 생성된다. 오른손 좌표계를 사용한다면, 오른손 법칙을. 왼손 좌표계를 사용한다면, 왼손 법칙을 사용해서 법선 벡터의 방향을 파악할 수 있다. 좌우 방향 판별 월드 공간의 $y$축 $\\vec{y} = (0, 1, 0)$에 직교하는 평면에 캐릭터와 몬스터가 놓여 있다. 이 때, 캐릭터의 정면을 향하는 시선 벡터 $\\vec{f}$와 캐릭터에서 몬스터로 향하는 벡터 $\\vec{v}$를 외적하면? 결과 벡터는 오른손 법칙의 경우 평면의 위쪽으로 향할 것이다.\n외적의 결과에 평면의 위쪽 방향을 나타내는 벡터 $\\vec{y}$를 내적하면, 두 벡터의 방향이 같으면 양수가 나오고, 반대 방향이라면 음수가 나온다. 몬스터의 위치 판별식의 값 왼쪽에 있다 $(\\vec{f} \\times \\vec{v}) \\cdot \\vec{y} \u0026gt; 0$ 오른쪽에 있다 $(\\vec{f} \\times \\vec{v}) \\cdot \\vec{y} \u0026lt; 0$ 정확히 시선 방향과 일치한다 $(\\vec{f} \\times \\vec{v}) = 0$ 이러한 성질은 외적이 $\\sin$함수에 비례하는 성질을 가졌기 때문이다. 반면, 내적은 $\\cos$함수에 비례하기 때문에 앞뒤 판별에 사용된다. 내적 외적 방향 판별 앞뒤 좌우 벡터로부터 회전행렬 생성 Chapter 10에서는 오일러 각 방식을 사용해서 카메라의 회전을 지정하였다. 외적을 사용하면 카메라의 시선 벡터 하나를 가지고 카메라를 구성하는 세 가지 로컬 축을 구할 수가 있다. 로컬 $z$축 물체의 위치에서 카메라의 위치를 뺀 후 크기를 $1$로 정규화 시킨 시선 벡터이다. 로컬 $x$축 월드 공간의 $y$축(업벡터라고 한다; Up vector)과 카메라의 로컬 $x$축을 외적한 후 정규화하면 얻을 수 있다. 로컬 $y$축 로컬 $z$축과 로컬 $x$축을 외적하면 얻을 수 있다. 따라서 시선 벡터 $\\vec{v}$와 업 벡터 $\\vec{u}$로부터 다음과 같이 구할 수 있다. $\\vec{x} = \\frac{\\vec{v} \\times \\vec{u}}{|\\vec{v} \\times \\vec{u}|}$ $\\vec{y} = \\vec{x} \\times \\vec{z}$ $\\vec{z} = \\frac{\\vec{v}}{|\\vec{v}|}$ 그렇다면 카메라 트랜스폼의 회전 행렬 $R$은 로컬 벡터를 열벡터로 지정해서 다음과 같이 생성할 수 있다. $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 예외 상황 (1) 카메라의 위쪽방향이 월드 공간의 $y$축과 반대인 경우(뒤집힌 경우) 월드 공간 $y$축과 반대인 $(0, -1, 0)$을 사용해야 한다. (2) 카메라의 시선방향이 월드 공간의 $y$축과 평행한 경우 로컬 $z$축에 직교하는 로컬 $x$축의 값을 수동으로 지정해야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 목표물의 위치로부터 카메라의 세 로컬 축을 구해서 트랜스폼에 반영한다. // InUp은 카메라가 뒤집힌 경우에는 반대 방향의 월드 Y축이 전달되겠다. (1) void CameraObject::SetLookAtRotation(const Vector3\u0026amp; InTargetPosition, const Vector3\u0026amp; InUp) { Vector3 localX, localY, localZ; localZ = (InTargetPosition - _Transform.GetPosition()).Normalize(); // 시선 방향과 월드 Y축(0, 1, 0)이 평행한 경우 (2) // 단위 벡터 Z축의 y값이 1과 가까우면... if (Math::Abs(localZ.Y) \u0026gt;= (1.f - SMALL_NUMBER)) { localX = Vector3::UnitX; // 로컬 X 좌표 값을 임의로 지정. } else { localX = InUp.Cross(localZ).Normalize(); } localY = localX.Cross(localX); // 최종 계산된 세 로컬 축을 카메라의 트랜스폼에 반영한다. _Transform.SetLocalAxes(localX, localY. localZ); } 렌더링 계산량을 줄여주는 백페이스 컬링 백페이스 컬링(Backface culling) 카메라와 마주보지 않는 메시의 뒷면은 그리지 않고 건너뛰는 것이다. 덕분에 빠르게 렌더링할 수 있겠다. 삼각형의 세 점을 지정하는 인덱스 버퍼에는 점의 순서가 나열되어있다. 외적을 사용해서 삼각형이 향하는 방향을 파악할 수 있다. 이러한 삼각형의 방향과 카메라의 시선 방향을 내적해서 그 결과 값이 음수라면, 방향이 마주보고 있다는 것이므로 그린다. 나머지 경우에는 두 방향이 같은 방향을 바라보는 것이므로 그리지 않는다. 백페이스 컬링 구현 코드 삼각형의 면이 향하는 법선 벡터 $\\vec{n} = \\vec{P_0P_1} \\times \\vec{P_0P_2}$ 뷰 공간에서 카메라가 바라보는 시선이 $-z$축이므로 $(0, 0, -1)$과 내적을 한다. $(n_x, n_y, n_z) \\cdot (0, 0, -1) \u0026lt; 0$ 일 때만 그린다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void SoftRenderer::DrawTriangle3D(std::vector\u0026lt;Vertex3D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get3DGameEngine(); if (useBackfaceCulling) { // 백페이스 컬링 ( 뒷면이면 그리기 생략 ) Vector3 edge1 = (InVertices[1].Position - InVertices[0].Position).ToVector3(); Vector3 edge2 = (InVertices[2].Position - InVertices[0].Position).ToVector3(); Vector3 faceNormal = edge1.Cross(edge2); Vector3 viewDirection = -Vector3::UnitZ; if (faceNormal.Dot(viewDirection) \u0026gt;= 0.f) { return; } } LinearColor finalColor = _WireframeColor; if (InColor != LinearColor::Error) { finalColor = InColor; } r.DrawLine(InVertices[0].Position, InVertices[1].Position, finalColor); r.DrawLine(InVertices[0].Position, InVertices[2].Position, finalColor); r.DrawLine(InVertices[1].Position, InVertices[2].Position, finalColor); } 오일러 각의 문제를 해결하는 로드리게스 회전 공식 Chapter 10에서 본 것처럼, 오일러 각은 짐벌락 현상이 발생하고 회전 보간이 어렵다는 문제가 있었다. 축-각 회전(Axis-Angle rotation)을 사용해서 해결할 수 있다. 임의의 축에 직교하는 평면에서 회전을 하는 방법이다. 아래 그림과 같을 때 $\\vec{u\u0026rsquo;}$를 구해보자. 먼저 점 $P$의 좌표가 $P = (x, y, z, 1)$이라면 $\\vec{u} = P - O$이므로 $\\vec{u} = (x, y, z, 0)$라고 할 수 있겠다. $\\vec{OO\u0026rsquo;}$의 경우에는 Chapter 7에서 본 투영 공식에 의해서 구할 수 있다. $\\vec{v} = (\\vec{u} \\cdot \\hat{n}) \\cdot \\hat{n}$ 이것을 간단히 $\\vec{v}$라고 부르자. 그렇다면 $\\vec{O\u0026rsquo;P}$의 경우에는 $\\vec{u} - \\vec{v}$로 구할 수 있다. 이번에는 회전 평면을 위에서 내려다 보자. 벡터 $\\vec{O\u0026rsquo;P\u0026rsquo;}$의 가로 성분 $\\cos\\theta \\cdot (\\vec{u} - \\vec{v})$ 벡터 $\\vec{O\u0026rsquo;P\u0026rsquo;}$의 세로 성분 세로 성분과 같은 방향을 향하는 벡터를 $\\vec{O\u0026rsquo;Q}$라고 하자. 이것은 법선 벡터 $\\hat{n}$와 벡터 $\\vec{OP\u0026rsquo;}$를 외적해서 얻을 수 있다. $\\vec{O\u0026rsquo;Q} = \\hat{n} \\times (\\vec{u} - \\vec{v})$ 여기에 $\\sin\\theta$를 곱하면 세로 성분에 대한 벡터를 얻을 수 있다. $\\sin\\theta \\cdot (\\hat{n} \\times (\\vec{u} - \\vec{v}))$ 따라서 다음과 같이 벡터 $\\vec{O\u0026rsquo;P\u0026rsquo;}$를 계산할 수 있겠다. $\\vec{O\u0026rsquo;P\u0026rsquo;} = \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times (\\vec{u} - \\vec{v}))$ $ = \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u} - \\hat{n} \\times \\vec{v})$ $\\hat{n}$과 $\\vec{v}$는 평행하므로 $\\hat{n} \\times \\vec{v}$는 $0$이므로 다음과 같이 정리된다. $\\vec{O\u0026rsquo;P\u0026rsquo;} = \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u})$ 이제 우리의 목표인 $\\vec{u\u0026rsquo;}$를 구해보자. 이것은 $\\vec{O\u0026rsquo;P\u0026rsquo;}$에다가 $\\vec{v}$를 더해서 얻을 수 있다. $\\vec{u\u0026rsquo;} = \\vec{v} + \\cos\\theta \\cdot (\\vec{u} - \\vec{v}) + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u})$ 이제 $\\vec{v}$를 $(\\vec{u} \\cdot \\hat{n}) \\cdot \\hat{n}$로 치환하면 최종 수식이 유도된다. $\\vec{u\u0026rsquo;} = \\cos\\theta \\cdot \\vec{u} + (1- \\cos\\theta)(\\vec{u} \\cdot \\hat{n})\\cdot \\hat{n} + \\sin\\theta \\cdot (\\hat{n} \\times \\vec{u})$ 이 공식은 프랑스 수학자 로드리게스가 1840년에 발표했으며, 그의 이름을 인용해서 로드리게스 회전 공식(Rodrigues\u0026rsquo; rotation formula)이라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 메시를 그리는 함수 void SoftRenderer::DrawMesh3D(const Mesh\u0026amp; InMesh, const Matrix4x4\u0026amp; InMatrix, const Vector3\u0026amp; InScale, const LinearColor\u0026amp; InColor) { size_t vertexCount = InMesh.GetVertices().size(); size_t indexCount = InMesh.GetIndices().size(); size_t triangleCount = indexCount / 3; // 렌더러가 사용할 정점 버퍼와 인덱스 버퍼로 변환 std::vector\u0026lt;Vertex3D\u0026gt; vertices(vertexCount); std::vector\u0026lt;size_t\u0026gt; indice(InMesh.GetIndices()); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = Vector4(InMesh.GetVertices()[vi]); if (InMesh.HasColor()) { vertices[vi].Color = InMesh.GetColors()[vi]; } if (InMesh.HasUV()) { vertices[vi].UV = InMesh.GetUVs()[vi]; } } // 정점 변환 진행 for (Vertex3D\u0026amp; v : vertices) { float sin = 0.f, cos = 0.f; Math::GetSinCos(sin, cos, thetaDegree); Vector3 u = v.Position.ToVector3(); // 원점에서 정점으로 향하는 벡터 u. 계산의 편의를 위해 4차원 벡터의 마지막 요소는 생략했다. float udotn = u.Dot(n); Vector3 ncrossu = n.Cross(u); // 스케일을 적용한 후 로드리게스 공식으로 회전을 적용한다. Vector3 result = Vector3(u * cos + n * (1.f - cos) * udotn + ncrossu * sin) * InScale; // 그다음 뷰 행렬(InMatrix로 전달됨)을 적용한다. v.Position = InMatrix * Vector4(result); } // 삼각형 별로 그리기 for (int ti = 0; ti \u0026lt; triangleCount; ++ti) { int bi0 = ti * 3, bi1 = ti * 3 + 1, bi2 = ti * 3 + 2; std::vector\u0026lt;Vertex3D\u0026gt; tvs = { vertices[indice[bi0]] , vertices[indice[bi1]] , vertices[indice[bi2]] }; size_t triangles = tvs.size() / 3; for (size_t ti = 0; ti \u0026lt; triangles; ++ti) { size_t si = ti * 3; std::vector\u0026lt;Vertex3D\u0026gt; sub(tvs.begin() + si, tvs.begin() + si + 3); DrawTriangle3D(sub, InColor, FillMode::Color); } } } 로드리게스 회전 공식을 활용하면 오일러 각으로 구현하기 어려운 임의의 축에 대한 회전 변환을 수행할 수 있다. 하지만, 행렬로의 변환이 어려워서 지금까지 구축했던 렌더링 파이프라인에 연동하기가 까다롭다. 그래서 게임 엔진에서는 동일한 기능을 제공하지만 간결하고, 행렬로 변환이 용이한 사원수(Chapter 16)를 사용한다. 삼중곱 삼중곱(Triple product) 연산 벡터의 외적과 내적을 두 번 연속 사용 하는 연산이다. 다음과 같은 경우의 수가 있다. (1) $\\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w})$ → 결과 값이 스칼라이므로 제외한다. (2) $\\vec{u} \\cdot (\\vec{v} \\times \\vec{w})$ (3) $\\vec{u} \\times (\\vec{v} \\cdot \\vec{w})$ → 벡터와 스칼라는 외적할 수 없으므로 연산이 불가능해서 제외한다. (4) $\\vec{u} \\times (\\vec{v} \\times \\vec{w})$ 스칼라 삼중곱 스칼라 삼중곱(Scalar triple product) (2) $\\vec{u} \\cdot (\\vec{v} \\times \\vec{w})$ 왼쪽과 오른쪽 판별 방법과, 벡페이스 컬링에 사용했던 공식이 바로 스칼라 삼중곱이었다. $(\\vec{f} \\times \\vec{v}) \\cdot \\vec{y}$ $-\\hat{z} \\cdot (\\vec{P_0P_1} \\times \\vec{P_0P_2})$ 스칼라 삼중곱의 절댓값은 세 벡터가 만드는 평행육면체(Parallelepiped)의 부피를 의미한다. 임의의 벡터 $\\vec{u}$를 법선 벡터 $\\vec{v} \\times \\vec{w}$에 투영한 벡터의 높이는 $|\\vec{u}|\\cos\\theta$이다. 여기에 평행사변형의 넓이 $|\\vec{v} \\times \\vec{w}|$를 곱하면 육면체의 부피가 나온다. $|\\vec{u}||\\vec{v} \\times \\vec{w}|\\cos\\theta$ 이것은 스칼라 삼중곱이 만들어내는 값의 절댓값과 동일하다. $|\\vec{u} \\cdot (\\vec{v} \\times \\vec{w})| = |\\vec{u}||\\vec{v} \\times \\vec{w}|\\cos\\theta$ 이 세 백터에서 바닥에 해당하는 두 벡터를 다른 벡터로 변경해도 최종 육면체의 부피 값은 변하지 않아서 삼중곱의 결과는 동일하다. 따라서 다음과 같은 성질을 도출할 수 있다. $\\vec{u} \\cdot (\\vec{v} \\times \\vec{w}) = \\vec{v} \\cdot (\\vec{w} \\times \\vec{u}) = \\vec{w} \\cdot (\\vec{u} \\times \\vec{v})$ 스칼라 삼중곱이 $0$이 아니면 세 백터는 모두 선형 독립의 관계를 가진다. Chapter 5에서 보았던 행렬식의 절댓값은 평행사변형의 넓이였다. 이것은 평면에서 평행사변형을 이루는 두 벡터가 서로 선형 독립의 관계를 가지는지 판단하는 수식이었다. 외적으로 생성된 벡터의 크기는 평행사변형의 넓이와 같다. 따라서 스칼라 삼중곱은 3차원 공간의 세 벡터가 모두 선형 독립의 관계를 가지는지 판단하는 판별식으로 생각할 수 있다. 스칼라 삼중곱이 $0$이 나오는 경우 (1) 외적의 결과가 영벡터이므로 스칼라 삼중곱이 $0$이 된다. (2) 외적의 결과로 만들어진 법선 벡터에 벡터 $\\vec{u}$가 직교하므로 이의 내적은 $0$이 된다. 따라서 스칼라 삼중곱은 $0$이 된다. 벡터 삼중곱 벡터 삼중곱(Vector triple product) (4) $\\vec{u} \\times (\\vec{v} \\times \\vec{w})$ 삼중곱 전개(Triple product expansion) 또는 라그랑주 공식(Lagrange\u0026rsquo;s formula) 벡터 삼중곱은 다음과 같은 성질을 지닌다. $(\\vec{u} \\cdot \\vec{w}) \\cdot \\vec{v} - (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w}$ 이것을 직접 확인해보자. (풀이 간단 설명) $(\\vec{u} \\times (\\vec{v} \\times \\vec{w}))_x = v_x(\\vec{u} \\cdot \\vec{w}) - w_x(\\vec{u} \\cdot \\vec{v})$ $(\\vec{u} \\times (\\vec{v} \\times \\vec{w}))_y = v_y(\\vec{u} \\cdot \\vec{w}) - w_y(\\vec{u} \\cdot \\vec{v})$ $(\\vec{u} \\times (\\vec{v} \\times \\vec{w}))_z = v_z(\\vec{u} \\cdot \\vec{w}) - w_z(\\vec{u} \\cdot \\vec{v})$ 이것은 $a\\vec{v} + b\\vec{w}$형태의 선형 결합식이므로, 벡터 삼중곱으로 만들어지는 벡터는 두 벡터$\\vec{v}$, $\\vec{w}$가 만드는 평면에 속한다. 이것은 2차원에서 동일 평면에 있는 직교 벡터를 구하는 데도 유용하게 쓸 수 있다. $(\\vec{u} \\times \\vec{v}) \\times \\vec{u}$ ","date":"2022-04-28T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-11/","title":"[Game Math] Chapter 11. 외적: 3차원 공간의 분석과 응용"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n3차원 공간의 설계 $x$축에서 $y$축 방향으로 손을 감았을 때, $z$축이 어느쪽 손의 엄지 손가락의 방향과 일치하는가에 따라 나뉜다.\n오른손 좌표계(Right-handed coordinate system) 왼손 좌표계(Left-handed coordinate system) 프로그램 마다 각 축의 용도를 다르게 설정한다.\n아래 그림에서 (a)3DS맥스는 $z$업 오른손 좌표계이고, (b)유니티는 $y$업, (c)언리얼은 $z$업 왼손 좌표계이다. (저자가 제시한) 우리의 좌표계는 유니티 좌표계에서 $z$축의 방향이 반대인 형상이다. ($y$업 오른손 좌표계)\n3차원 공간의 트랜스폼 3차원 공간 역시 이동 변환을 위해서 한 차원 더 늘어난 4차원 공간을 사용한다.\n$$S = \\begin{bmatrix} s_x \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; s_y \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; s_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 3차원 공간의 회전 변환은?\n세 가지 표준기저벡터가 동일한 크기와 직교성을 유지한 상태로 함께 움직여야한다. 회전변환으로 달라진 세 표준기저벡터값을 열벡터로 꽂아 널어 회전변환행렬 $R$을 만들 수 있을 것이다. 오일러 각 오일러 각(Euler\u0026rsquo;s angle) 3차원 공간에서 물체가 놓인 방향을 3개의 각을 사용해서 표시하는 방법이다. 오일러 각은 표준기저벡터를 중심으로해서 회전한 각의 크기로 나타낸다. $(\\theta_x, \\theta_y, \\theta_z)$ 하지만 소프트웨어마다 $x$, $y$, $z$축의 용도가 다르다는 문제가 있다. 예를 들면 언리얼에서 사용하는 $x$축 회전은 유니티의 $x$축 회전과 다르게 동작하므로, 언리얼 엔진에서의 오일러 각 정보를 그대로 유니티 엔진으로 넘겨서 사용할 수 없다. 이런 문제를 해결하기 위해 회전의 움직임으로 회전 동작을 구분하는 방법을 사용한다. 요, 롤, 피치의 움직임으로 오일러 각을 지정하면, 서로 다른 좌표계를 사용하는 프로그램 간에도 데이터를 쉽게 변환할 수 있다. 회전 방향 유니티 언리얼 요(Yaw) 위 $y$ $z$ 롤(Roll) 앞 $z$ $x$ 피치(Pitch) 오른쪽 $x$ $y$ 오일러 각에서 회전은 표준기저벡터를 중심으로 진행되는 세 번의 연속적인 회전을 의미한다. 따라서 다음과 같이 각 기저축의 회전행렬을 구할 수 있겠다. 3차원 공간에서는 $x$→$y$→$z$→$x$→$y$의 순서로 세 축이 순환된다. $x$축 회전은 $yz$평면의 회전을 의미한다. $$R_x = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos\\theta \u0026amp; -\\sin\\theta \\\\ 0 \u0026amp; \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ $y$축 회전은 $zx$평면의 회전을 의미한다. (위의 순서에 따르므로 $xz$가 아니다) $$R_y = \\begin{bmatrix} \\cos\\theta \u0026amp; 0 \u0026amp; \\sin\\theta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin\\theta \u0026amp; 0 \u0026amp; \\cos\\theta \\end{bmatrix}$$ $z$축 회전은 $xy$평면의 회전을 의미한다. $$R_z = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \\\\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 회전행렬의 유도 각 기저축의 회전행렬을 순서대로 적용해서 최종 회전행렬을 만들어야 한다. 어떤 순서로 적용할 것인가에 대한 경우의 수는 다양하다. 그 중에서 언리얼 엔진은 $Roll$→$Pitch$→$Yaw$의 순서를 채택한다. 이 순서로 회전행렬 $R$을 구하면 다음과 같다. $ R = R_{yaw} \\cdot R_{pitch} \\cdot R_{roll} $ (저자가 제시한) 우리의 좌표계는 $Roll$→$Pitch$→$Yaw$가 $z$→$x$→$y$에 대응되므로 요, 피치, 롤 각의 값을 $\\alpha$, $\\beta$, $\\gamma$라고 한다면 행렬 곱은 다음과 같이 계산할 수 있다. $$R_{\\alpha} \\cdot R_{\\beta} \\cdot R_{\\gamma} = \\begin{bmatrix} \\cos\\alpha \u0026amp; 0 \u0026amp; \\sin\\alpha \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin\\alpha \u0026amp; 0 \u0026amp; \\cos\\alpha \\end{bmatrix} \\begin{bmatrix} \\cos\\beta \u0026amp; 0 \u0026amp; \\sin\\beta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin\\beta \u0026amp; 0 \u0026amp; \\cos\\beta \\end{bmatrix} \\begin{bmatrix} \\cos\\gamma \u0026amp; -\\sin\\gamma \u0026amp; 0 \\\\ \\sin\\gamma \u0026amp; \\cos\\gamma \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$= \\begin{bmatrix} \\cos\\alpha\\cos\\gamma + \\sin\\alpha\\sin\\beta\\sin\\gamma \u0026amp; -\\cos\\alpha\\sin\\gamma + \\sin\\alpha\\sin\\beta\\cos\\gamma \u0026amp; \\sin\\alpha\\cos\\beta \\\\ \\cos\\beta\\sin\\gamma \u0026amp; \\cos\\beta\\cos\\gamma \u0026amp; -\\sin\\beta \\\\ -\\sin\\alpha\\cos\\gamma + \\cos\\alpha\\sin\\beta\\sin\\gamma \u0026amp; \\sin\\alpha\\sin\\gamma + \\cos\\alpha\\sin\\beta\\cos\\gamma \u0026amp; \\cos\\alpha\\cos\\beta \\end{bmatrix}$$ 이렇게 계산한 회전행렬의 열벡터는 표준기저벡터가 회전 변환된 로컬 축을 의미한다. 따라서 다음과 같이 나타낼 수 있겠다. $x_{local} = ( \\cos\\alpha\\cos\\gamma + \\sin\\alpha\\sin\\beta\\sin\\gamma, \\cos\\beta\\sin\\gamma, -\\sin\\alpha\\cos\\gamma + \\cos\\alpha\\sin\\beta\\sin\\gamma )$ $y_{local} = ( -\\cos\\alpha\\sin\\gamma + \\sin\\alpha\\sin\\beta\\cos\\gamma, \\cos\\beta\\cos\\gamma, \\sin\\alpha\\sin\\gamma + \\cos\\alpha\\sin\\beta\\cos\\gamma )$ $z_{local} = ( \\sin\\alpha\\cos\\beta, -\\sin\\beta, \\cos\\alpha\\cos\\beta )$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct Rotator { public: // 0~360 범위로 각도 값을 바꿔준다. FORCEINLINE void Clamp() { Yaw = GetAxisClampedValue(Yaw); Roll = GetAxisClampedValue(Roll); Pitch = GetAxisClampedValue(Pitch); } FORCEINLINE float GetAxisClampedValue(float InRotatorValue) { float angle = Math::FMod(InRotatorValue, 360.f); if (angle \u0026lt; 0.f) { angle += 360.f; } return angle; } // 오일러각으로 회전된 3차원 공간의 로컬 축을 계산해서 반환한다. FORCEINLINE void GetLocalAxes(Vector3\u0026amp; OutRight, Vector3\u0026amp; OutUp, Vector3\u0026amp; OutForward) { float cy = 0.f, sy = 0.f, cp = 0.f, sp = 0.f, cr = 0.f, sr = 0.f; Math::GetSinCos(sy, cy, Yaw); Math::GetSinCos(sp, cp, Pitch); Math::GetSinCos(sr, cr, Roll); OutRight = Vector3(cy * cr + sy * sp * sr, cp * sr, -sy * cr + cy * sp * sr); OutUp = Vector3(-cy * sr + sy * sp * cr, cp * cr, sy * sr + cy * sp * cr); OutForward = Vector3(sy * cp, -sp, cy * cp); } public: // 오일러 각을 구성하는 요, 롤, 피치는 각도법을 사용해서 관리한다. float Yaw = 0.f; float Roll = 0.f; float Pitch = 0.f; } 3차원 공간의 트랜스폼도 회전 변환이 발생할 때마다 로컬 축 데이터를 갱신한다면, 로컬 축 벡터가 $\\vec{x} = (x_x, x_y, x_z), \\vec{y} = (y_x, y_y, y_z), \\vec{z} = (z_x, z_y, z_z)$일 때 이들을 열벡터로 꽂아넣어 회전행렬을 구할 수 있다. $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TransformComponent { public: // 오일러 각의 정보가 변경되면 항상 Update함수를 호출해서 로컬 축을 갱신한다. void AddYawRotation(float InDegree) { _Rotation.Yaw += InDegree; Update(); } void AddRollRotation(float InDegree) { _Rotation.Roll += InDegree; Update(); } void AddPitchRotation(float InDegree) { _Rotation.Pitch += InDegree; Update(); } void SetRotation(const Rotator \u0026amp; InRotation) { _Rotation = InRotation; Update(); } const Vector3\u0026amp; GetLocalX() const { return _Right; } const Vector3\u0026amp; GetLocalY() const { return _Up; } const Vector3\u0026amp; GetLocalZ() const { return _Forward; } // 로컬 축 값을 직접 설정한다. void SetLocalAxes(const Vector3 \u0026amp; InRight, const Vector3 \u0026amp; InUp, const Vector3 \u0026amp; InForward) { _Right = InRight; _Up = InUp; _Forward = InForward; } private: FORCEINLINE void Update(); Vector3 _Position = Vector3::Zero; Rotator _Rotation; // 트랜스폼의 회전을 관리하기 위해 오일러 각 방식의 Rotator 구조체를 사용한다. Vector3 _Scale = Vector3::One; Vector3 _Right = Vector3::UnitX; Vector3 _Up = Vector3::UnitY; Vector3 _Forward = Vector3::UnitZ; }; FORCEINLINE void TransformComponent::Update() { _Rotation.Clamp(); // 오일러 각의 범위를 0~360 범위로 바꿔준다. _Rotation.GetLocalAxes(_Right, _Up, _Forward); // 오일러 각으로부터 세 로컬 축 값을 가져와서 로컬 축에 저장한다. } 3차원 모델링 행렬 크기, 회전, 이동 변환행렬 $$S = \\begin{bmatrix} s_x \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; s_y \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; s_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 모델링 행렬 $$M = T \\cdot R \\cdot S = \\begin{bmatrix} x_xs_x \u0026amp; y_xs_y \u0026amp; z_xs_z \u0026amp; t_x \\\\ x_ys_x \u0026amp; y_ys_y \u0026amp; z_ys_z \u0026amp; t_y \\\\ x_zs_x \u0026amp; y_zs_y \u0026amp; z_zs_z \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 1 2 3 4 5 6 7 8 9 10 // 3차원 모델링 행렬을 생성한다. FORCEINLINE Matrix4x4 TransformComponent::GetModelingMatrix() const { return Matrix4x4( Vector4(_Right * _Scale.X, false), // 두번째 인자값이 false이면 점이고, 네번째 원소값이 0이 된다. Vector4(_Up * _Scale.Y, false), Vector4(_Forward * _Scale.Z, false), Vector4(_Position, true) // 두번째 인자값이 true이면 벡터이고, 네번째 원소값이 1이 된다. ); } 카메라 공간 2차원 카메라를 구현할 때에는 이동 기능만 부여 했지만, 3차원 공간의 카메라에는 이동과 회전 기능을 함께 부여할 것이다. 카메라의 경우 크기의 개념이 없기 때문에 제외한다. 카메라 트랜스폼에 저장된 위치값을 $t = (t_x, t_y, t_z)$로 지정하고, 로컬 축 값을 각각 $\\vec{x} = (x_x, x_y, x_z), \\vec{y} = (y_x, y_y, y_z), \\vec{z} = (z_x, z_y, z_z)$로 지정한다면 이동 행렬과 회전 행렬은 다음과 같다. $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} x_x \u0026amp; y_x \u0026amp; z_x \u0026amp; 0 \\\\ x_y \u0026amp; y_y \u0026amp; z_y \u0026amp; 0 \\\\ x_z \u0026amp; y_z \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ Chapter 9에서 보았듯이 상대 좌표는 역행렬로 구할 수 있다. 이동 행렬의 역행렬은 덧셈의 역원인 반대수로 구한다. 회전 행렬의 역행렬은 전치행렬로 구한다. $$T^{-1} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -t_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -t_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R^{-1} = \\begin{bmatrix} x_x \u0026amp; x_y \u0026amp; x_z \u0026amp; 0 \\\\ y_x \u0026amp; y_y \u0026amp; y_z \u0026amp; 0 \\\\ z_x \u0026amp; z_y \u0026amp; z_z \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 순서는? 모든 물체의 좌표를 카메라를 중심으로 옮긴 후, 회전을 해야하므로 이동의 역행렬 → 회전의 역행렬 순이다. 이것은 트랜스폼의 순서를 바꾸는 것이며, 즉 크기 변환 $S$를 제외한 모델링 행렬의 역행렬이 뷰 행렬이 된다. $M^{-1} = (T \\cdot R)^{-1} = R^{-1} \\cdot T^{-1}$ 따라서 뷰 행렬은 다음과 같으며, 마지막 4열은 내적을 사용해서 간단하게 정리할 수 있다. $$R^{-1} \\cdot T^{-1} = \\begin{bmatrix} x_x \u0026amp; x_y \u0026amp; x_z \u0026amp; -x \\cdot t \\\\ y_x \u0026amp; y_y \u0026amp; y_z \u0026amp; -y \\cdot t \\\\ z_x \u0026amp; z_y \u0026amp; z_z \u0026amp; -z \\cdot t \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ (저자가 제시한) 우리의 좌표계의 경우 카메라가 양의 $z$축을 바라보면 카메라가 만드는 화면 좌표계에서는 $x$축이 왼쪽을 향해서 2차원 데카르트 좌표계와 다르게 된다. 따라서 $x$축이 오른쪽을 향하도록 $y$축을 기준으로 $180^{\\circ}$회전 시켜서 뷰 공간을 구성한다. 이것을 위해 $x$축 기저와 $z$축 기저를 반전시킨다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 카메라 트랜스폼으로부터 x, y, z 로컬 축 값을 얻는다. FORCEINLINE void CameraObject::GetViewAxes(Vector3\u0026amp; OutViewX, Vector3\u0026amp; OutViewY, Vector3\u0026amp; OutViewZ) const { // (x축과 z축을 반전시킨다) OutViewZ = -_Transform.GetLocalZ(); OutViewY = _Transform.GetLocalY(); OutViewX = -_Transform.GetLocalX(); } // 뷰 행렬을 얻는다. FORCEINLINE Matrix4x4 CameraObject::GetViewMatrix() const { Vector3 viewX, viewY, viewZ; GetViewAxes(viewX, viewY, viewZ); Vector3 pos = _Transform.GetPosition(); return Matrix4x4( Vector4(Vector3(viewX.X, viewY.X, viewZ.X), false), Vector4(Vector3(viewX.Y, viewY.Y, viewZ.Y), false), Vector4(Vector3(viewX.Z, viewY.Z, viewZ.Z), false), Vector4(-viewX.Dot(pos), -viewY.Dot(pos), -viewZ.Dot(pos), 1.f) ); } 오일러 각의 특징 오일러 각의 장점\n오일러 각은 표준기저벡터를 회전축으로 삼아서 회전한 각의 크기를 설정하기 때문에 인터페이스가 직관적이다. 따라서 사용자 입장에서 물체의 회전을 설정하기에 용이하다. 행렬을 사용해서 3차원 공간의 회전을 표현하려면 최소 9개의 실수 데이터가 필요하지만, 오일러 각은 3개의 데이터만 있으면 된다. 따라서 적은 용량으로 게임 데이터를 관리할 수 있게 도와준다. 오일러 각의 단점\n짐벌락 현상이 발생한다. 짐벌락 현상 짐벌락(Gimbal lock) 현상\n오브젝트의 두 회전 축이 겹쳐서 자유도를 잃는 것을 말한다. 짐벌락 참고 영상 해결 방법\n로드리게스 회전 공식(Chapter 11) 사원수(Chapter 16) 회전 보간의 계산 회전 보간(Rotational interpolation) 카메라의 움직임이나 캐릭터의 애니메이션을 구현할 때는 3차원 공간에서 시작 회전과 끝 회전을 지정하고 시간에 따라 두 회전 사이를 부드럽게 전환하는 기능이 필요할 수 있다. 이를 위해서 중간 회전 값을 계산하는 것을 회전 보간이라고 한다. 선형 보간식을 사용해서 중간 회전 값을 얻을 수 있다. $ \\theta\u0026rsquo; = (1-t)\\theta_{start} + t\\theta_{end} $ 예를 들어, 동일한 평면 상에서 $15^{\\circ}$에서 시작해서 $165^{\\circ}$로 끝나는 회전의 $\\frac{1}{3}$비율에 해당하는 회전 보간 값은 다음과 같이 구해서 $65^{\\circ}$가 되겠다. $\\frac{2}{3} \\cdot 15^{\\circ} + \\frac{1}{3} \\cdot 165^{\\circ} = 65^{\\circ}$ 선형 보간식이 성립하려면 두 각의 회전 변환을 곱합 결과가 두 각의 합의 회전 변환과 동일해야한다. $R_{\\beta} \\cdot R_{\\alpha} = R_{(\\alpha + \\beta)}$ Chapter 5에서 보았듯이 2차원 공간의 회전에서는 위 식이 만족하므로, 선형 보간식을 사용하는 데 문제가 없었다. 그렇다면 3차원 공간의 오일러 각 회전에서도 문제가 없을까? 한 축으로만 회전하는 경우 맨 처음에 보았던 회전 행렬을 구하는 식: $ R = R_{yaw} \\cdot R_{pitch} \\cdot R_{roll} $ 만약 $y$축으로 $\\alpha$와 $\\beta$만큼 회전한다면\u0026hellip; $R_{(\\alpha + \\beta)} = R_{yaw(\\alpha + \\beta)} \\cdot I \\cdot I = R_{yaw(\\alpha + \\beta)}$ $yaw$회전만 수행하므로 $pitch$와 $roll$회전 행렬은 변화가 없는 항등행렬이 된다. $R_{\\beta} \\cdot R_{\\alpha} = (R_{yaw\\beta} \\cdot I \\cdot I) \\cdot (R_{yaw\\alpha} \\cdot I \\cdot I)$ $ = R_{yaw\\beta} \\cdot R_{yaw\\alpha}$ $ = R_{yaw(\\alpha + \\beta)}$ 이처럼, 오일러 각에서 한 축만 사용한다는 것은 결국 2차원 평면에서의 회전과 동일하므로, 선형 보간식을 사용하는 데 문제가 없다. 두 축에 대해서 회전하는 경우 만약 $x$축과 $y$축에 대해서 회전한다면\u0026hellip; $R_{(\\alpha + \\beta)} = R_{yaw(\\alpha + \\beta)} \\cdot R_{pitch(\\alpha + \\beta)} \\cdot I = R_{yaw(\\alpha + \\beta)} \\cdot R_{pitch(\\alpha + \\beta)}$ $R_{\\beta} \\cdot R_{\\alpha} = (R_{yaw\\beta} \\cdot R_{pitch\\beta} \\cdot I) \\cdot (R_{yaw\\alpha} \\cdot R_{pitch\\alpha} \\cdot I)$ $ = R_{yaw\\beta} \\cdot R_{pitch\\beta} \\cdot R_{yaw\\alpha} \\cdot R_{pitch\\alpha}$ $ \\neq R_{(\\alpha + \\beta)}$ 이처럼, 두 축 이상을 사용하는 오일러 각은 선형 보간식을 사용할 수 없다. 해결 방법 로드리게스 회전 공식(Chapter 11) 사원수(Chapter 16) ","date":"2022-04-27T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-10/","title":"[Game Math] Chapter 10. 3차원 공간: 입체 공간의 생성"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n게임 엔진의 구성 요소 게임 엔진의 인터페이스는 게임 콘텐츠가 담기는 게임 공간을 설계하는 작업 공간과, 게임 데이터를 관리하는 작업 공간으로 나뉜다. 게임 공간: 씬(Scene), 레벨(Level) 데이터: 리소스(Resource), 애셋(Asset) 게임엔진은 씬 데이터와 리소스 데이터를 결합해서 최종 게임 화면이 렌더링되로록 설계됐다. 씬의 구조 콘텐츠를 구성하는 기본단위: 액터(Actor), 게임 오브젝트(GameObject) 크기, 회전, 위치로 구성된 트랜스폼(Transform)의 정보를 사용해서 관리한다. 이 트랜스폼 정보에 모델링 행렬을 사용해서 렌더링할 물체의 정점을 변환한다. 모델링 행렬의 설계 트랜스폼의 크기, 회전, 이동 데이터\n크기(S): 2차원 벡터 $(s_x, s_y)$ 회전(R): 각 $\\theta$ 이동(T): 2차원 벡터 $(t_x, t_y)$ 크기, 회전, 이동에 대한 세 가지 아핀 변환행렬에 대응된다.\n$$S = \\begin{bmatrix} a \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; b \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \\\\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; a\\\\ 0 \u0026amp; 1 \u0026amp; b \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 그렇다면 아핀 변환을 어떤 순서로 적용해야 할까?\n회전과 이동변환을 할 경우 아래처럼 순서에 따라서 다른 결과가 나온다. 이것은 회전 대신 크기변환을 해도 마찬가지이다. 따라서 이동변환은 가장 마지막에 해야하겠다. 이동변환을 제외하면 크기변환과 회전변환이 남는다. 크기와 회전변환을 할 경우에도 순서에 따라서 다른 결과가 나온다. Chapter 7에서 보았듯이 회전변환은 물체의 형태를 그대로 보존해주는 강체 변환(Rigid Transform)이기 때문에 회전변환을 나중에 해서 형태를 유지하는 것이 사용자 입장에서 직관적인 변환이겠다. 따라서 아핀 변환의 순서는 크기 → 회전 → 위치순서로 이뤄지며 행렬곱으로 나타내면 다음과 같다. (열 기준 행렬으로 설명한다. 따라서 변환의 순서는 오른쪽에서 왼쪽으로 진행된다.)\n$T \\cdot R \\cdot S$ 이 3가지 변환을 수행하는 합성행렬인 모델링 행렬(Modeling matrix) 은 다음과 같다.\n$$M = T \\cdot R \\cdot S = \\begin{bmatrix} \\cos\\theta \\cdot s_x \u0026amp; -\\sin\\theta \\cdot s_y \u0026amp; t_x \\\\ \\sin\\theta \\cdot s_x \u0026amp; \\cos\\theta \\cdot s_y \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 로컬 공간과 로컬 축 로컬 공간(Local space) Chapter 8에서 보았듯이, 하나의 물체를 표현하기 위해서 만들어진 메시 데이터는 자신만의 공간에서 물체를 구성하는 각 정점의 위치 정보가 저장된다. 이렇게 물체의 정보를 담기 위해 부여한 공간을 로컬 공간이라고 한다. 월드 공간(World space) 게임 콘텐츠는 단일 물체가 아니라 여러가지 물체를 모아서 하나의 배경을 만든다. 이럴 때 사용하는 새로운 공간을 월드 공간이라고 한다. 예를 들어, 비행기 게임을 만든다고 하자. 그러면 월드 공간을 중심으로 설정된 비행기의 위치좌표가 필요하다. 또한 앞으로 나아가는 비행기의 방향을 조종하려면 월드 공간과 무관하게 비행기가 바라보는 방향 정보도 필요할 것이다. 로컬 축(Local Axis)\n이렇게 물체를 기준으로 설정된 방향 정보를 로컬 축이라고 한다. 로컬 축 정보는 로컬 공간의 기저벡터와 동일한 값을 가진다. 게임 엔진은 월드의 $X$, $Y$, $Z$축과 구분하기 위해 각 로컬 축의 이름을 다음과 같이 부른다. 로컬 축 로컬 축의 이름 $+X$ 라이트벡터 (Right Vector) $+Y$ 업벡터 (Up Vector) $+Z$ 포워드벡터 (Forward Vector) 트랜스폼의 이동과 크기 정보가 변경되더라도 게임 오브젝트가 보는 방향은 변함이 없기 때문에, 로컬 축 정보는 오직 회전 정보에만 영향을 받는다. 게임 오브젝트에 새로운 회전 값 $\\theta$가 설정되면 로컬 축을 구성하는 표준기저벡터도 이에 따라 변한다. $e_1$이 변화된 값을 $\\vec{r}$로, $e_2$가 변화된 값을 $\\vec{u}$로 표현하면 그 값은 다음과 같다. $\\vec{r} = (\\cos\\theta, \\sin\\theta)$ $\\vec{u} = (-\\sin\\theta, \\cos\\theta)$ 여기서 로컬축 벡터의 원소를 각각 $\\vec{r} = (r_x, r_y)$, $\\vec{u} = (u_x, u_y)$로 지정하면, 아핀 회전 변환행렬은 삼각함수 대신 로컬 축 벡터를 사용해 생성할 수 있다. 따라서 모델링 행렬 역시 삼각함수 대신 로컬 축 정보를 사용해 계산할 수 있다. $$M = T \\cdot R \\cdot S = \\begin{bmatrix} r_x \\cdot s_x \u0026amp; u_x \\cdot s_y \u0026amp; t_x \\\\ r_y \\cdot s_x \u0026amp; u_y \\cdot s_y \u0026amp; t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TransformComponent { // 회전하면 로컬 축을 갱신한다. void SetRotation(float InDegree) { _Rotation = InDegree; Update(); } void AddRotation(float InDegree) { _Rotation += InDegree; Update(); } // ... private: Vector2 _Right = Vector2::UnityX; // e1 Vector2 _Up = Vector2::UnityY; // e2 }; // 열벡터를 사용해서 모델링 행렬을 만든다. FORCEINLINE Matrix3x3 TransformComponent::GetModelingMatrix() const { return Matrix3x3( Vector3(_Scale.X * _Right.X, _Scale.X * _Right.Y, 0.f), Vector3(_ScaleY. * _Up.X, _ScaleY. * _Up.Y, 0.f), Vector3(_Position.X, _Position.Y, 1.f) ); } // sin cos함수를 이용해서 현재 회전 정보에 맞는 로컬 축 벡터를 갱신한다. FORCEINLINE void TransformComponent::Update() { float sin, cos; Math::GetSinCos(sin, cos, _Rotation); _Right = Vector2(cos, sin); // e1 _Up = Vector2(-sin, cos); // e2 } 리소스 관리 월드 공간에 동일한 게임 오브젝트를 여러 개 배치한다고 하자.\n모델링 행렬을 사용해서 로컬 공간 정보를 월드 공간 정보로 변환하여 트랜스폼 정보를 설정해야할 것이다. 여기서 각각의 게임 오브젝트들은 각자의 트랜스폼 정보를 포함하고 있다. 그렇다면 리소스 데이터는 어떨까? 용량이 큰 메시 정보를 모두 각각 가지고 있다면 메모리 공간이 낭비될 것이다. 따라서 리소스 데이터는 여러 게임 오브젝트들이 함께 사용할 수 있는 공유 자원의 형태로 관리하는 것이 바람직하다. 리소스 저장소(Resource repository)\n씬과 무관하게 별도로 리소스를 모아두는 저장소이다. 게임 오브젝트는 리소스의 키 값만 저장하며, 이것을 통해서 리소스에 접근한다. 게임 엔진의 워크플로우 워크플로우(Workflow)\n실행의 흐름. 게임 엔진의 워크플로우는 크게 씬을 완성하는 과정, 완성된 씬으로부터 화면을 그려내는 과정으로 나뉜다. (저자가 제작한) 게임 엔진의 워크플로우\n1. 리소스 로딩 단계 메시, 텍스처 같은 리소스는 게임을 진행하면서 불러들이기에는 데이터 양이 크기 때문에 게임 시작 전에 미리 불러들여서 메모리에 올려둬야 안정적으로 게임을 진행할 수 있다. LoadResources() 2. 씬 구축 단계 게임 오브젝트의 트랜스폼 정보가 설정되며 리소스 정보가 게임 오브젝트에 연결된다. LoadScene2D() 3. 게임 로직 단계 프레임마다 게임 오브젝트의 트랜스폼 값을 변경한다. Update2D() 4. 렌더링 로직 단계 트랜스폼 정보와 리소스 데이터를 활용해서 최종화면을 그린다. Render2D() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 1. 리소스 로딩 단계 // 메시 const std::size_t GameEngine::QuadMesh = std::hash\u0026lt;std::string\u0026gt;()(\u0026#34;SM_Quad\u0026#34;); // 텍스처 const std::size_t GameEngine::BaseTexture = std::hash\u0026lt;std::string\u0026gt;()(\u0026#34;Base\u0026#34;); const std::string GameEngine::CharacterTexturePath(\u0026#34;CKMan.png\u0026#34;); bool GameEngine::LoadResources() { // 사각형 메시 데이터 객체를 생성하고 QuadMesh 키를 부여한다. Mesh\u0026amp; quadMesh = CreateMesh(GameEngine::QuadMesh); constexpr float squareHalfSize = 0.5f; constexpr int vertexCount = 4; constexpr int triangleCount = 2; constexpr int indexCount = triangleCount * 3; auto\u0026amp; v = quadMesh.GetVertices(); // 정점 버퍼 auto\u0026amp; i = quadMesh.GetIndices(); // 인덱스 버퍼 auto\u0026amp; uv = quadMesh.GetUVs(); // UV 값 v = { Vector2(-squareHalfSize, -squareHalfSize), Vector2(-squareHalfSize, squareHalfSize), Vector2(squareHalfSize, squareHalfSize), Vector2(squareHalfSize, -squareHalfSize) }; uv = { Vector2(0.125f, 0.75f), Vector2(0.125f, 0.875f), Vector2(0.25f, 0.875f), Vector2(0.25f, 0.75f) }; i = { 0, 2, 1, 0, 3, 2 }; // 텍스처 객체를 생성하고 BaseTexture 키를 부여한다. Texture\u0026amp; baseTexture = CreateTexture(GameEngine::BaseTexture, GameEngine::CharacterTexturePath); // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 2. 씬 구축 단계 // 게임 오브젝트 목록 static const std::string PlayerGo(\u0026#34;Player\u0026#34;); // 최초 씬 로딩을 담당하는 함수 void SoftRenderer::LoadScene2D() { // 최초 씬 로딩에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; g = Get2DGameEngine(); // 플레이어의 생성과 설정 constexpr float playerScale = 30.f; GameObject\u0026amp; goPlayer = g.CreateNewGameObject(PlayerGo); // 게임 오브젝트를 생성한다. goPlayer.SetMesh(GameEngine::QuadMesh); // 메시 키를 설정한다. goPlayer.GetTransform().SetScale(Vector2::One * playerScale); // 최초 트랜스폼을 설정한다. goPlayer.SetColor(LinearColor::Red); // 100개의 배경 게임 오브젝트 생성과 설정 char name[64]; constexpr float squareScale = 20.f; std::mt19937 generator(0); std::uniform_real_distribution\u0026lt;float\u0026gt; dist(-1000.f, 1000.f); for (int i = 0; i \u0026lt; 100; ++i) { std::snprintf(name, sizeof(name), \u0026#34;GameObject%d\u0026#34;, i); GameObject\u0026amp; newGo = g.CreateNewGameObject(name); newGo.GetTransform().SetPosition(Vector2(dist(generator), dist(generator))); newGo.GetTransform().SetScale(Vector2::One * squareScale); newGo.SetMesh(GameEngine::QuadMesh); newGo.SetColor(LinearColor::Blue); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 3. 게임 로직 단계 // 게임 로직을 담당하는 함수 void SoftRenderer::Update2D(float InDeltaSeconds) { // 게임 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; g = Get2DGameEngine(); const InputManager\u0026amp; input = g.GetInputManager(); // 게임 로직의 로컬 변수 static float moveSpeed = 200.f; static float rotateSpeed = 180.f; static float scaleMin = 15.f; static float scaleMax = 30.f; static float scaleSpeed = 180.f; // 플레이어에 대한 주요 레퍼런스 GameObject\u0026amp; goPlayer = g.GetGameObject(PlayerGo); TransformComponent\u0026amp; transform = goPlayer.GetTransform(); // 입력에 따른 플레이어 위치와 크기의 변경 float newScale = Math::Clamp(transform.GetScale().X + scaleSpeed * input.GetAxis(InputAxis::ZAxis) * InDeltaSeconds, scaleMin, scaleMax); transform.SetScale(Vector2::One * newScale); transform.AddRotation(input.GetAxis(InputAxis::XAxis) * rotateSpeed * InDeltaSeconds); transform.AddPosition(transform.GetLocalY() * input.GetAxis(InputAxis::YAxis) * moveSpeed * InDeltaSeconds); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 4. 렌더링 로직 단계 // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render2D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; r = GetRenderer(); const auto\u0026amp; g = Get2DGameEngine(); // 배경에 격자 그리기 DrawGizmo2D(); // 렌더링 로직의 로컬 변수 size_t totalObjectCount = g.GetScene().size(); // 씬을 구성하는 모든 게임 오브젝트의 순회 for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { // 게임 오브젝트의 레퍼런스를 얻기 const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); Matrix3x3 finalMatrix = transform.GetModelingMatrix(); // 게임 오브젝트의 렌더링 수행 - 다음 절의 렌더링 파이프라인의 시작. DrawMesh2D(mesh, finalMatrix, gameObject.GetColor()); // 플레이어의 정보를 화면에 출력 if (gameObject == PlayerGo) { r.PushStatisticText(\u0026#34;Player Position : \u0026#34; + transform.GetPosition().ToString()); r.PushStatisticText(\u0026#34;Player Rotation : \u0026#34; + std::to_string(transform.GetRotation()) + \u0026#34; (deg)\u0026#34;); r.PushStatisticText(\u0026#34;Player Scale : \u0026#34; + std::to_string(transform.GetScale().X)); } } } 렌더링 파이프라인 렌더링 파이프라인(Rendering pipeline)\n게임 제작의 렌더링은 GPU가 처리한다. GPU 내부에 설정된 렌더링 워크플로우를 렌더링 파이프라인이라고 한다. 드로우 콜(Drawcall)\nCPU가 GPU에게 렌더링 작업을 수행하도록 명령을 하는 것이다. (저자가 제작한 게임 엔진에서는) DrawMesh2D()를 호출하는 것이 드로우 콜이라고 할 수 있겠다. (저자가 제작한) 렌더링 파이프라인 1. 정점 변환과 처리 단계 메시에 설정된 정점의 데이터는 로컬 공간을 기준으로 설정되어 있다. 이것을 월드 공간 중심으로 변환하여 화면에 그려질 정점의 최종 위치 값을 구한다. 즉, 모델링 행렬에 로컬 공간의 좌표를 곱한다. DrawMesh2D(), VertexShader2D() 2. 픽셀화와 픽셀 처리 단계 Chapter 8에서 보았던 무게중심좌표를 활용해서 삼각형 영역의 픽셀을 추려내고, 색상을 결정한다. 해당 픽셀의 UV에 대응되는 색상을 가져온 후 필요하다면 추가로 조명 효과 등을 적용해서 최종 픽셀 색상을 설정한다. DrawTriangle2D(), FragmentShader2D() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 1. 정점 변환과 처리 // 메시를 그리는 함수 void SoftRenderer::DrawMesh2D(const class DD::Mesh\u0026amp; InMesh, const Matrix3x3\u0026amp; InMatrix, const LinearColor\u0026amp; InColor) { // 메시의 구조를 파악하기 위한 로컬 변수 size_t vertexCount = InMesh.GetVertices().size(); size_t indexCount = InMesh.GetIndices().size(); size_t triangleCount = indexCount / 3; // 메시 정보를 렌더러가 사용할 정점 버퍼와 인덱스 버퍼로 변환 std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); std::vector\u0026lt;size_t\u0026gt; indice(InMesh.GetIndices()); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = InMesh.GetVertices()[vi]; if (InMesh.HasColor()) { vertices[vi].Color = InMesh.GetColors()[vi]; } if (InMesh.HasUV()) { vertices[vi].UV = InMesh.GetUVs()[vi]; } } // 정점 변환 진행!! VertexShader2D(vertices, InMatrix); // 그리기모드 설정 FillMode fm = FillMode::None; if (InMesh.HasColor()) { fm |= FillMode::Color; } if (InMesh.HasUV()) { fm |= FillMode::Texture; } // 메시를 삼각형으로 쪼개서 각각 그리기 for (int ti = 0; ti \u0026lt; triangleCount; ++ti) { int bi0 = ti * 3, bi1 = ti * 3 + 1, bi2 = ti * 3 + 2; std::vector\u0026lt;Vertex2D\u0026gt; tvs = { vertices[indice[bi0]] , vertices[indice[bi1]] , vertices[indice[bi2]] }; // 2. 픽셀화 DrawTriangle2D(tvs, InColor, fm); } } 셰이더(Shader)\nGPU의 렌더링 파이프라인의 몇몇 부분은 프로그래밍이 가능하다. 이런 부분을 개발자가 프로그래밍해서 만들어낸, 렌더링 효과를 계산하는 함수를 셰이더라고 한다. 정점 셰이더(Vertex Shader)\n개발자들이 변환을 직접 설계해서 만든 정점 처리 함수이다. 1 2 3 4 5 6 7 8 9 10 // 정점 셰이더 FORCEINLINE void VertexShader2D(std::vector\u0026lt;Vertex2D\u0026gt;\u0026amp; InVertices, const Matrix3x3\u0026amp; InMatrix) { // 위치 값에 최종 행렬을 적용해 변환 for (Vertex2D\u0026amp; v : InVertices) { v.Position = InMatrix * v.Position; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 2. 픽셀화와 픽셀 처리 // 삼각형을 그리는 함수 void SoftRenderer::DrawTriangle2D(std::vector\u0026lt;DD::Vertex2D\u0026gt;\u0026amp; InVertices, const LinearColor\u0026amp; InColor, FillMode InFillMode) { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; r = GetRenderer(); const GameEngine\u0026amp; g = Get2DGameEngine(); const Texture\u0026amp; texture = g.GetTexture(GameEngine::BaseTexture); if (IsWireframeDrawing()) { // 와이어 프레임 모드 } else { // ... 삼각형 칠하기 // 삼각형 영역 내 모든 점을 점검하고 색칠 for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++y) { ScreenPoint fragment = ScreenPoint(x, y); Vector2 pointToTest = fragment.ToCartesianCoordinate(_ScreenSize); Vector2 w = pointToTest - InVertices[0].Position; float wdotu = w.Dot(u); float wdotv = w.Dot(v); float s = (wdotv * udotv - wdotu * vdotv) * invDenominator; float t = (wdotu * udotv - wdotv * udotu) * invDenominator; float oneMinusST = 1.f - s - t; if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { Vector2 targetUV = InVertices[0].UV * oneMinusST + InVertices[1].UV * s + InVertices[2].UV * t; // 색상 결정 진행!! r.DrawPoint(fragment, FragmentShader2D(texture.GetSample(targetUV), LinearColor::White)); } } } } } 파편(Fragment) GPU에서는 삼각형을 구성하는 픽셀을 파편이라고 한다. 파편 셰이더(Fragment Shader) 혹은 픽셀 셰이더(Pixel Shader) 개발자들이 직접 설계한, 최종 픽셀을 계산하는 함수이다. 1 2 3 4 5 6 // 픽셀 셰이더 (단순하게 흰색을 합성해서 고유의 색을 표현하도록 함) FORCEINLINE LinearColor FragmentShader2D(LinearColor\u0026amp; InColor, const LinearColor\u0026amp; InColorParam) { return InColor * InColorParam; } 카메라 시스템 게임 엔진에는 개발자 관점에서 바라보는 게임 공간과 게이머가 바라보는 게임 공간, 이 두 가지 화면을 제공한다. 그렇다면 게이머를 위한 카메라는 월드 공간에 어떻게 설정할 수 있을까? 가상 공간의 카메라 뷰포트(Viewport)\n카메라는 자신이 출력할 화면의 해상도 정보를 가지고 월드의 일부를 그려낸다. 이 때 카메라가 출력할 화면의 크기 정보를 뷰포트라고 한다. 즉, 게이머가 보는 게임 공간의 크기가 바로 뷰포트다. 뷰 공간(View space)\n카메라에 설정된 뷰포트 정보를 바탕으로 월드 공간의 일부분을 렌더링해야 한다. 이를 위해서는 카메라를 중심으로 물체의 트랜스폼을 재조정하는 작업이 필요하다. 여기서 카메라를 중심으로 변환한 공간을 뷰 공간이라고 한다. 로컬 공간, 월드 공간, 뷰 공간의 개념을 정리하면 다음과 같다. 카메라를 중심으로 전개되는 뷰 공간을 어떻게 설계할 수 있을까?\n예를 들어, 월드 공간에 카메라가 $(-10, -10)$에 있고, 어떤 물체가 $(10, 10)$에 있다고 하자. 그렇다면 카메라로부터 해당 게임 오브젝트의 상대적 위치는 $(20, 20)$이 된다. 어떻게 하면 그 물체의 월드 공간 좌표인 $(10, 10)$을 뷰 공간 좌표인 $(20, 20)$로 바꿀 수 있을까? 뷰 행렬(View matrix)\n모델링 행렬이 로컬 공간의 좌표를 월드 공간의 좌표로 변환해준다면, 뷰 행렬은 월드 공간의 좌표를 뷰 공간의 좌표로 변환해준다. 이전 예제를 다시보면, 뷰 공간 좌표인 $(20, 20)$은 물체의 월드 공간 좌표에다가 카메라의 위치를 기준으로 측정한 월드 원점의 상대 좌표인 $(10, 10)$을 더하면 얻을 수 있다. 그리고 그 상대 좌표는 카메라의 월드 공간 좌표를 반전시켜서 얻을 수 있다. 즉, 이동 행렬의 역행렬을 사용해서 계산하면 된다. $$V = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -t_x \\\\ 0 \u0026amp; 1 \u0026amp; -t_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 따라서, 로컬 공간 $v_{local}$을 뷰 공간 $v_{view}$으로 변환하는 과정은 다음과 같다.\n$v_{view} = V \\cdot M \\cdot v_{local}$ 즉, 행렬 $VM$은 로컬 공간을 뷰 공간으로 변환한다. 다음은 플레이어를 따라가는 카메라의 로직을 구현한 예제이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 게임 로직을 담당하는 함수 void SoftRenderer::Update2D(float InDeltaSeconds) { // 게임 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; g = Get2DGameEngine(); const InputManager\u0026amp; input = g.GetInputManager(); // 게임 로직의 로컬 변수 static float moveSpeed = 200.f; static float rotateSpeed = 180.f; static float scaleMin = 15.f; static float scaleMax = 30.f; static float scaleSpeed = 180.f; static float minDistance = 1.f; // 플레이어와 카메라의 위치가 일치할 최소거리 static float lerpSpeed = 2.f; // 플레이어가 카메라를 쫒아가는 속도 // 플레이어에 대한 주요 레퍼런스 GameObject\u0026amp; goPlayer = g.GetGameObject(PlayerGo); TransformComponent\u0026amp; transform = goPlayer.GetTransform(); // 입력에 따른 플레이어 위치와 크기의 변경 transform.AddPosition(Vector2(input.GetAxis(InputAxis::XAxis), input.GetAxis(InputAxis::YAxis)).GetNormalize() * moveSpeed * InDeltaSeconds); float newScale = Math::Clamp(transform.GetScale().X + scaleSpeed * input.GetAxis(InputAxis::ZAxis) * InDeltaSeconds, scaleMin, scaleMax); transform.SetScale(Vector2::One * newScale); transform.AddRotation(input.GetAxis(InputAxis::WAxis) * rotateSpeed * InDeltaSeconds); // 플레이어를 따라다니는 카메라의 트랜스폼 TransformComponent\u0026amp; cameraTransform = g.GetMainCamera().GetTransform(); Vector2 playerPos = transform.GetPosition(); Vector2 cameraPos = cameraTransform.GetPosition(); if ((playerPos - cameraPos).SizeSquared() \u0026lt; minDistance * minDistance) { // 최소거리보다 작으면 플레이어 위치로 간다. cameraTransform.SetPosition(playerPos); } else // 최소거리보다 크면 서서히 이동한다. { float ratio = Math::Clamp(lerpSpeed * InDeltaSeconds, 0.f, 1.f); Vector2 newCameraPos = cameraPos + (playerPos - cameraPos) * ratio; cameraTransform.SetPosition(newCameraPos); } } // 렌더링 로직을 담당하는 함수 void SoftRenderer::Render2D() { // 렌더링 로직에서 사용하는 모듈 내 주요 레퍼런스 auto\u0026amp; r = GetRenderer(); const auto\u0026amp; g = Get2DGameEngine(); const auto\u0026amp; texture = g.GetTexture(GameEngine::BaseTexture); // 배경에 격자 그리기 DrawGizmo2D(); // 렌더링 로직의 로컬 변수 size_t totalObjectCount = g.GetScene().size(); Matrix3x3 viewMatrix = g.GetMainCamera().GetViewMatrix(); // 뷰 행렬 // 씬을 구성하는 모든 게임 오브젝트의 순회 for (auto it = g.SceneBegin(); it != g.SceneEnd(); ++it) { // 게임 오브젝트의 레퍼런스를 얻기 const GameObject\u0026amp; gameObject = *(*it); if (!gameObject.HasMesh() || !gameObject.IsVisible()) { continue; } // 렌더링에 필요한 게임 오브젝트의 주요 레퍼런스를 얻기 const Mesh\u0026amp; mesh = g.GetMesh(gameObject.GetMeshKey()); const TransformComponent\u0026amp; transform = gameObject.GetTransform(); Matrix3x3 finalMatrix = viewMatrix * transform.GetModelingMatrix(); // 뷰행렬 * 모델링 행렬으로 VM을 구한다 // 게임 오브젝트의 렌더링 수행 DrawMesh2D(mesh, finalMatrix, gameObject.GetColor()); // 플레이어의 정보를 화면에 출력 if (gameObject == PlayerGo) { r.PushStatisticText(\u0026#34;Player Position : \u0026#34; + transform.GetPosition().ToString()); r.PushStatisticText(\u0026#34;Player Rotation : \u0026#34; + std::to_string(transform.GetRotation()) + \u0026#34; (deg)\u0026#34;); r.PushStatisticText(\u0026#34;Player Scale : \u0026#34; + std::to_string(transform.GetScale().X)); } } } ","date":"2022-04-26T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-09/","title":"[Game Math] Chapter 9. 게임 엔진: 콘텐츠를 만드는 기술"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n세 점의 결합 Chapter 6에서 보았듯이, 아핀 결합은 여러개의 점을 결합해서 새로운 점을 생성하는 수식이다. 이 때 스칼라 값들은 그 합이 모두 $1$이어야 했다. 세 점 $P_1$, $P_2$, $P_3$를 결합하는 경우에도 스칼라값 3개의 합은 $1$이 되어야 할 것이다. $P\u0026rsquo; = s \\cdot P_1 + t \\cdot P_2 + (1 - s - t) \\cdot P_3$ $(P\u0026rsquo; - P_3) = s(P_1 - P_3) + t(P_2 - P_3)$ $\\vec{w} = s \\cdot \\vec{u} + t \\cdot \\vec{v}$ 이 때 벡터 $\\vec{u}$와 $\\vec{v}$가 선형 독립의 관계라면, 벡터 $\\vec{w}$는 2차원 벡터 공간 $\\mathbb{R}^2$에 존재하는 모든 벡터가 될 수 있다. 즉, 세 점의 아핀 결합은 평면의 모든 점을 만들어낸다. 여기서 $s$와 $t$의 값의 범위를 $[0, 1]$로 고정시키면 어떻게 될까? 해당 영역은 삼각형이 된다. 이렇게 아핀 결합에서 모든 스칼라 값을 $[0, 1]$ 범위로 한정한 결합을 컨벡스 결합(Convex combination) 이라고 부른다. 컨벡스 결합은 Chapter 6의 아핀 결합식에 각 스칼라 범위를 $[0, 1]$로 제한하는 조건을 추가해서 다음과 같이 표현할 수 있다. $$\\displaystyle\\sum_{i=1}^{n} c_i \\cdot P_i (s.t. \\displaystyle\\sum_{i=1}^{n} c_i = 1, 0 \\leq c_i \\leq 1)$$ 컨벡스 영역(Convex region)\n선분이나 삼각형처럼 컨벡스 결합으로 만든 영역. 컨벡스는 사전적으로 \u0026lsquo;볼록한\u0026rsquo;을 뜻한다. 수학에서 정의하는 볼록함이란, 영역 내 임의의 두 점을 연결한 선분을 만들었을 때, 그 선분은 언제나 해당 컨벡스 영역 안에 속하는 성질을 의미한다. 컨케이브 영역(Concave region)\n컨벡스 영역과 반대로, 임의의 두 점을 연결한 선분이 영역 밖으로 벗어나는 경우가 있는 영역이다. 아래 사진에서 왼쪽이 컨벡스 영역, 오른쪽이 컨케이브 영역이다. 4개의 점을 결합하는 컨벡스 결합은 어떻게 구성될까? $\\vec{x} = a \\cdot \\vec{u} + b \\cdot \\vec{v} + c \\cdot \\vec{w}$ 세 벡터 $\\vec{u}$, $\\vec{v}$, $\\vec{w}$가 선형 독립 관계를 이룬다면 3차원 공간의 모든 벡터를 생성할 수 있으므로, 벡터 $\\vec{x}$는 3차원 공간의 벡터가 된다. 여기서 스칼라 값을 $[0, 1]$ 범위로 제한한다면 삼각뿔(Tetrahedron) 영역이 형성된다. 이 또한 컨벡스 성질을 가진다. 메시 메시(Mesh) 삼각형을 중심으로 물체에 관련된 정보를 기록한 데이터이다. 메시는 다수의 삼각형으로 구성되고, 삼각형은 세 개의 점으로 구성되므로, 메시는 결국 다수의 점으로 구성된다고 볼 수 있다. 메시는 삼각형으로 물체의 외형을 표현하므로 삼각형의 위치정보를 가지고 있어야 한다. 이에 추가로 위치 뿐만 아니라 색상, 방향과 같은 부가 정보도 함께 제공한다. 이렇게 $위치 정보와 부가 정보를 묶은 특별한 점을 정점(Vertex) 이라고 한다. 즉, 메시는 정점들이 모인 데이터라고 할 수 있다. 와이어 프레임(Wireframe) 삼각형의 외곽선만 그려 메시를 표현하는 방법을 와이어 프레임이라고 한다. 정점 버퍼(Vertex buffer) 메시의 정점 정보를 빠르게 읽기 위해서 메모리에 정점 정보를 일렬로 나열하는 배열의 형태로 관리한다. 이것을 정점 버퍼라고 한다. 인덱스 버퍼(Index buffer) 정점 정보만으로는 삼각형을 만들 수 없으므로, 삼각형을 구성하는 정점의 인덱스(순번)만 기록한 배열을 별도로 만들어서 관리한다. 이것을 인덱스 버퍼라고 한다. 인덱스 버퍼는 삼각형의 수만큼 필요하기 때문에 인덱스 버퍼의 크기는 항상 3의 배수이다. 다음은 정사각형의 와이어 프레임을 그리는 예제이다. 정사각형을 구성하는 메시 정보를 표현하면 다음과 같다. 여기서 정점 0, 2번은 두 삼각형이 공유해 사용할 수 있다. 정점 버퍼 순서 좌표 0 (-0.5, -0.5) 1 (-0.5, 0.5) 2 (0.5, 0.5) 3 (0.5, -0.5) 인덱스 버퍼 순서 삼각형 정점 순서 0 0 0 1 0 1 2 0 2 3 1 0 4 1 2 5 1 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 정점 배열 static constexpr std::array\u0026lt;Vertex2D, vertexCount\u0026gt; rawVertices = { Vertex2D(Vector2(-sqareHalfSize, -squareHalfSize)), Vertex2D(Vector2(-sqareHalfSize, squareHalfSize)), Vertex2D(Vector2(sqareHalfSize, squareHalfSize)), Vertex2D(Vector2(sqareHalfSize, -squareHalfSize)) }; // 인덱스 배열 static constexpr std::array\u0026lt;size_t, triangleCount * 3\u0026gt; indices = { 0, 1, 2, 0, 2, 3 }; // ... 아핀 변환행렬을 곱해서 최종 행렬 finalMatrix를 생성한다. // 최종 행렬을 곱해서 위치 지정 static std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = finalMatrix * rawVertices[vi].Position; } // 정점 배열과 인덱스 배열을 사용해서 삼각형의 점을 서로 이어준다. for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { size_t bi = ti * 3; r.DrawLine(vertices[indices[bi]].Position, vertices[indices[bi + 1]].Position, _WireframeColor); r.DrawLine(vertices[indices[bi]].Position, vertices[indices[bi + 2]].Position, _WireframeColor); r.DrawLine(vertices[indices[bi + 1]].Position, vertices[indices[bi + 2]].Position, _WireframeColor); } 무게중심좌표 무게중심좌표(Barycentric coordinate) $P\u0026rsquo; = s \\cdot P_1 + t \\cdot P_2 + (1 - s - t) \\cdot P_3$ 위 식에서 스칼라 값 $s$, $t$, $1 - s - t$는 모두 실수이다. 이들을 묶어서 하나의 3차원 벡터로 생성할 수 있다. 이렇게 아핀 결합의 스칼라를 묶어서 만든 좌표를 무게중심좌표라고 한다. 무게중심좌표의 계산 이전에 보았듯이 아핀 결합이 삼각형이 되려면 스칼라 값 $s$, $t$, $1 - s - t$는 $[0, 1]$ 범위 내에 있어야 한다.\n따라서 $[0, 1]$ 외부에 있다면 아핀 결합으로 생성된 점이 삼각형 외부에 있다고 볼 수 있다. 아핀 결합으로 생성된 점이 삼각형 내부에 있는지 판별하는 법 $\\vec{w} = s \\cdot \\vec{u} + t \\cdot \\vec{v}$ 이전에 보았던 이 수식에 벡터 $\\vec{u}$와 $\\vec{v}$를 내적해보자.\n$\\vec{w} \\cdot \\vec{u} = ( s \\cdot \\vec{u} + t \\cdot \\vec{v}) \\cdot \\vec{u}$ $\\vec{w} \\cdot \\vec{v} = ( s \\cdot \\vec{u} + t \\cdot \\vec{v}) \\cdot \\vec{v}$ 이것을 분배법칙에 따라 풀어준다.\n$ \\vec{w} \\cdot \\vec{u} = s(\\vec{u} \\cdot \\vec{u}) + t (\\vec{u} \\cdot \\vec{v})$ $ \\vec{w} \\cdot \\vec{v} = s(\\vec{u} \\cdot \\vec{v}) + t (\\vec{v} \\cdot \\vec{v})$ 위의 식에는 $(\\vec{u} \\cdot \\vec{v})$를, 및에 식에는 $(\\vec{u} \\cdot \\vec{u})$를 곱해 각각 전개해보자.\n$(\\vec{w} \\cdot \\vec{u})(\\vec{u} \\cdot \\vec{v}) = s(\\vec{u} \\cdot \\vec{u})(\\vec{u} \\cdot \\vec{v}) + t(\\vec{u} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v})$ $(\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u}) = s(\\vec{u} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u}) + t(\\vec{v} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u})$ 위에 식에서 아래식을 빼 $s$를 소거하고 $t$만 남긴다.\n$$ t = \\frac{ (\\vec{w} \\cdot \\vec{u})(\\vec{u} \\cdot \\vec{v}) - (\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{u}) }{ (\\vec{u} \\cdot \\vec{v})^2 - (\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) }$$ 예전 식에서 이번에는 위의 식에 $(\\vec{v} \\cdot \\vec{v})$를, 및에 식에는 $(\\vec{u} \\cdot \\vec{v})$를 곱해 각각 전개해보자.\n$(\\vec{w} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) = s(\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) + t(\\vec{u} \\cdot \\vec{v})(\\vec{v} \\cdot \\vec{v})$ $(\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v}) = s(\\vec{u} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v}) + t(\\vec{v} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v})$ 위의 식에서 아래 식을 빼 $t$를 소거하고 $s$만 남긴다.\n$$ s = \\frac{ (\\vec{w} \\cdot \\vec{v})(\\vec{u} \\cdot \\vec{v}) - (\\vec{w} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) }{ (\\vec{u} \\cdot \\vec{v})^2 - (\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v}) }$$ 이렇게 얻어진 무게중심좌표 $(s, t, 1-s-t)$의 세 값 모두 $[0, 1]$ 범위 내에 있다면 새로 생성된 점은 삼각형 안에 있다고 할 수 있다. 반대로 그 범위를 벗어난다면, 삼각형 밖에 있다고 판단할 수 있다. 공통분모 $(\\vec{u} \\cdot \\vec{v})^2 - (\\vec{u} \\cdot \\vec{u})(\\vec{v} \\cdot \\vec{v})$의 결과가 $0$이 나올 수도 있으므로 주의해야한다. 분모 값이 $0$이면 무게중심좌표를 구할 수가 없다. 공통분모에서 내적을 $\\cos$공식으로 변경하면 다음과 같아진다. $(|\\vec{u}||\\vec{v}|)^2 \\cdot \\cos^2\\theta - (|\\vec{u}||\\vec{v}|)^2$ 이 값이 $0$이 되기 위한 조건은 $\\vec{u}$ 혹은 $\\vec{v}$의 크기가 $0$이거나, 그 두 벡터가 이루는 각 $\\theta$가 $0^{\\circ}$ 혹은 $180^{\\circ}$일 때다. 이것은 두 벡터가 평행함을 의미한다. 두 벡터가 평행하면 선형 종속의 관계를 가지며 삼각형이 아니라 선분을 만들어낸다. 이런 삼각형을 퇴화삼각형(Degenerate triangle) 이라고 하며, 퇴화삼각형은 그리기에서 제외한다. 다음은 무게중심좌표를 사용해서 정사각형을 칠하는 예제이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // ... 이전 예제와 똑같은 과정을 거친다. for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { size_t bi = ti * 3; // 삼각형의 세 점 std::array\u0026lt;Vertex2D, 3\u0026gt; tv = {vertices[indices[bi]], vertices[indices[bi + 1]], vertices[indices[bi + 2]]}; // ... 삼각형의 세 점을 통해 minX, minY, maxX, maxY를 구한다. // u벡터와 v벡터 Vector2 u = tv[1].Position - tv[0].Position; Vector2 v = tv[2].Position - tv[0].Position; // 공통분모 구하기 float uDotv = u.Dot(v); float vDotv = v.Dot(v); float uDotu = u.Dot(u); float denominator = uDotv * uDotv - vDotv * uDotu; // 퇴화삼각형은 그리지 않는다!! if (denominator == 0.0f) continue; float invDenominator = 1.f / denominator; // ... minX, minY, maxX, maxY를 스크린 좌표계로 옮기고, 화면을 넘어서면 클리핑한다. // 삼각형을 둘러싸는 사각형 영역의 픽셀을 모두 순회한다. for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++x)) { // 스크린 좌표계와 데카르트 좌표계 ScreenPoint fragment = ScreenPoint(x, y); Vector2 pointToTest = fragment.ToCartesianCoordinate(_ScreenSize); // w벡터 Vector2 w = pointToTest - tv[0].Position; float wDotu = w.Dot(u); float wDotv = w.Dot(v); // s, t, 1-s-t 구하기 float s = (wDotv * uDotv - wDotu * vDotv) * invDenominator; float t = (wDotu * uDotv - wDotv * uDotu) * invDenominator; float oneMinusST = 1.f - s - t; // 컨벡스 조건을 만족할 때만 점 찍기!! if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp;((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { r.DrawPoint(fragment, LinearColor::Blue); } } } } 정점에 설정된 부가 정보의 활용 무게중심좌표의 값은 주어진 픽셀이 삼각형의 세 점으로부터 얼마나 영향을 받는지 파악하는 용도로도 활용할 수 있다. 예를 들어 어떤점의 무게중심좌표가 $(0.333, 0.333, 0.333)$이라면 삼각형의 세 점이 균일하게 영향을 미치는 삼각형의 무게중심에 그 점이 위치한다고 볼 수 있다. 다음은 무게중심좌표를 사용해서 삼각형에 색상을 입히는 예제이다. 정점 버퍼 인덱스 좌표 색상(RGB) 0 (0, 0.25) (1, 0, 0) Red 1 (-0.5, -0.25) (0, 1, 0) Green 2 (0.5, -0.25) (0, 0, 1) Blue 인덱스 버퍼 순서 삼각형 정점 순서 0 0 0 1 0 2 2 0 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 정점 배열에 색상정보도 추가한다. std::array\u0026lt;Vertex2D, vertexCount\u0026gt; rawVertices = { Vertex2D(Vector2(0.f, 0.25f), LinearColor(1.f, 0.f, 0.f)), Vertex2D(Vector2(-0.5f, -0.25f), LinearColor(0.f, 1.f, 0.f)), Vertex2D(Vector2(0.5f, -0.25f), LinearColor(0.f, 0.f, 1.f)) }; // 인덱스 배열 static constexpr std::array\u0026lt;size_t, triangleCount * 3\u0026gt; indices = { 0, 2, 1 }; // ... 아핀 변환행렬을 곱해서 최종 행렬 finalMatrix를 생성한다. // 최종 행렬을 곱해서 위치 지정. 색상 정보도 함께 복사한다. static std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = finalMatrix * rawVertices[vi].Position; vertices[vi].Color = rawVertices[vi].Color; } for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { // ... for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++x)) { // ... // 무게중심좌표와 정점의 색상정보를 선형 보간해서 최종 픽셀 색상값을 계산한다. if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp;((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { LinearColor outColor = tv[0].Color * oneMinusST + tv[1].Color * s + tv[2].Color * t; r.DrawPoint(fragment, outColor); } } } } 텍스처 매핑 무게중심좌표는 메시에 이미지를 입하는 용도로도 활용할 수 있다.\n텍스처(Texture)\n메시에 이미지를 입히기 위해 변환된 데이터. 텍스처 매핑(Texture mapping)\n메시에 이미지를 입하는 작업. UV 좌표계\n사진이나 그림을 저장한 이미지는 각기 고유한 해상도를 가진다. 메시에 이것을 입히기 위해서 텍스처로 변환하면 관리 방식을 통일하기 위해 이미지 고유의 해상도에 관계없이 가로, 세로 크기가 $1$로 정규화된다. 이처럼 렌더링 과정에서 텍스처를 사용할 때는 $[0, 1]$범위로 구성된 2차원 좌표계를 사용하는 데 이 좌표계를 UV좌표계라고 한다. U는 가로정보, V는 세로정보를 나타낸다. 예를 들어, 왼쪽 하단을 원점으로 잡고 우상단으로 증가하는 방식의 UV좌표계는 다음과 같을 것이다. 텍스처 매핑 방법 삼각형의 세 정점에 UV 좌표 정보를 추가한다. 그리고 삼각형을 구성하는 각 픽셀들의 무게중심좌표를 계산해서 UV좌표와 선형보간한다. 이렇게 하면 해당 픽셀에 해당하는 UV값을 얻어낼 수 있다. 이 UV값에 대응하는 텍스처의 색상 정보를 얻은 후에 이것을 최정 픽셀의 색상으로 지정하면 텍스처 매핑이 완성된다. 다음은 무게중심좌표와 UV좌표를 사용해서 정사각형에 얼굴 텍스처를 입히는 예제이다. 정점 버퍼 인덱스 좌표 UV좌표 0 (-0.5, -0.5) (0.125, 0.75) 1 (-0.5, 0.5) (0.125, 0.875) 2 (0.5, 0.5) (0.25, 0.75) 3 (0.5, -0.5) (0.25, 0.875) 인덱스 버퍼 순서 삼각형 정점 순서 0 0 0 1 0 1 2 0 2 3 1 0 4 1 2 5 1 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 텍스쳐를 가져온다. const auto\u0026amp; texture = g.GetTexture(GameEngine::BaseTexture); //... // 정점 배열에 UV값도 추가한다. std::array\u0026lt;Vertex2D, vertexCount\u0026gt; rawVertices = { Vertex2D(Vector2(-sqareHalfSize, -squareHalfSize), LinearColor(), Vector2(0.125f, 0.75f)), Vertex2D(Vector2(-sqareHalfSize, squareHalfSize), LinearColor(), Vector2(0.125f, 0.875f)), Vertex2D(Vector2(sqareHalfSize, squareHalfSize), LinearColor(), Vector2(0.25f, 0.875f)), Vertex2D(Vector2(sqareHalfSize, -squareHalfSize), LinearColor(), Vector2(0.25f, 0.75f)), }; // 인덱스 배열 static constexpr std::array\u0026lt;size_t, triangleCount * 3\u0026gt; indices = { 0, 1, 2, 0, 2, 3 }; // ... 아핀 변환행렬을 곱해서 최종 행렬 finalMatrix를 생성한다. // 최종 행렬을 곱해서 위치 지정. UV 정보도 함께 복사한다. static std::vector\u0026lt;Vertex2D\u0026gt; vertices(vertexCount); for (size_t vi = 0; vi \u0026lt; vertexCount; ++vi) { vertices[vi].Position = finalMatrix * rawVertices[vi].Position; vertices[vi].UV = rawVertices[vi].UV; } // 정점 배열과 인덱스 배열을 사용해서 삼각형의 점을 서로 이어준다. for (size_t ti = 0; ti \u0026lt; triangleCount; ++i) { // ... for (int x = lowerLeftPoint.X; x \u0026lt;= upperRightPoint.X; ++x) { for (int y = upperRightPoint.Y; y \u0026lt;= lowerLeftPoint.Y; ++x)) { // ... // 무게중심좌표와 정점의 UV좌표를 선형 보간해서 최종 UV값을 계산한다. if (((s \u0026gt;= 0.f) \u0026amp;\u0026amp; (s \u0026lt;= 1.f)) \u0026amp;\u0026amp; ((t \u0026gt;= 0.f) \u0026amp;\u0026amp; (t \u0026lt;= 1.f)) \u0026amp;\u0026amp;((oneMinusST \u0026gt;= 0.f) \u0026amp;\u0026amp; (oneMinusST \u0026lt;= 1.f))) { Vector2 targetUV = tv[0].UV * oneMinusST + tv[1].UV * s + tv[2].UV * t; r.DrawPoint(fragment, targetUV.GetSample(targetUV)); } } } } ","date":"2022-04-25T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-08/","title":"[Game Math] Chapter 8. 삼각형: 물체를 구성하는 가장 작은 단위"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n벡터의 내적 내적(Dot product) 같은 차원의 두 벡터가 주어졌을 때, 벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산이다. $\\vec{u} = (a, b)$, $\\vec{v} = (c, d)$ 일 때, $\\vec{u} \\cdot \\vec{v} = a \\cdot c + b \\cdot d$ 내적의 성질 교환법칙이 성립한다. $\\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u}$ 결합법칙이 성립하지 않는다. $\\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w}) \\neq (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w}$ 덧셈에 대한 분배법칙이 성립한다. $\\vec{w} \\cdot (\\vec{u} + \\vec{v}) = \\vec{u} \\cdot \\vec{w} + \\vec{v} \\cdot \\vec{w}$ 같은 벡터를 내적하면 크기를 제곱한 결과가 나온다. $\\vec{v} \\cdot \\vec{v} = |\\vec{v}|^2$ 두 벡터의 합의 내적은 두 벡터의 크기로 표현할 수 있다. $(\\vec{u} + \\vec{v}) \\cdot (\\vec{u} + \\vec{v}) = |\\vec{u}|^2 + |\\vec{v}|^2 + 2(\\vec{u} \\cdot \\vec{v})$ 내적과 삼각함수와의 관계 벡터의 내적은 두 벡터의 사잇각에 대한 $\\cos$함수와 비례한다. $\\vec{u} \\cdot \\vec{v} = |\\vec{u}||\\vec{v}|\\cos\\theta$ 이 식을 유도해보자. 그림과 같이 구성되었을 때 벡터 $\\vec{b}$의 크기를 제곱하면 다음과 같다.\n$|\\vec{b}|^2 = (|\\vec{a}| - |\\vec{c}|\\cos\\theta)^2 + |\\vec{c}|^2\\sin^2\\theta$ $ = |\\vec{a}|^2 - 2 |\\vec{a}||\\vec{c}|\\cos\\theta + |\\vec{c}|^2\\cos^2\\theta + |\\vec{c}|^2\\sin^2\\theta$ $ = |\\vec{a}|^2 + |\\vec{c}|^2 - 2 |\\vec{a}||\\vec{c}|\\cos\\theta$ 같은 벡터를 내적하면 벡터 크기의 제곱이 된다.\n$|\\vec{b}|^2 = \\vec{b} \\cdot \\vec{b}$ $ = (\\vec{a} + (-\\vec{c})) \\cdot (\\vec{a} + (-\\vec{c}))$ $ = |\\vec{a}|^2 + |\\vec{c}|^2 - 2\\vec{a} \\cdot \\vec{c}$ 따라서 다음 식이 성립한다.\n$\\vec{a} \\cdot \\vec{c} = |\\vec{a}||\\vec{c}|\\cos\\theta$ 여기서 두 벡터의 크기가 $1$이면, 두 벡터의 내적은 $\\cos$함수가 된다. $\\vec{u} \\cdot \\vec{v} = \\cos\\theta$ 두 벡터의 내적이 $0$이면, 두 벡터는 직교한다. 위의 공식에 따르면, 내적 값이 $0$이 되기 위한 조건은 $\\cos$함수의 값이 $0$이 되는 경우 뿐이다. $\\cos$함수의 값이 $0$이 되는 경우는 두 벡터의 사잇각이 $90^\\circ$ 혹은$270^\\circ(-90^\\circ)$인 경우다. 이것은 두 벡터가 서로 직교하는 경우이다. 벡터 공간에서 직교하는 두 표준기저벡터 $(0, 1)$, $(1, 0)$을 내적한 결과는 $0$이다. 그리고 이것을 $\\theta$만큼 회전한 두 기저벡터 $(\\cos\\theta, \\sin\\theta)$, $(-\\sin\\theta, \\cos\\theta)$도 직교하기 때문에 내적한 결과는 똑같이 $0$이다. 행렬의 곱셈을 내적으로 표현하기 행렬과 벡터의 곱셈 연산을 내적으로 표현해보자.\n$$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ $$ = \\begin{bmatrix} (a, b) \\cdot (x, y) \\\\ (c, d) \\cdot (x, y) \\end{bmatrix} $$ 이제 행렬과 행렬의 곱셈 연산을 내적으로 표현해보자.\n$$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix} = \\begin{bmatrix} ae + bg \u0026amp; af + bh \\\\ ce + dg \u0026amp; cf + dh \\end{bmatrix}$$ $$ = \\begin{bmatrix} (a, b) \\cdot (e, g) \u0026amp; (a, b) \\cdot (f, h) \\\\ (c, d) \\cdot (e, g) \u0026amp; (c, d) \\cdot (f, h) \\end{bmatrix} $$ 직교 행렬(Orthogonal matrix)\n정방행렬을 구성하는 모든 행벡터와 열벡터의 크기가 $1$이고, 벡터들이 서로 직교하는 행렬이다. $$Q = \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix}$$ 위 행렬에서 $(a, c)$, $(b, d)$, $(a, b)$, $(c, d)$의 크기가 $1$이고, $(a, b)$와 $(c, d)$가 직교하면 직교 행렬이다. 직교행렬의 특징은 전치행렬이 곧 역행렬이라는 점이다. 따라서 직교행렬과 그 전치행렬의 곱은 항등행렬이된다.\n$Q \\cdot Q^T = I$ 이는 내적을 사용해서 증명할 수 있다. $(a, b)$와 $(c, d)$는 서로 직교하므로 두 벡터의 내적은 $0$이다. 그리고 행벡터와 열벡터의 크기가 $1$이므로 자기 자신과 내적한 결과는 $1$이 된다. $$Q = \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix}$$ $$Q^T \\cdot Q = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix} $$ $$ = \\begin{bmatrix} (a, b) \\cdot (a, b) \u0026amp; (a, b) \\cdot (c, d) \\\\ (c, d) \\cdot (a, b) \u0026amp; (c, d) \\cdot (c, d) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} = I$$ 회전 변환행렬은 직교행렬이다.\n$$R_{\\theta} = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ $$R_{\\theta}^T \\cdot R_{\\theta} = \\begin{bmatrix} \\cos^2\\theta + \\sin^2\\theta \u0026amp; 0 \\\\ 0 \u0026amp; \\cos^2\\theta + \\sin^2\\theta \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix} = I$$ 강체 변환(Rigid Transformation)\n물체의 형태가 그대로 유지되는 선형 변환이다. 조건 변화된 기저벡터의 크기는 모두 $1$이어야 한다. 모든 기저벡터는 서로 직교해야한다. 행렬식 값이 $1$이어야 한다. 회전 변환은 강체 변환이다.\n회전 행렬은 앞서 보았듯이 직교 행렬이기 때문에 1, 2번 조건을 만족한다. 3번의 경우 행렬식 $ad - bc$가 다음과 같이 $1$이 된다. $det(R) = \\cos^2\\theta + \\sin^2\\theta = 1$ 시야 판별 앞뒤 판별 벡터의 크기 값은 언제나 양수이다. 따라서 내적의 부호는 $\\cos$ 함수가 결정한다.\n$\\cos$함수는 $(-90^\\circ, 90^\\circ)$에서 양의 부호를 가지고 $-90^\\circ$와 $90^\\circ$에서는 $0$이며, 나머지 범위에서는 음의 부호를 가진다. 따라서 이를 응용하면 벡터 내적의 부호만 가지고도 다음과 같이 판단할 수 있다.\n벡터 내적의 결과가 양수이다. 두 벡터는 같은 방향을 향하고 있다. 벡터 내적의 결과가 음수이다. 두 벡터는 다른 방향을 향하고 있다. (서로 마주보고 있다.) 벡터 내적의 결과가 $0$이다. 두 벡터는 직교한다. 이것들을 응용해서 목표물이 캐릭터 앞에 있는지 뒤에 있는지를 판별할 수 있겠다. $\\vec{f} \\cdot \\vec{v}$이 양수 캐릭터 앞에 목표물이 있다. $\\vec{f} \\cdot \\vec{v}$이 음수 캐릭터 뒤에 목표물이 있다. $\\vec{f} \\cdot \\vec{v}$이 $0$ 캐릭터 바로 옆에 목표물이 있다. 시야 판별 캐릭터에게 부여한 시야각이 $\\beta$라고 하자. 그리고 캐릭터에서 목표물로 향하는 벡터 $\\vec{v}$와의 사잇각을 $\\alpha$라고 하자. $\\cos$함수의 경우 $[0^\\circ, 180^\\circ]$에서는 각이 커질 수록 값이 작아진다. 이것을 활용해서 다음의 과정으로 캐릭터 시야 안에 목표물이 있는지 판별할 수 있다.\n(1) 시야각을 절반 나눈 각의 $\\cos\\frac{\\beta}{2}$를 미리 계산해둔다. (2) 캐릭터 시선 벡터의 크기를 $1$로 정규화시킨 단위 벡터 $\\hat{f}$을 구한다. (3) 캐릭터에서 목표물로 향하는 벡터를 정규화시킨 단위 벡터 $\\hat{v}$을 구한다. (4) 그 두 벡터의 내적 결과는 $\\hat{f} \\cdot \\hat{v} = \\cos\\alpha$가 된다. 이것을 앞서 계산해 두었던 $\\cos\\frac{\\beta}{2}$와 비교한다. 이 때 $\\hat{f} \\cdot \\hat{v}$가 $\\cos\\frac{\\beta}{2}$보다 크다면 사잇각이 시야보다 작다는 것을 의미하므로 물체가 시야 영역에 들어왔음을 의미한다. $\\hat{f} \\cdot \\hat{v} \\lt \\cos\\frac{\\beta}{2}$\n목표물이 시야 범위 안에 있다. $\\hat{f} \\cdot \\hat{v} \u0026gt; \\cos\\frac{\\beta}{2}$\n목표물이 시야 범위 밖에 있다. $atan2$함수를 사용해서 두 벡터가 이루는 각 $\\alpha$를 구한 후 이것을 $\\cos\\frac{\\beta}{2}$와 비교해도 동일한 결과를 얻을 수 있다. 하지만 위의 방법이 더 효율적이다. 조명 효과의 구현 램버트 반사(Lambertian reflection) 표면에서의 조명 모델 계산을 위해 쓰인다. 빛을 받아서 표면에서 반사되는 빛의 세기는 두 벡터가 만드는 사잇각의 $cos$함수에 비례한다는 것이다. 즉, 사잇각이 커질 수록 $\\cos$함수의 값이 적어져서 빛도 줄어든다는 것이다. 표면이 향하는 단위벡터 $\\hat{N}$과 표면에서 광원으로 향하는 단위벡터 $\\hat{L}$이 있다. 여기서 두 벡터를 내적하여 사잇각의 $\\cos$값을 얻을 수 있다. $\\hat{N} \\cdot \\hat{L} = \\cos\\theta$ 1 2 3 4 5 6 7 8 9 10 // circle에 존재하는 모든 픽셀 v에 대해 적용한다. for (auto const\u0026amp; v : circle) { Vector2 n = (v - circlePosition).GetNormalize(); Vector2 l = (lightPosition - v).GetNormalize(); float shading = Math::Clamp(n.Dot(l), 0.f, 1.f); // 음수는 의미가 없으므로 0으로 만든다. r.DrawPoint(v, lightColor * shading); // 빛의 색상과 shading을 곱해서 해당 픽셀에 적용한다. } 투영 벡터 벡터의 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로도 사용된다. 예를 들면, 다음과 같이 카메라와 물체 사이의 깊이 값을 구할 때, 내적을 사용해서 투영 벡터를 구할 수 있겠다. 투영 벡터를 구하는 공식\n$\\vec{A} \\cdot \\vec{B} = |\\vec{A}| \\cdot |\\vec{B}| \\cdot \\cos\\theta = |\\vec{A}| \\cdot |\\vec{B}| \\cdot \\frac{|\\vec{proj}|}{|\\vec{A}|} = |\\vec{B}| \\cdot |\\vec{proj}|$ $|\\vec{proj}| = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|}$ $\\vec{proj}$는 $\\vec{B}$와 방향이 같으므로 $|\\vec{proj}| \\cdot \\hat{B}$으로도 표현할 수 있다. $\\vec{proj} = |\\vec{proj}| \\cdot \\hat{B}$ 여기에 맨 위의 공식을 대입하면 다음과 같다. $\\vec{proj} = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|} \\cdot \\hat{B}$ $\\vec{proj} = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|} \\cdot \\frac{\\vec{B}}{|\\vec{B}|} = \\frac{\\vec{A} \\cdot \\vec{B}}{|\\vec{B}|^2} \\cdot \\vec{B}$ 여기서 $\\vec{B}$ 크기가 $1$이라면 다음과 같이 단순하게 정리할 수 있다. $\\vec{proj} = (\\vec{A} \\cdot \\hat{B}) \\cdot \\hat{B}$ 1 2 3 4 5 6 Vector2 unitB = (lineEnd - lineStart).GetNormalize(); Vector2 A = point - lineStart; Vector2 proj = unitB * (A.Dot(unitB)); Vector2 projectedPoint = lineStart - proj; float depth = (projectedPoint - point).Size(); ","date":"2022-04-24T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-07/","title":"[Game Math] Chapter 7. 내적: 벡터 공간의 분석과 응용"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n이동 변환을 위한 아핀 공간 행렬 곱으로 어떻게 이동 기능을 구현할 수 있을까? $$A \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} x + a \\\\ y + b \\end{bmatrix}$$ 이러한 행렬 곱을 만족하는 정방행렬 $A$는 존재하지 않는다. 왜냐하면, 표준기저벡터의 원점을 이동시키기 위해서는 $A$가 선형성을 만족해야 한다. 그러나 선형성이 되기 위해서는 Chapter 5에서 본 것처럼 기저벡터가 원점에서 출발해야한다. 전단 변환을 생각해보자.\n전단 변환으로 공간을 오른쪽으로 밀면, $y$값이 $1$인 영역의 $x$범위는 밀어낸만큼 이동한다. 따라서 다음과 같이 벡터의 $y$값을 $1$로 고정한다면 $x$를 이동시킬 수 있다. $$\\begin{bmatrix} 1 \u0026amp; a\\\\ 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x + a \\\\ 1 \\end{bmatrix} $$ 그렇다면, 2차원을 3차원으로 확장해서 마지막 차원 $z$값을 1로 고정한 전단 변환을 시행하면 $x$와 $y$를 이동시킬 수 있겠다.\n$$\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; a\\\\ 0 \u0026amp; 1 \u0026amp; b \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x + a \\\\ y + b \\\\ 1 \\end{bmatrix} $$ 이동 변환행렬(Translate transformation matrix)\n마지막 차원의 값이 1이라는 특정 조건을 가지는 전단 변환을 활용해서 이동 기능을 행렬로 구현한 것이다. $$ T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; a\\\\ 0 \u0026amp; 1 \u0026amp; b \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 우리가 Chapter 5에서 보았던 크기와 회전 변환행렬의 경우 $2 \\times 2$정방행렬이기 때문에 이동 변환행렬과 같이 $3 \\times 3$으로 맞추어 줄 필요가 있겠다. $$S = \\begin{bmatrix} a \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; b \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ $$R = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \\\\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$$ 아핀 공간(Affine space)\n벡터 공간에서 이동을 위해 마지막 차원 값을 $1$로 한정한 부분 공간을 말한다. 위의 그림에서 파란색으로 칠한 공간이다. 아핀 변환(Affine transformation)\n한 차원을 높여서 설계해서, 점, 직선, 평면을 보존하는 선형 변환을 말한다. 아핀 공간의 구성요소 점(Point)\n물체를 표현하고 위치를 지정하는 요소. 마지막 차원의 값은 항상 $1$이다. 2차원 공간의 점: $(x, y, 1)$ 3차원 공간의 점: $(x, y, z, 1)$ 이동 벡터 혹은 변위 벡터(Displacement vector)\n물체를 움직이는 데 사용하는 요소. 마지막 차원의 값은 항상 $0$이다. 아핀 공간의 점 $P_1$에 이동 벡터 $\\vec{v}$를 더한 결과는 아핀 공간의 다른 점 $P_2$에 대응된다. $P_1 + \\vec{v} = P_2$ $\\vec{v} = P_2 - P_1$ 여기서 벡터 $\\vec{v}$는 $P_1$에서 $P_2$를 향하는 벡터를 의미한다. (순서를 거꾸로하면 반대로 향한다.) 점 $P_1$이 $(x_1, y_1, 1)$이고 $P_2$이 $(x_2, y_2, 1)$이라면 두 점을 빼서. 만든 이동 벡터 $\\vec{v}$는 $x$, $y$값과 무관하게 $0$이다. $(x_1 - x_2, y_1 - y_2, 0)$ 아핀 공간의 성질 유클리드 공간(Euclidean space) → 아핀 공간에 대응 물리적인 관점에서 바라본 현실 세계의 3차원 공간. 유클리드 벡터(Euclidean vector) → 이동 벡터에 대응 유클리드 공간에서 작용하는 힘. 점과 이동 벡터의 마지막 차원 값을 토대로 다음과 같은 연산 규칙이 성립한다. 점 $-$ 점 $=$ 벡터 $(1 - 1 = 0)$ 점 $+$ 벡터 $=$ 점 $(1 + 0 = 1)$ 벡터 $+$ 벡터 $=$ 벡터 $(0 + 0 = 0)$ 점 $+$ 점 $\\neq$ 점 $(1 + 1 = 2)$ 마지막 차원 값이 $2$가 되므로 아핀 공간 영역을 벗어나게 되어서 성립하지 않는다. 아핀 결합 점 $+$ 점 $\\neq$ 점\n만약 선형 결합의 형태로 점에 스칼라를 곱한 후 더한다면 특정 조건에서 새로운 점을 생성하는 것이 가능하다. 점 $(x_1, y_1, 1)$과 $(x_2, y_2, 1)$에 각각 스칼라 $a$, $b$를 곱한 선형 결합은 다음과 같다.\n$a \\cdot P_1 + b \\cdot P_2 = (ax_1 + ax_2, ay_1 + by_2, a + b)$ 여기서 $a + b = 1$ 조건을 유지한다면 점과 점을 결합해서 새로운 점을 만들 수 있다. 동일한 원리로 점 세개를 가지고도 새로운 점을 만들 수 있다. $a \\cdot P_1 + b \\cdot P_2 + c \\cdot P_3 (s.t. a + b + c = 1)$ 아핀 결합(Affine combination)\n이렇게 여러 개의 점을 결합해서 새로운 점을 생성하는 수식을 아핀 결합이라고 한다. $n$개의 점을 아핀 결합하는 경우 $$\\displaystyle\\sum_{i=1}^{n} c_i \\cdot P_i (s.t. \\displaystyle\\sum_{i=1}^{n} c_i = 1)$$ 두 점의 결합 $b = 1 - a$을 대입하면, $a \\cdot P_1 + (1 - a) \\cdot P_2 = P\u0026rsquo;$이 된다. $a$에 $1$을 대입하면, 점 $P_1$이 생성된다. $a$에 $0$을 대입하면, 점 $P_2$가 생성된다. $a$에 $0.5$을 대입하면, 점 $P_1$과 $P_2$의 중점이 생성된다. $(\\frac{x_1 + x_2}{2}, \\frac{y_1 + y_2}{2}, 1)$ 이렇듯 두 점 $P_1$, $P_2$의 아핀 결합으로 새로운 점을 생성하면 $a$값이 양의 방향으로 커질 수록. $P_1$의 바깥쪽에 점이 생성되고, $a$의 값이 음의 방향으로 커질 수록 $P_2$의 바깥쪽 방향에 점이 생성된다. 따라서 아핀 결합으로 생성되는 점을 모두 모으면 두 점 $P_1$, $P_2$을 지나는 무한한 긴 선이 만들어질 것이다. 이것을 수식으로 확인해보면, $a \\cdot + (1 - a) \\cdot P_2 = P\u0026rsquo;$을 $a$로 묶어서 다시 정리하면 $a(P_1. - P_2) = (P\u0026rsquo; - P_2)$이다. 이것을 두 이동 벡터로 나타내면, $a \\cdot \\vec{u} = \\vec{v}$이다. 이 식으로 두 벡터가 평행하다는 것을 알 수 있고, 따라서 아핀 결합으로 생성되는 점은 두 점을 지나는 직선 상에 위치함을 보장받게 된다. 직선의 방정식 $L(a) = a \\cdot P_1 + (1 - a) \\cdot P_2$ 직선의 방정식은 $a$의 범위에 따라 다양한 종류의 선에 대응된다. (a) 직선(Line) 양쪽 받향으로 무한히 뻗어나가는 선. 추상적인 선의 성질을 표현할 때 사용한다. (b) 반직선(Ray) 지정한 위치에서 한쪽으로만 뻗어나가는 선. 레이캐스팅(Raycasting), 레이트레이싱(Raytracing)에 사용된다. (c) 선분(Line segment) 시작점과 끝점의 위치가 정해져 있는 선. 프로그래밍을 활용해서 화면에 선을 그릴 때 사용한다. 선 그리기 알고리즘 벡터를 모니터의 점으로 표현 데카르트 좌표계가 빈틈 없이 연속된(Continuous) 실수로 평면을 채우는 반면, 스크린 좌표계는 서로 독립된 영역을 가지는 이산적인(Discrete) 정수를 사용한다.\n픽셀(Pixel)\n스크린 좌표계를 사용해서 화면에 무언가를 표현하려면 스크린 좌표와 색상이 함께 지정되어야 한다. 이 때, 좌표와 색상에 대응하는 화면의 구성 요소를 픽셀이라고 한다. 픽셀화(Rasterization)\n벡터를 화면의 점으로 표현하기 위해서 실수로 표현된 벡터 좌표를 정수로 변환한 후 색상을 부여하는 과정을 픽셀화라고 한다. 데카르트 좌표계와 스크린 좌표계의 차이 데카르트 좌표계 스크린 좌표계 수 집합 실수 정수 수의 성질 연속성 이산성 단위 원소 벡터 픽셀 수의 범위 실수 범위 $0$부터 해상도 크기까지 선 그리기 알고리즘 브레젠험 알고리즘(Bresenham\u0026rsquo;s algorithm) 화면을 8등분영역으로 구분한 후, 각 영역별로 그려내는 방식을 사용한다. 픽셀을 선택하기 위해서 중간값 $0.5$를 사용하기 때문에 중점 알고리즘(Midpoint algorithm) 이라고도 한다. 첫 번째 영역인 1팔분면(Octant)은 $[0^\\circ , 45^\\circ]$의 범위를 가진다. 이것은 해당 영역에 존재하는 모든 선의 기울기가 $1$을 넘어설 수 없음을 의미한다. 시작 위치의 픽셀 $(x_0, y_0)$을 찍은 후에 그 다음 픽셀을 어디에 찍어야 할까? 1팔분면의 특성상 평행으로 이동하거나 아래로 한 칸 내려가게 될 것이다. 오른쪽으로 한 칸 이동한 $x$좌표는 $x_0 + 1$이 된다. $y$좌표는 평행($y_0$)이거나, 아래로 한 칸 내려갈($y_0 + 1$) 것이다. 둘 중에서 어떤 것일지 판단하기 위해서 중간값인 $y_0 + 0.5$를 사용한다. 즉, $y_0 + 0.5$를 기준으로 우리가 그리려는 $y$값이 더 작으면 수평으로 이동하고($y_0$), 그렇지 않으면 아래로 한 칸 내려가는($y_0 + 1$) 것이다. 이것을 직선의 방정식 $y = ax + b$을 사용해서 구하면 $2h - w \u0026lt; 0$이라는 판별식이 도출된다. (풀이 생략) 그 다음 픽셀은? 이전에 평행이동을 했다면, $(x_0 + 2, y_0 + 0.5)$을 직선의 방정식에 대입해서 판별식이 $4h - w \u0026lt; 0$이 된다. 이전에 아래로 내려갔다면, $(x_0 + 2, y_0 + 1.5)$을 직선의 방정식에 대입해서 판별식이 $4h - 3w \u0026lt; 0$이 된다. 이처럼 $x$값이 증가할 수록 판별식은 언제나 $2h$만큼 증가하며, 한 칸 내려갈 수록 $2w$만큼 줄어든다. 2팔분면은 1팔분면에서 $x$, $y$가 변경되었을 뿐 전개 방식은 동일하다. 3팔분면은 2팔분면에서 선분의 진행방향만 반대일 뿐 기본 원리는 동일하다. 따라서 다음과 같이 구현해 볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 void DrawLine(const Vector2\u0026amp; InStartPos, const Vector2\u0026amp; InEndPos, const LinearColor\u0026amp; InColor) { // 시작점과 끝점이 화면 영역을 벗어나면 클리핑 알고리즘을 수행한다(다음 절에서 살펴본다) Vector2 clippedStart = InStartPos; Vector2 clippedEnd = InEndPos; Vector2 screenExtend = Vector2(_ScreenSize.X, _ScreenSize.Y) * 0.5f; Vector2 minScreen = -screenExtend; Vector2 maxScreen = screenExtend; if (!CohenSutherlandLineClip(clippedStart, clippedEnd, minScreen, maxScreen)) { return; } ScreenPoint startPosition = ScreenPoint::ToScreenCoordinate(_ScreenSize, clippedStart); ScreenPoint endPosition = ScreenPoint::ToScreenCoordinate(_ScreenSize, clippedEnd); int width = endPosition.X - startPosition.X; int height = endPosition.Y - startPosition.Y; // 완만한 경사(1, 4, 5, 8팔분면)인가? 아닌가(2, 3, 6, 7팔분면)? bool isGradualSlope = (Math::Abs(width) \u0026gt;= Math::Abs(height)); // x, y축의 진행방향 int dx = (width \u0026gt;= 0) ? 1 : -1; int dy = (height \u0026gt; 0) ? 1 : -1; int fw = dx * width; int fh = dy * height; // 경사에 따른 판별식 int f = isGradualSlope ? fh * 2 - fw : 2 * fw - fh; // 변화 없을 시 판별식에 적용할 값 int f1 = isGradualSlope ? 2 * fh : 2 * fw; // 변화 있을 시 판별식에 적용할 값 int f2 = isGradualSlope ? 2 * (fh - fw) : 2 * (fw - fh); // 최초 선 그리기 지점 int x = startPosition.X; int y = startPosition.Y; // 완만한 경사(1, 4, 5, 8) if (isGradualSlope) { while (x != endPosition.X) { SetPixel(ScreenPoint(x, y), InColor); if (f \u0026lt; 0) // 변화가 없는 경우 { f += f1; } else. // 변화가 있는 경우 { f += f2; y += dy; // 변화가 있을 때만 y가 이동한다. } x += dx; // 언제나 x는 이동한다. } } else // 급격한 경사(2, 3, 6, 7) { while (y != endPosition.Y) { SetPixel(ScreenPoint(x, y), InColor); if (f \u0026lt; 0) { f += f1; } else { f += f2; x += dx; // x, y가 완만한 경우와 반대이다. } y += dy; } } } 라인 클리핑 알고리즘 클리핑(Clipping) 선분이 가진 성질은 유지하면서 지정된 영역에 맞는 데이터로 재설정하는 작업이다. 코헨-서덜랜드 라인 클리핑 알고리즘(Cohen-Sutherland line clipping algorithm) 그릴 영역을 정 가운데에 두고 그 외의 바깥 영역을 포함해서 총 9개로 영역을 설정한다. 상위 두 비트는 상하 정보를, 하위 두 비트는 좌우 정보를 담아서 총 4자리의 이진수 값으로 고유한 값을 부여한다. 여기서 정 가운데의 0000이 눈에 보이는 화면 영역이다. 선분을 그릴 때 고려해야 할 상황은 세 가지로 나뉜다. (1) 화면 안에 위치해서 자를 필요가 없는 경우 시작점과 끝점 모두 0000이다. (2) 화면 밖에 위치해서 그릴 필요가 없는 경우 시작점과 끝점의 \u0026amp;연산 결과가 $0$보다 큰 값이 나온다. 혹은 $0$이 나올 때도 있다. 이 경우에는 클리핑을 한 후 다시 검사한다. (3) 화면을 가로질러서 화면에 유효한 영역으로 잘라내야 하는 경우 시작점과 끝점의 \u0026amp;연산 결과가 $0$이 나온다. 따라서 클리핑을 한다. 따라서 다음과 같이 구현해 볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // 주어진 점의 영역값을 돌려준다. int TestRegion(const Vector2\u0026amp; InVectorPos, const Vector2\u0026amp; InMinPos, const Vector2\u0026amp; InMaxPos) { int result = 0; if (InVectorPos.X \u0026lt; InMinPos.X) { result = result | 0b0001; } else if (InVectorPos.X \u0026gt; InMaxPos.X) { result = result | 0b0010; } if (InVectorPos.Y \u0026lt; InMinPos.Y) { result = result | 0b0100; } else if (InVectorPos.Y \u0026gt; InMaxPos.Y) { result = result | 0b1000; } return result; } // 클리핑한다. bool CohenSutherlandLineClip(Vector2\u0026amp; InOutStartPos, Vector2\u0026amp; InOutEndPos, const Vector2\u0026amp; InMinPos, const Vector2\u0026amp; InMaxPos) { int startTest = TestRegion(InOutStartPos, InMinPos, InMaxPos); int endTest = TestRegion(InOutEndPos, InMinPos, InMaxPos); float width = (InOutEndPos.X - InOutStartPos.X); float height = (InOutEndPos.Y - InOutStartPos.Y); while (true) { if ((startTest == 0) \u0026amp;\u0026amp; (endTest == 0)) // 화면 안에 두 점이 있으면 바로 그리기 { return true; } else if (startTest \u0026amp; endTest) // 화면 밖에 선이 있으므로 그릴 필요가 없음 { return false; } else // 양쪽을 조사해 클리핑 진행 { Vector2 clippedPosition; bool isStartTest = (startTest != 0); int currentTest = isStartTest ? startTest : endTest; if (currentTest \u0026lt; 0b0100) { if (currentTest \u0026amp; 1) { clippedPosition.X = InMinPos.X; } else { clippedPosition.X = InMaxPos.X; } if (Math::EqualsInTolerance(height, 0.0f)) { clippedPosition.Y = InOutStartPos.Y; } else { clippedPosition.Y = InOutStartPos.Y + height * (clippedPosition.X - InOutStartPos.X) / width; } } else { if (currentTest \u0026amp; 0b0100) { clippedPosition.Y = InMinPos.Y; } else { clippedPosition.Y = InMaxPos.Y; } if (Math::EqualsInTolerance(width, 0.0f)) { clippedPosition.X = InOutStartPos.X; } else { clippedPosition.X = InOutStartPos.X + width * (clippedPosition.Y - InOutStartPos.Y) / height; } } // 클리핑한 결과로 다시 테스트 진행. if (isStartTest) { InOutStartPos = clippedPosition; startTest = TestRegion(InOutStartPos, InMinPos, InMaxPos); } else { InOutEndPos = clippedPosition; endTest = TestRegion(InOutEndPos, InMinPos, InMaxPos); } } } return true; } ","date":"2022-04-23T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-06/","title":"[Game Math] Chapter 6. 아핀 공간: 움직이는 가상 세계의 구축"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n선형성: 예측 가능한 비례 관계 선형성(Linearity) 이란? 직선의 형태를 띠는 성질을 의미한다. 함수 $f$에 대해 다음 두 가지 조건을 만족하면 함수 $f$는 선형이라고 한다. (1) 가법성(Additivity) 임의의 수 $x_1$, $x_2$에 대해 $f(x_1 + x_2) = f(x_1) + f(x_2)$ (2) 1차 동차성(Homogeneity) 임의의 수 $x$, $k$에 대해 $f(kx) = kf(x)$ 선형 함수 직선의 함수 $f(x) = ax$의 경우 가법성: $f(x_1 + x_2) = f(x_1) + f(x_2)$ $a(x_1 + x_2) = ax_1 + ax_2$이므로, $a$, $x_1$, $x_2$가 모두 체의 성질을 가지는 실수라면 분배법칙이 성립해서 OK 1차 동시성: $f(kx) = kf(x)$ $a(kx) = k(ax)$이므로, $a$, $x$, $k$가 모두 체의 성질을 가지는 실수라면 체는 곱셈에 대해 결합법칙과 교환법칙이 성립하므로 OK 곡선의 형태를 띠는 $f(x) = x^2$의 경우 가법성: $f(x_1 + x_2) = f(x_1) + f(x_2)$ $x_1^2 + x_2^2 + 2x_1x_2 = x_1^2 x_2^2$이므로, NO 스칼라 $b$를 더해본 $f(x) = ax + b$의 경우 가법성: $f(x_1 + x_2) = f(x_1) + f(x_2)$ $ax_1 + ax_2 + b = ax_1 + b + ax_2 + b$이므로, NO 어째서 직선의 형태를 띰에도 선형성을 만족하지 않을까? 선형성이란 두 집합의 순수한 비로 구성된 1차적 대응 관계를 의미한다. 단지 곧게 뻗은 직선의 성질을 뜻하는 것이 아니다. 순수한 비로 구성되어 있기 때문에 다른 입력값을 투여했을 때 어떤 출력값이 나올지 쉽게 예측할 수 있고, 반대로 역함수($f(x) = \\frac{1}{a}x$)를 사용해서 출력값으로부터 입력값을 계산하는 것이 가능하다. 따라서 원점에서 벗어난 $f(x) = ax + b$의 경우 선형성을 만족하지 못한다. 벡터 공간의 선형 변환 그렇다면, 입력과 출력을 실수가 아닌 벡터를 넣어보자!\n선형성을 가지는 함수는 순수한 비의 형태로 구성되어 있으므로, $\\vec{v} = (x, y)$에서 $x$와 $y$에 선형성을 유지하고자 한다면 다음과 같이 설계해 볼 수 있겠다. $f(\\vec{v}) = f(x, y) = (ax + by, cx + dy)$\n이 식은 가법성과 1차 동차성을 만족하므로 선형성을 지닌다. (풀이 생략) 따라서 순수한 비를 통해 예측할 수 있는 형태로 변환되며, 역함수를 통해 변환 후의 벡터로부터 변환 전의 벡터를 파악할 수 있다. 표준기저벡터의 선형 결합으로 형성된 벡터 공간은 선형성을 지닌다. 그리고 이 벡터 공간을 위와 같은 선형 함수를 이용해서 변화시킨 새로운 공간도 표준기저벡터의 선형 결합으로 형성되므로 선형성을 지니겠다.\n이렇게 동일한 구조를 지니는 두 공간의 대응관계를 변환(Transformation)이라고 하며, 선형성을 유지시켜주는 위와같은 선형 함수를 선형 변환(Linear transformation) 이라고 한다. 스칼라 곱셈 $f(\\vec{v}) = f(x, y) = (kx, ky)$의 경우\n$(ax + by, cx + dy)$에다가 $a = k, b = 0, c = 0, d = k$를 대입한 것이므로, 선형변환이다. 벡터를 회전시키는 $f(\\vec{v}) = f(x, y) = (\\cos\\theta x - \\sin\\theta y, \\cos\\theta x + \\sin\\theta y)$의 경우\n$(ax + by, cx + dy)$에다가 $a = \\cos\\theta, b = - \\sin\\theta, c = \\cos\\theta, d = \\sin\\theta$를 대입한 것이므로, 선형변환이다. 게임 세계에서 모든 변환들은 선형 변환에 기초를 두고 있다. 이런 선형 변환의 계산 과정을 체계화해서 손쉽게 계산할 수 있다면 좋겠다! 그것이 바로 행렬(Matrix) 이다. 행렬 행렬은 수를 사각형의 형태로 행과 열을 맞춰 배열한 테이블이다.\n행렬로 벡터를 나타낼 수 있다.\n열벡터: $$ \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$ 행벡터: $$ \\begin{bmatrix} x \u0026amp; y \\end{bmatrix} $$ 선형변환을 표현할 때는 행과 열의 크기가 같은 정방행렬(Square matrix) 을 사용한다.\n$f(x, y) = (ax + by, cx + dy)$의 경우에는 $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}$$과 같이 표현할 수 있겠다. 행렬의 기본 연산 반드시 알아야 하는 행렬의 연산들 (1) 행렬과 행렬의 덧셈 $$A + B = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} + \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix} = \\begin{bmatrix} a+e \u0026amp; b+f \\\\ c+g \u0026amp; d+h \\end{bmatrix} $$ (2) 행렬과 스칼라의 곱셈 $$k \\cdot A = k \\cdot \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} = \\begin{bmatrix} k \\cdot a \u0026amp; k \\cdot b \\\\ k \\cdot c \u0026amp; k \\cdot d \\end{bmatrix} $$ (3) 행렬의 전치(Transpose of a matrix) 첨자 $T$으로 표시하며, 행과 열을 바꾸는 연산이다. $$\\begin{bmatrix} a \u0026amp; d \\\\ b \u0026amp; e \\\\ c \u0026amp; f \\end{bmatrix}^T = \\begin{bmatrix} a \u0026amp; b \u0026amp; c \\\\ d \u0026amp; e \u0026amp; f \\end{bmatrix}$$ (4) 행렬과 행렬의 곱셈 (행렬 곱) 행렬과 행렬의 곱셈 앞의 행벡터와 뒤의 열벡터를 각각 곱해서 더한다. $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix} = \\begin{bmatrix} ae + bg \u0026amp; af + bh \\\\ ce + dg \u0026amp; cf + dh \\end{bmatrix}$$ 교환법칙이 성립하지 않는다. $A \\cdot B \\neq B \\cdot A$ 결합법칙이 성립한다. $A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C$ 행렬 곱을 전치한 결과는 순서를 바꾼 후 각각 전치해서 곱한 결과와 동일하다. $(A \\cdot B)^T = B^T \\cdot A^T$ 2차원 벡터에 선형 변환을 적용해서 새로운 벡터를 생성하는 작업. $f(x, y) = (ax + by, cx + dy)$ 를 표현하면 다음과 같다. $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ 연산의 순서는 오른쪽에서 왼쪽으로 역방향으로 이루어짐을 알 수 있다. 정방행렬의 곱셈 $2 \\times 2$정방행렬 간의 곱은 합성함수에 대응되는 연산이다. 벡터 $\\vec{v}$에 선형 변환을 나타내는 $2 \\times 2$정방행렬 $A$, $B$를 순서대로 연산하는 것은 다음과 같다. $B \\cdot A \\cdot \\vec{v}$ 행렬의 곱셈은 결합법칙이 성립하기 때문에 컴퓨터 그래픽 연산에서 계산량을 크게 줄일 수 있다. 예를 들어, 100개의 점을 5번씩 선형 변환($A$, $B$, $C$, $D$, $E$)을 한다고 하면, $E \\cdot D \\cdot C \\cdot B \\cdot A \\cdot \\vec{v_1}$과 같은 작업이 100번 이루어지며, 총 500번의 행렬곱 연산이 필요하다. 하지만 $F = E \\cdot D \\cdot C \\cdot B \\cdot A$과 같이 합성함수에 해당하는 $F$를 미리 만들어 두면, $F \\cdot \\vec{v_1}$과 같이 점 당 한 번씩만 행렬곱을 하면 된다. 그래서 총 104번의 행렬곱 연산만 하면 된다. 열 기준 행렬과 행 기준 행렬 열 기준 행렬 역방향으로 연산된다. 사례: DirectX, Unity $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ 행 기준 행렬 순방향으로 연산된다. 사례: OpenGL, Unreal 열 기준 행렬에 전치연산을 적용하면 된다. $(A \\cdot \\vec{v})^T = \\vec{v}^T \\cdot A^T$ $$\\begin{bmatrix} x \u0026amp; y \\end{bmatrix} \\cdot \\begin{bmatrix} a \u0026amp; c \\\\ b \u0026amp; d \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$ 행렬의 설계 평면 상의 물체를 원하는 대로 변환하기 위해 $2 \\times 2$행렬을 설계해보자. 아래 그림과 같이 표준기저벡터를 변화시켜서 벡터와 선형 결합을 하면 $$\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix}$$와 동일한 값을 가진다. 따라서 표준기저벡터를 변화시킨 벡터인 $(a, c)$와 $(b, d)$는 정방행렬을 구성하는 열벡터임을 알 수 있다. 크기 변환행렬 (Scale transformation matrix) 물체를 크기를 변경하는 행렬을 설계해보자. 표준기저벡터 $e_1$을 $a$배 늘리거나 줄인 벡터: $a \\cdot (1, 0) = (a, 0)$ 표준기저벡터 $e_2$을 $b$배 늘리거나 줄인 벡터: $b \\cdot (0, 1) = (0, b)$ 그렇다면 이 두 표준기저벡터를 열벡터로 설정하면 다음과 같은 크기 변환행렬을 만들 수 있겠다. $$S = \\begin{bmatrix} a \u0026amp; 0 \\\\ 0 \u0026amp; b \\end{bmatrix}$$ 회전 변환행렬 (Rotation transformation matrix) 물체를 각 $\\theta$만큼 회전시키는 행렬을 설계해보자. Chapter 4에서 살펴본 바와 같이 표준기저벡터가 $\\theta$만큼 회전한 결과는 $(\\cos\\theta, \\sin\\theta)$와 $(-\\sin\\theta, \\cos\\theta)$가 된다. 따라서 이 두 표준기저벡터를 열벡터로 설정해서 다음과 같은 회전 변환행렬을 만들 수 있겠다. $$R_\\theta = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ 전단 변환행렬 (Shear transformation matrix) 표준기저벡터 $e_1$은 고정한 상태에서 $e_2$를 $x$축 방향으로 $a$만큼 미는 변환을 생각해보자. 이러한 것을 전단변환이라고 하며, 전단변환행렬은 다음과 같을 것이다. $$S = \\begin{bmatrix} 1 \u0026amp; a \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ 삼각함수의 덧셈 정리 위 그림과 같이 $\\alpha$와 $\\beta$를 합한 만큼 회전한 행렬은 다음과 같이 나타낼 수 있다. $$R_(\\alpha + \\beta) = \\begin{bmatrix} \\cos(\\alpha + \\beta) \u0026amp; -\\sin(\\alpha + \\beta) \\\\ \\sin(\\alpha + \\beta) \u0026amp; \\cos(\\alpha + \\beta) \\end{bmatrix}$$ 여기서 $\\alpha + \\beta$의 회전변환은 $\\alpha$만큼 회전한 후, $\\beta$만큼 회전한 것과 같다. 따라서 다음과 같은 결과가 나온다. $$R_\\beta \\cdot R_\\alpha = \\begin{bmatrix} \\cos(\\beta) \u0026amp; -\\sin(\\beta) \\\\ \\sin(\\beta) \u0026amp; \\cos(\\beta) \\end{bmatrix} \\begin{bmatrix} \\cos(\\alpha) \u0026amp; -\\sin(\\alpha) \\\\ \\sin(\\alpha) \u0026amp; \\cos(\\alpha) \\end{bmatrix}$$ $$ = \\begin{bmatrix} \\cos\\alpha\\cos\\beta - \\sin\\alpha\\sin\\beta \u0026amp; -(\\cos\\alpha\\sin\\beta + \\sin\\alpha\\cos\\beta) \\\\ \\cos\\alpha\\sin\\beta + \\sin\\alpha\\cos\\beta \u0026amp; \\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta \\end{bmatrix}$$ 여기서 삼각함수의 덧셈 정리를 얻을 수 있다. $\\cos(\\alpha + \\beta) = \\cos\\alpha\\cos\\beta- \\sin\\alpha\\sin\\beta$ $\\sin(\\alpha + \\beta) = \\cos\\alpha\\sin\\beta + \\sin\\alpha\\cos\\beta$ 추가적으로 삼각함수의 배각 공식은 각 $\\beta$대신 $\\alpha$를 대입해서 얻을 수 있다. $\\cos 2 \\alpha = 1 - 2 \\sin^2 \\alpha$ $\\sin 2 \\alpha = 2 \\sin \\alpha \\cos \\alpha$ 역행렬 행렬은 본질적으로 함수의 성질을 지니기 때문에 항등행렬과 역행렬이라는 개념이 존재한다.\n항등행렬(Identity matrix)\n원 공간의 변화없이 동일한 공간으로 유지하는 변환을 의미한다. 표준기저벡터 $(1, 0)$과 $(0, 1)$을 순서대로 넣어 만들 수 있다. $$I = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ 역행렬(Inverse matrix)\n행렬 곱의 결과가 항등행렬이 나오는 행렬을 의미한다. $A \\cdot A^{-1} = A^{-1} \\cdot A = I$ 역행렬을 시각적으로 나타내본다면, 아래 그림과 같이 선형 변환된 벡터 공간을 원 벡터 공간으로 다시 되돌리는 선형 변환이라고 볼 수 있다. 역행렬의 존재를 판별하는 성립식 역행렬 또한 함수이므로, 두 공간의 변환이 전단사로 대응될 때만 역행렬이 존재한다. 역행렬이 존재하는지 파악할 수 있는 특별한 수식이 있는 데 이것을. 행렬식(Determinant) 이라고 한다. $2 \\times 2$정방행렬 $A$의 행렬식은 다음과 같이 계산한다. $$A = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}$$ $det(A) = ad - bc$ $det(A)$의 값이 $0$인 선형 변환은 전단사 대응이 성립하지 않아서 역행렬이 존재하지 않는다. 행렬식이 $0$이라는 것의 의미는 무엇일까? 임의의 행렬 $$A = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}$$를 사용해서 표준기저벡터가 $(a, c)$와 $(b, d)$로 변환된 새로운 벡터 공간의 넒이는 어떻게 될까? 이 넓이 $Area(P)$는 전체 사각형의 넓이에서 평행사변형을 제외한 삼각형과 사각형을 빼서 구할 수 있으며, 결과적으로 행렬식과 동일하게 된다. $Area(P) = ad - bc$ 따라서 이 넓이가 $0$이라는 것은 2차원의 평면 영역이 1차원의 직선 영역으로 압축되었다는 것을 뜻하며, 그렇기 때문에 다시 2차원으로 돌아갈 수 없게된다. 행렬식이 음수가 나온다면? $ad - bc$에서 모든 수가 양수일 때 $a \u0026lt; b$이고, $d \u0026lt; c$이면 계산 결과는 음수가 나온다. 이것은 두 표준기저벡터가 엇갈리면서 평면이 뒤집힌 것이라고 볼 수 있다. 크기 변환행렬의 역행렬 $$S = \\begin{bmatrix} a \u0026amp; 0 \\\\ 0 \u0026amp; b \\end{bmatrix}$$ $$S^{-1} = \\begin{bmatrix} \\frac{1}{a} \u0026amp; 0 \\\\ 0 \u0026amp; \\frac{1}{b} \\end{bmatrix}$$ 전단 변환행렬의 역행렬 $$S = \\begin{bmatrix} 1 \u0026amp; a \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ $$S^{-1} = \\begin{bmatrix} 1 \u0026amp; -a \\\\ 0 \u0026amp; 1 \\end{bmatrix}$$ 회전 변환행렬의 역행렬 Chapter 4에서 보았던 $\\sin$, $\\cos$함수의 다음과 같은 성질을 사용해서 역행렬을 구할 수가 있겠다. $\\cos(-\\theta) = \\cos(\\theta)$ $\\sin(\\theta) = -\\sin(\\theta)$ $$R_{\\theta} = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\ \\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ $$R_{\\theta}^{-1} = \\begin{bmatrix} \\cos\\theta \u0026amp; \\sin\\theta \\\\ -\\sin\\theta \u0026amp; \\cos\\theta \\end{bmatrix}$$ 이 결과는 전치행렬과 동일하므로, 회전 변환행렬의 역행렬은 전치연산을 적용하는 방법으로 쉽게 구할 수 있겠다. $R_{\\theta}^{-1} = R_{\\theta}^{T}$ 행렬 곱의 역행렬 행렬 곱은 합성 함수이므로 다음과 같은 수식이 성립한다. $(g \\circ f)^{-1} = f^{-1} \\circ g^{-1}$ $(A \\cdot B)^{-1} = B^{-1} \\cdot A^{-1}$ ","date":"2022-04-22T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-05/","title":"[Game Math] Chapter 5. 행렬: 가상 세계의 변환 도구"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n삼각함수 삼각비(Trigonometric ratio) 직각삼각형을 구성하는 세 변에서, 직각이 아닌 각에 대한 두 변의 비례관계를 나타낸 것이다. 삼각비를 구하려면 꼭 직각삼각형이어야 하므로, $\\theta$는 늘 $0^\\circ$와 $90^\\circ$ 사이이다. 그렇다면 $90^\\circ$를 넘어서는 각에 대해서는 삼각비를 구할 수 없을까? 삼각함수(Trigonometric function)\n각의 크기를 삼각비로 나타내는 함수이다. 직각삼각형을 데카르트 좌표계 상에 배치하고, 사잇각의 범위를 실수 전체인 $\\mathbb{R^2}$집합으로 확장하였다. 반지름이 $1$인 원을 사용하면 삼각함수를 좀 더 쉽게 파악할 수 있다.\n$\\sin\\theta = \\frac{b}{1} = b$이고, $\\cos\\theta = \\frac{a}{1} = a$이므로, 원주 위의 모든 좌표는 $(\\cos\\theta, \\sin\\theta)$에 대응한다. 이것을 피타고라스 정리에 대입하면, $\\cos^2\\theta + \\sin^2\\theta = 1$과 같은 공식을 얻을 수 있다. 이번에는 반지름을 $r$으로 일반화시켜 생각해보자.\n벡터의 개념으로 생각했을 때, 길이가 $1$에서 $r$만큼 증가 했으므로, 스칼라 곱셈에 의해 $r\\cdot(\\cos\\theta, \\sin\\theta)$라는 좌표를 얻을 수 있다. 따라서 밑변과 높이는 각각 $r\\cdot\\cos\\theta$와 $r\\cdot\\sin\\theta$가 된다. 이것을 피타고라스 정리에 대입하면, $r^2(\\cos^2\\theta + \\sin^2\\theta) = r^2$이므로, 반지름 길이와 무관하게 $\\cos^2\\theta + \\sin^2\\theta = 1$식은 성립한다. 삼각함수의 성질 데카르트 좌표계에서의 각도란? $x$축에서 원의 궤적을 따라 반시계 방향으로 회전한 크기를 의미한다. 반지름이 $1$인 단위 원에서 반시계 방향의 회전을 생각해보자. 아직 회전하지 않은 상태에서 빗변 $\\vec{v}$는 $x$축에 위치하며, 좌표는 $(1, 0)$이다. 이것의 각도는 $0^\\circ$이겠다. 여기서 각도를 서서히 증가시키다면? $v_x$와 $v_y$의 변화량을 나타내면 아래 그림과 같을 것이다. 값의 변화는 $[-1, 1]$범위(진폭, Amplitude) 내에서 $360^\\circ$마다 반복(주기, Period)된다. 짝함수(Even function) $y$축을 기준으로 좌우를 접었을 때 $\\cos$함수와 같이 좌우 대칭인 함수. $\\cos(-\\theta) = \\cos(\\theta)$ 홀함수(Odd function) $\\sin$함수와 같이 원점 대칭인 함수. $\\sin(-\\theta) = -\\sin(\\theta)$ $\\tan$함수의 특징 빗변과 무관하게 밑변과 높이의 관계만을 나타낸다. $\\tan\\theta = \\frac{b}{a}$ 분자와 분모를 모두 빗변 값으로 나누면? $\\tan\\theta = \\frac{\\frac{b}{c}}{\\frac{a}{c}} = \\frac{\\sin\\theta}{\\cos\\theta}$ 분모의 값은 0이 될 수 없기 때문에, 분모인 $\\cos$함수의 값이 $0$이 되는 각도(예를 들면, $90^\\circ$)에서는 $\\tan$값이 존재하지 않는다. $\\sin$함수처럼 홀함수의 성질을 지닌다. 각의 측정법 각도법(Degree)\n우리가 일상생활에서 사용하듯이 $0$에서 $360$까지의 수를 사용하는 방법. 호도법(Radian)\n호의 길이를 기준으로 각을 측정하는 방법. 크기 1인 단위벡터를 사용해서 크기를 비교하는 것처럼, 호의 길이가 1이 되는 부채꼴의 각을 기준으로 각을 측정한다. 반원의 호길이는 $\\pi$이므로 다음과 같은 변환식을 만들 수 있다. $1^\\circ = \\frac{\\pi}{180} (rad)$ $1 (rad) = (\\frac{180}{\\pi})^\\circ$ 삼각함수를 활용한 물체의 회전 물체를 이동시키고, 크기를 늘리는 것은 $x$축과 $y$축이 서로 독립적으로 적용된다. 따라서 이 두 축을 서로 분리해서 따로 계산한 후 결합한 것과 동일하다. 하지만 회전은 $x$와 $y$값이 함께 영향을 미치기 때문에 분리해서 독립적으로 계산할 수 없다. 기저벡터 개념을 활용해서 회전시켜보자.\n$\\mathbb{R^2}$의 기저벡터 $e_1 = (1, 0)$과 $e_2 = (0, 1)$을 각 $\\theta$만큼 회전시키면?\n$e_1\u0026rsquo; = (\\cos\\theta, \\sin\\theta)$과 $e_2\u0026rsquo; = (-\\sin\\theta, \\cos\\theta)$가 될 것이다. $(1, 1)$에 위치한 벡터 $\\vec{v}$는 $\\vec{v} = 1 \\cdot e_1 + 1 \\cdot e_2$라고 표현할 수 있다.\n이 벡터를 $\\theta$만큼 회전시키면?\n$\\vec{v}\u0026rsquo; = 1 \\cdot (\\cos\\theta, \\sin\\theta) + 1 \\cdot (-\\sin\\theta, \\cos\\theta)$이며, 따라서 $\\vec{v}\u0026rsquo; = (\\cos\\theta - \\sin\\theta, \\sin\\theta + \\cos\\theta)$가 된다. 이것을 일반화시킨다면, $(x, y)$에 위치한 벡터를 $\\theta$만큼 회전한 $(x\u0026rsquo;, y\u0026rsquo;)$는 다음과 같다. $x\u0026rsquo; = x\\cos\\theta - y\\sin\\theta$ $y\u0026rsquo; = x\\sin\\theta + y\\cos\\theta$ 삼각함수의 역함수 벡터의 좌표를 가지고 대응하는 각도를 알아내는 법. 각 삼각함수의 정의역과 공역의 범위를 제한시키면 전단사함수를 만들 수 있다. 이것은 역함수도 구할 수 있다는 것을 의미한다. $\\sin$함수가 $\\theta$값이 주어졌을 때, 두 변의 비례관계를 구한다면, $\\arcsin$함수는 거꾸로 $\\sin$함수의 값인 두 변의 비례관계가 주어지면, 그것을 통해 $\\theta$ 값을 구할 수 있는 것이다. $\\sin^{-1}(x) = \\arcsin(x)$\n정의역: $[-90^\\circ, 90^\\circ]$ 공역: $[-1, 1]$ $\\cos^{-1}(x) = \\arccos(x)$\n정의역: $[0^\\circ, 180^\\circ]$ 공역: $[-1, 1]$ $\\tan^{-1}(x) = \\arctan(x)$\n정의역: $(-90^\\circ, 90^\\circ)$ 공역: 실수 영역 전체 $\\arctan$ 함수는 벡터의 각도를 구하는 데 유용하게 사용할 수 있다.\n$\\vec{v} = (x, y)$라는 임의의 벡터가 있을 때, $\\tan\\theta$는 $\\frac{y}{x}$이다. 이 값을 이용해서 $\\arctan$함수로 $\\theta$에 해당하는 각도값을 구할 수 있다. 하지만! $\\arctan$함수는 정의역이 $(-90^\\circ, 90^\\circ)$으로 한정되어 있다는 문제가 있다. 따라서 각 축인 $x$와 $y$를 따로 분리해서 전달하는 함수인 $atan2$함수를 사용한다. $atan2(y, x)$\n정의역: $[-180^\\circ, 180^\\circ]$ 공역: 실수 영역 전체 극좌표계 데카르트 좌표계\n앞에서 본 것처럼 회전을 구현하면 회전에 따른 $x$, $y$의 변화를 매번 계산하는 번거로움이 발생한다. 극좌표계(Polar coordinate system)\n$(r, \\theta)$ 원점으로부터의 거리 $r$과, 각 $\\theta$의 두 요소로 구성된다. 극좌표계는 원형공간의 특징을 지닌다. 따라서 스킬 쿨타임 아이콘 등 회전에 관련된 효과를 줄 때 많이 사용된다. 데카르트 좌표계에서 극좌표계로 변환\n$r = \\sqrt{x^2 + y^2}$ $\\theta = atan2(x, y)$ 극좌표계에서 데카르트 좌표계로 변환\n$x = r \\cdot \\cos\\theta$ $y = r \\cdot \\sin\\theta$ ","date":"2022-04-21T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-04/","title":"[Game Math] Chapter 4. 삼각함수: 회전을 위한 수학"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n데카르트 좌표계 데카르트 좌표계(Cartesian coordinate system) Chapter 2에서 보았던 것처럼, 직선으로 된 수 집합을 수직으로 배치해서 평면을 표기하는 방식. 좌표(Coordinate) 데카르트 좌표계의 한 원소이다. 곱집합과 동일하게 순서쌍으로 표현한다. 벡터 공간과 벡터 스칼라와 벡터 벡터 공간(Vector space) 두 개 이상의 실수를 곱집합으로 묶어서 형성된 집합을 공리적 집합론의 관점에서 규정한 것. 벡터(Vector) 벡터 공간의 원소. $\\vec{v} = (x, y)$ 스칼라(Scalar) 체 구조를 가지는 수 집합의 원소. $x$, $y$ 벡터 공간의 연산 벡터 공간의 두 가지 기본 연산 (선형성이 있어서 선형 연산이라고 한다) (1) 벡터와 벡터의 덧셈(벡터의 합) (2) 스칼라와 벡터의 곱셈(스칼라 곱셈, 스칼라배) 벡터 공간의 8가지 공리 분류 공리 수식 벡터의 합 닫혀 있다 $\\vec{a}$, $\\vec{b}$가 벡터 공간 $V$에 존재하면 $\\vec{a} + \\vec{b}$도 $V$에 존재한다. 결합법칙 $\\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w}$ 교환법칙 $\\vec{u} + \\vec{v} = \\vec{v} + \\vec{u}$ 항등원 $\\vec{v} + \\vec{0} = \\vec{v}$ 역원 $\\vec{v} + (-\\vec{v}) = \\vec{0}$ 스칼라배 닫혀 있다 $\\vec{v}$가 벡터 공간 $V$에 존재하면 $a\\vec{v}$도 $V$에 존재한다. 결합법칙 $a(b\\vec{v}) = (ab)\\vec{v}$ 항등원 $1 \\cdot \\vec{v} = \\vec{v}$ (좌)분배법칙 $a(\\vec{u} + \\vec{v}) = a\\vec{u} + a\\vec{v}$ (우)분배법칙 $(a + b)\\vec{v} = a\\vec{v} + b\\vec{v}$ 벡터의 크기와 이동 벡터의 크기 피타고라스 정리를 사용해서 측정할 수 있다. $||\\vec{v}|| = \\sqrt{x^2 + y^2}$ 단위 벡터(Unit Vector) 크기가 1인 벡터. $\\hat{v} = \\frac{\\vec{v}}{||\\vec{v}||}$ 정규화(Normalize)한다. 임의의 벡터를 크기가 1인 단위 벡터로 다듬는 작업. 벡터의 결합과 생성 선형 결합(Linear combination) 벡터의 합과 스칼라배는 선형성이 있어서 선형 연산이라고도 한다. 이런 선형연산을 사용해서 $n$개의 스칼라 $a_1, \u0026hellip;, a_n$과 $n$개의 벡터 $\\vec{v_1}, \u0026hellip;, \\vec{v_n}$을 결합해 새로운 벡터 $\\vec{v\u0026rsquo;}$를 생성하는 수식을 선형 결합이라고 한다. $a_1\\vec{v_1} + a_2\\vec{v_2} + \u0026hellip; + a_n\\vec{v_n} = \\vec{v_n}$ 선형 종속 선형 결합에서 모든 $a$가 $0$이 아님에도 영벡터를 만들 수 있는 것. $2 \\cdot (1, 1) + (-1) \\cdot (2, 2) = (0, 0)$ 선형 독립 선형 결합에서 모든 $a$가 $0$이어야만 영벡터를 만들 수 있는 것. $0 \\cdot (1, 2) + 0 \\cdot (2, 1) = (0, 0)$ 선형 독립 관계를 가지는 벡터를 선형 결합하면, 벡터 공간에 속한 모든 벡터를 생성할 수 있다. 평면에서 선형 독립 관계를 유지하려면 2개의 벡터만 사용되어야 한다. 기저(Basis) 벡터 공간 내 모든 벡터를 생성할 수 있는, 선형 독립 관계를 가지는 벡터의 집합. 기저벡터(Basis vector) 기저에 속한 원소. 차원(Dimension) 평면에서 선형 독립 관계를 유지하려면 2개의 벡터만 사용되어야 한다. 기저 집합의 원소 수는 언제나 2개 뿐이다. 따라서 평면에 대응하는 벡터 공간을 2차원으로 정의할 수 있게 된다. 표준기저(Standard basis) 한 축만 사용하는 단위벡터로 구성된 집합. 표준기저벡터(Standard basis vector) 표준기저의 원소. 2차원 실벡터 공간 $\\mathbb{R}^2$ $e_1 = (1, 0)$ $e_2 = (0, 1)$ 3차원 실벡터 공간 $\\mathbb{R}^3$ $e_1 = (1, 0, 0)$ $e_2 = (0, 1, 0)$ $e_3 = (0, 0, 1)$ ","date":"2022-04-20T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-03/","title":"[Game Math] Chapter 3. 벡터: 가상 공간의 탄생"},{"content":" 이득우의 게임 수학 책을 읽고 공부한 노트입니다.\n수와 집합 수의 체계 기호 분류 정의 $\\mathbb{N}$ 자연수 1, 2, \u0026hellip; $\\mathbb{Z}$ 정수 \u0026hellip;, -2, -1, 0, 1, 2, \u0026hellip; $\\mathbb{Q}$ 유리수 분수로 나타낼 수 있는 수의 집합 $\\mathbb{I}$ 무리수 분수로 나타낼 수 없는 수의 집합 $\\mathbb{R}$ 실수 유리수와 무리수를 포함하는 수의 집합 $\\mathbb{C}$ 복소수 실수와 허수를 포함하는 수의 집합 $\\mathbb{H}$ 사원수 $a + bi + cj + dk$ $(i, j, k는 허수)$ 형태로 표현하는 수의 집합 이항연산의 특징 닫혀 있다(Closure) 같은 집합에 속한 두 수를 투입한 이항연산의 결과가 항상 투입한 집합에 속한다면, 그 이항연산은 해당 집합에 닫혀 있다고 한다. 교환법칙(Commutative law) 결합볍칙(Associative law) 분배법칙(Distributive law) 항등원(Identity) 어떤 수와 항등원과의 연산결과는 늘 그 어떤 수이다. 덧셈의 항등원: $a + 0 = a$ 곱셈의 항등원: $a \\cdot 1 = a$ 역원(Inverse) 어떤 수와 역원과의 연산결과는 늘 그 어떤 수의 항등원이다. 덧셈의 역원: $a + (-a) = 0$ (부호가 반대인 수, 반대수(Opposite number)) 곱셈의 역원: $a \\cdot \\frac{1}{a} = 1$ (역수(Reciprocal)) 체의 구조 공리(Axiom) 명제 중에서 증명할 필요가 없는 기본 명제 체(Field)의 구조를 지닌다. 공리적 집합론에서 두 연산에 대해 다음과 같은 공리를 모두 만족하는 수 집합. 따라서 체는 사칙연산이 자유로이 시행될 수 있는 수의 구조이다. 덧셈 연산에 대해 (1) 닫혀있다. (2) 덧셈 항등원($0$)이 존재한다. (3) 모든 성분에 대해 덧셈 역원이 존재한다. (4) 모든 성분에 대해 결합볍칙이 성립한다. (5) 모든 성분에 대해 교환법칙이 성립한다. 곱셈 연산에 대해 (6) 닫혀있다. (7) 곱셈 항등원이 존재한다. (8) $0$ 이외의 모든 성분에 대해 곱셈 역원이 존재한다. (9) $0$ 이외의 모든 성분에 대해 결합법칙이 성립한다. (10) $0$ 이외의 모든 성분에 대해 교환법칙이 성립한다. 덧셈과 곱셈 연산에 대해 (11) 덧셈에 대한 곱셈 연산의 분배법칙이 성립한다. 뺄셈과 나눗셈의 경우에는\u0026hellip; 뺄셈 대신 덧셈의 역원을 사용하고: $a + (-b) = (-b) + a$ 나눗셈 대신 곱셈의 역원을 사용하면 된다: $a \\cdot \\frac{1}{b} = \\frac{1}{b} \\cdot a$ 체의 구조를 만족하는 수집합은 유리수, 실수가 있다. 이 중에서 완벽한 연속성을 가지는 실수를 가지고 수직선 상에서 수를 표현할 수 있겠다. 방향: 부호 크기: 절대값 (원점으로부터의 거리) 함수 $f: X \\rightarrow Y$\n함수의 조건 (1) 첫 번째 집합의 모든 원소에 대한 대응 관계가 존재해야한다. (2) 첫 번째 집합의 원소는 두 번째 집합의 한 원소에만 대응되어야 한다. 함수 용어 정의역(Domain) 함수에서 왼쪽에 위치한 첫 번째 집합. ($X$) 공역(Codomain) 함수에서 오른쪽에 위치한 두 번째 집합. ($Y$) 치역(Range) 정의역에 대응되는 공역의 원소만 따로 모든 부분집합. 함수 종류 전사함수(Surjection) 공역의 모든 요소가 정의역에 대응되는 함수. 단사함수(Injection) 정의역과 공역의 요소가 1대1로 대응되는 함수. 전단사함수(Bijection) 정의역과 공역의 모든 요소가 빠짐없이 1대1로 대응되는 함수. 함수의 합성 함수의 합성(Function composition) $f: X \\rightarrow Y$ $g: Y \\rightarrow Z$ 2개의 함수를 연쇄적으로 이어서 하나의 함수로 만드는 연산이다. $g \\circ f$ 혹은 $g(f(x))$로 표시한다. 먼저 실행되는 함수 $f$ 가 기호 $\\circ$ 의 오른쪽에 놓인다는 점에 유의하자. 합성 함수는 결합법칙이 성립한다. 항등함수와 역함수 항등함수(Identity function) 정의역과 공역이 동일한 값으로 대응되는 함수로 $id$ 로 나타낸다. 어느 위치에 있던 동일한 대응 관계를 나타낸다. $id \\circ f = f$, $ f \\circ id = f$ 역함수(Inverse function) 역함수와의 합성 함수의 대응 결과는 항등함수가 된다. $f^{-1}$ 로 나타낸다. 공역 $Y$ 에서 정의역 $X$로 대응되는 함수로도 생각할 수 있다. $f^{-1} \\circ f = id$, $f \\circ f^{-1} = id$ 모든 함수가 역함수를 갖지는 않는다. 역함수를 가지려면 반드시 전단사함수의 형태가 되어야 한다. 곱집합 곱집합(Catesian product) $A \\times B$ 두 집합의 원소를 순서쌍으로 묶은 원소의 집합. 곱집합의 요소는 순서쌍으로 묶어서 표현한다. $(a, b)$ 서로 수직으로 배치하는 곱집합의 성질을 응용하면, 하나의 직선으로 표현한 실수 집합을 확장해서, 두 실수 집합의 곱집합을 평면으로 나타낼 수 있다. ","date":"2022-04-20T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/game-math-02/","title":"[Game Math] Chapter 2. 수: 가상 세계를 구성하는 가장 작은 단위"},{"content":" C, C++의 경우 C, C++에서는 프로그래머가 수동으로 Heap 영역의 해제를 관리해주어야 한다. 또한 Heap에 객체를 할당하기 위해 비싼 비용을 치루어야한다. C, C++기반의 프로그램을 실행하는 C-런타임은 메모리를 여러 블록으로 나눈 뒤 이 블록들을 링크드 리스트로 묶어서 관리 한다. 따라서 객체를 메모리에 할당하기 위한 코드가 실행되면, 링크드 리스트를 순차적으로 탐색하면서 여유 있는 블록을 찾고, 찾으면 블록을 쪼개서 객체를 할당하고 링크드 리스트를 재조정한다. 따라서 단순히 객체 할당을 하는 것이 아니라 오버헤드가 발생한다. C#의 경우 C#은 CLR이 자동으로 메모리를 관리 해준다. 관리형 코드 C#으로 작성된 모든 코드는 CLR에 의해 관리된다. CLR은 메모리 할당, 보안, 스레딩, 쓰레기 수거 등의 업무를 한다. 비관리형 코드 unsafe 키워드를 이용하면 CLR이 제공하는 서비스를 받을 수 없다. CLR은 객체 할당이 전부이다. C-런타임처럼 메모리를 쪼개지 않고 메모리 공간을 통째로 확보해서 하나의 관리되는 힙(Managed Heap)을 마련한다. 그리고 다음 객체를 할당할 주소를 가리키는 포인터를 옮겨가면서 순서대로 객체를 할당한다. C#의 메모리 할당 방식은 C, C++과 달리 리스트를 탐색하거나 재조정하는 과정이 불필요하기 때문에 속도가 훨씬 빠르다. CLR이 메모리를 관리하는 방법 참조형식의 객체가 할당될 때는 스택영역에 힙의 메모리 주소(a)가, 힙 영역에 실제 값(A)이 할당된다. (a)처럼 할당된 메모리의 위치를 참조하고 있는 객체를 일컬어 루트(Root) 라고 부른다. 루트는 스택에 생성될 수도 있고, 정적 필드처럼 힙에 생성될 수도 있다. .NET 애플리케이션이 실행되면 JIT 컴파일러는 루트들을 목록으로 만들고, CLR이 이 루트 목록을 관리하며 상태를 갱신한다. 가비지 컬렉터는 이 루트 목록을 참조해서 쓰레기 수집을 한다. 여기서 만약에 스택 영역의 메모리가 회수되면 힙 영역 값이 쓰레기가 된다. 가비지 컬렉터 동작 순서 가비지 컬렉터는 힙 영역의 임계치에 다다르면 이 루트 목록을 참조해서 쓰레기를 수집한다. 모든 객체가 쓰레기라고 가정한다. 루트 목록을 순회하면서 참조하고 있는 힙 객체와 관계 여부를 조사한다. 어떤 루트와도 관계가 없다면 쓰레기로 간주한다. 쓰레기가 차지하고 있던 메모리를 회수하고 인접 객체들을 이동시켜서 차곡차곡 채워서 정리(Memory Compaction)한다. 세대별 가비지 컬렉션 CLR의 메모리는 구역을 나눠서 관리한다. 0세대, 1세대, 2세대로 분리하여서 0세대는 빨리 사라질 객체, 2세대는 오래 남아있을 객체를 위치시킨다. 프로그램을 실행하면 0세대부터 할당된 객체들이 차오르기 시작한다. 0세대 가비지 컬렉션 임계치에 도달하면 0세대에 대해 가비지 컬렉션을 수행한다. 여기서 살아남은 객체는 1세대로 옮겨진다. 1번 과정을 반복하다보면, 1세대 가비지 컬렉션이 임계치에 도달하게 되고, 1세대에 대해 가비지 컬렉션을 수행한다. 여기서 살아남은 객체는 2세대로 옮겨진다. 2번 과정도 반복하다보면, 2세대 가비지 컬렉션이 임계치에 도달하게 되고, 이 때에는 0, 1, 2세대 전체 가비지 컬렉션을 수행한다. 2세대 힙이 가득차게 되면 CLR은 응용 프로그램의 실행을 멈추고 전체 가비지 컬렉션을 수행(Full GC) 하면서 메모리를 확보하려고 하기 때문에, 응용 프로그램이 차지하는 메모리가 많을 수록 프로그램이 정지하는 시간도 그 만큼 늘어나게 된다. 85KB이상의 대형 객체의 할당 대형 객체의 경우에는 0세대에 할당하면 가비지 컬렉션을 자주 수행하기 때문에 CLR은 85KB 이상의 대형 객체를 할당하기 위해 대형 객체 힙(Large Object Heap; LOH) 을 따로 유지하고 있다. 대형 객체가 할당될 때는 포인터를 사용하지 않고, 힙을 탐색하며 그 크기만큼 들어갈 수 있는 위치를 찾는다. 대형 객체 힙은 해제된 공간을 인접 객체를 이동시켜서 채우는 것이 아니라 그대로 둔다. 왜냐하면 복사하여 옮기는 비용이 너무 비싸기 때문이다. 이렇기 때문에 큰 공간 사이사이의 메모리를 낭비하게 된다. CLR은 대형 객체 힙을 2세대 힙으로 간주한다. 따라서 대형 객체 힙에 있는 쓰레기 객체가 수거되려면 2세대 가비지 컬렉션이 수행되어야 한다. 2세대 가비지 컬렉션은 전 세대에 대한 가비지 컬렉션을 유발하기 때문에 수거되는 메모리의 양이 클수록 어플리케이션이 정지되는 경우가 발생하게된다. 가비지 컬렉션 메서드 메서드명 설명 GC.Collect() 모든 세대 GC 즉시 수행 GC.Collect(int) 세대 0에서 부터 지정된 세대까지 GC 즉시 수해 GC.CollectionCount(int) 지정된 세대의 개체에 대해 GC가 수행된 횟수 반환 (GC가 언제 발생하는지 모니터링하는 가장 쉬운 방법) GC.GetGerneration(object) obj의 현재 세대 반환 GC.MaxGeneration() 시스템에서 현재 지원하는 가장 큰 세대 번호 반환 (시스템에 따라 0~n세대로 나누어 질 수 있음) 주의점 객체를 너무 많이 할당하지 않는다. 너무 큰 객체를 할당하는 것을 피한다. 너무 복잡한 참조관계를 피한다. 복잡한 참조 관계를 가진 객체가 가비지 컬렉션 후에 살아 남으면, 세대를 옮기기 위해 메모리 복사를 진행하는데, 참조 관계가 복잡할 경우 객체를 구성하고 있는 각 필드 객체간의 참조관계를 조사하여 메모리 주소를 전부 수정해야 되기 때문에 탐색과 수정의 오버헤드가 발생한다. 또한 A객체가 2세대인데 A객체안에 B객체를 이제 막 생성하여 0세대로 되었다면, A의 인스턴스는 2세대에 있고 B 필드를 참조하는 메모리는 0세대에 위치하게 된다. 이때 0세대 가비지 컬렉션이 수행된다면 B필드가 수거될 수 있다. 하지만 CLR은 쓰기 장벽(Write barrier) 이라는 장치를 통해서 B필드가 루트를 갖고 있는 것으로 간주하게 해서 수거 되지 못하게 한다. 이 쓰기 장벽을 생성하는 데 오버헤드가 크다는 것이 문제가 된다. 루트를 너무 많이 만들지 않는다. 가비지 컬렉터는 루트 목록을 순회하면서 쓰레기를 찾아낸다. 루트 목록이 작아진다면 그만큼 가비지 컬렉터가 검사를 수행하는 횟수가 줄어들므로 더 빨리 가비지 컬렉션을 끝낼 수 있다. Unity의 경우 Boehm-Demers-Weiser의 알고리즘 이것은 가비지콜렉터가 가비지 수집을 수행할때 프로그램 코드 실행 및 CPU 메인스레드를 중지하며 전체 힙을 검사하는 방식이다. (Stop the world 방식) 따라서 힙의 모든 오브젝트를 처리한 이후에 어플리케이션 실행을 재개함으로 성능에 영향을 미치는 GC Spike(중단으로 인해 프로파일러 윈도우의 그래프에서 나타나는 큰 스파이크)가 발생한다. 더 이상 할당할 수 있는 메모리가 없다면 Managed Heap의 크기를 2배로 늘린다. 줄어들지는 않는다. 세대 구분이나 SOH, LOH, 메모리 압축같은 것이 없다. Incremental GC 부하가 있는 GC를 점진적으로 수행하는 방법이다. 즉, 하나의 작업을 여러 프레임 동안 나눠서 하는 것이다. GC에 드는 시간 총량이 줄어들지는 않지만 워크로드 분산으로 GC Spike 문제점을 개선시킬 수 있다. 유니티 공식 문서\nms 공식 문서\n가비지 컬렉션과 string string 문자열은 변경할 수 없는 객체이다. 그래서 변경하면 내부적으로 항상 새로운 문자열이 만들어진다. 1 2 3 4 // string + string의 경우 string str = \u0026#34;one\u0026#34;; str += \u0026#34;two\u0026#34;; // 새로운 객체를 만들고, str이 이것을 참조하도록 한다. 대안 : StringBuilder 클래스를 사용해보자. string 과 달리 변경 가능한 객체이다. StringBuilder 클래스는 연결될 새 데이터를 수용할 버퍼를 유지한다. 만약 용량을 초과하면 새 공간이 자동으로 할당되고 용량이 두 배로 증가한다. 1 2 3 4 // StringBuilder의 경우 StringBuilder sb = new StringBuilder(\u0026#34;one\u0026#34;); sb.Append(\u0026#34;two\u0026#34;); ","date":"2022-04-19T05:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/c-sharp-05/","title":"[C#] 가비지 컬렉션"},{"content":" 컬렉션이란? C#에서 지원하는 자료구조 클래스이다. C++의 컨테이너와 비슷하다. 컬렉션은 제네릭(Generic) 과 논제네릭(Non-Generic) 으로 나뉜다. 논제네릭은 object 형식을 사용해서 데이터를 관리하기 때문에 박싱과 언박싱이 잦아 성능 문제가 있어서 제네릭 컬렉션을 사용한다. 특징 Generic Non-Generic 인덱스 List\u0026lt;T\u0026gt; Array, ArrayList 키 - 값 쌍 Dictionary\u0026lt;TKey,TValue\u0026gt; Hashtable FIFO Queue\u0026lt;T\u0026gt; Queue LIFO Stack\u0026lt;T\u0026gt; Stack 순서대로 엑세스 LinkedList\u0026lt;T\u0026gt; 정렬된 컬렉션 SortedList\u0026lt;TKey,TValue\u0026gt; SortedList 수학함수용 집합 HashSet\u0026lt;T\u0026gt; 불변성과 가변성 불변성(Invariance) 변경할 수 없는. 인스턴스가 생성된 후 값을 변경할 수 없는 타입이다. 예: string 가변성(Variance) 변경할 수 있는. 인스턴스가 생성된 후 값이 변경될 수 있는 타입이다. 예: StringBuilder 여기서는 제네릭의 가변성을 살펴본다. 가변성은 암묵적으로 레퍼런스를 변환할 수 있는 능력이므로, Value Type에는 사용할 수 없고, Reference Type에만 적용된다. 타입 T 파라미터를 \u0026lt;out T\u0026gt;로 사용하면 공변성이 되고, \u0026lt;in T\u0026gt;로 사용하면 반공변성이 되며, in이나 out 없이 \u0026lt;T\u0026gt;로 사용하면 불변성이 된다. 공변성을 지원하는 타입 IEnumerable\u0026lt;out T\u0026gt;, IEnumerator\u0026lt;out T\u0026gt;, IQueryable\u0026lt;out T\u0026gt;, Func\u0026lt;out T\u0026gt; 등 반공변성을 지원하는 타입 IComparer\u0026lt;in T\u0026gt;, IComparable\u0026lt;in T\u0026gt;, IEqualityComparer\u0026lt;in T\u0026gt;, Action\u0026lt;in T\u0026gt; 등 속성 특징 파라미터 불변성 동일 타입만 할당 가능 \u0026lt;T\u0026gt; 가변성 - 공변성(Covariance) 상위 타입 할당 가능 \u0026lt;out T\u0026gt; 가변성 - 반공변성(Contravariance) 하위 타입 할당 가능 \u0026lt;in T\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Animal { public int Age { get; set; } public void Move() { } } class Dog : Animal { public void Bark() { } } class K9 : Dog { public void FindDrug() { } } // 제네릭 인터페이스: Covariance interface ICreate\u0026lt;out T\u0026gt; { T Create(); } class DogFactory : ICreate\u0026lt;Dog\u0026gt; { public Dog Create() { return new Dog(); } } // 제네릭 인터페이스: Contravariance interface ITest\u0026lt;in T\u0026gt; { void Run(T t); } class AnimalTest : ITest\u0026lt;Animal\u0026gt; { public void Run(Animal t) { t.Move(); } } class Main { public void Run() { ICreate\u0026lt;Animal\u0026gt; creator = (ICreate\u0026lt;Dog\u0026gt;)new DogFactory(); Animal ani = creator.Create(); ani.Move(); ITest\u0026lt;Dog\u0026gt; d = (ITest\u0026lt;Animal\u0026gt;)new AnimalTest(); d.Run(new Dog()); d.Run(new K9()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class AnimalComparer : IComparer\u0026lt;Animal\u0026gt; { int IComparer\u0026lt;Animal\u0026gt;.Compare(Animal a, Animal b) { if (a == null) return b == null ? 0 : -1; return b == null ? 1 : a.Age.CompareTo(b.Age); } } class Main { public void Run() { // covariance IEnumerable\u0026lt;Animal\u0026gt; animals = new List\u0026lt;Dog\u0026gt;() { new Dog() }; animals.GetEnumerator().Current.Move(); // contravariance IComparer\u0026lt;Dog\u0026gt; dogComparer = new AnimalComparer(); Dog dogA = new Dog { Age = 10 }; Dog dogB = new Dog { Age = 10 }; int result = dogComparer.Compare(dogA, dogB); } } List\u0026lt;T\u0026gt; 내부적으로는 배열을 사용한다. 현재 크기의 2배로 늘리면서 재할당한다. 메모리가 순차적으로 할당이 된다. 그래서 불연속적인 메모리 할당 보다는 순차 접근이 빠르다. (캐시에 참조 지역성의 원리에 따라서 저장이 함께 되므로) 대신 인덱스로 접근하기 때문에 임의 접근은 빠르다. 중간에 삽입, 삭제가 효율적이지 않다. 원소들을 한칸씩 옮겨야 하기 때문이다. 그 과정에서 사본을 생성해야 하는 일도 발생한다. 메서드 기능 Add(T) 개체를 끝부분에 추가한다. AddRang(IEnumerable\\\u0026lt;T\\\u0026gt;) 개체들을 끝부분에 추가한다. Insert(Int32, T) 개체를 지정된 인덱스에 추가한다. Remove(T) 처음 발견되는 해당 개체를 삭제한다. RemoveAll(Predicate\\\u0026lt;T\\\u0026gt;) 해당 조건을 만족하는 개체들을 모두 삭제한다. Clear() 개체들을 모두 제거한다. Contains(T) 개체를 포함하고 있는지 확인한다. IndexOf(T) 개체의 인덱스를 반환한다. 없으면 -1을 반환한다. Sort() 개체들을 오름차순 혹은 내림차순으로 정렬한다. Reverse() 개체들을 현재 상대의 반대로 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 List\u0026lt;int\u0026gt; l = new List\u0026lt;int\u0026gt; { 1, 3, 2 }; l.Reverse(); // 2 3 1 l.Add(3); // 2 3 1 3 l.AddRange(new List\u0026lt;int\u0026gt; {6, 7, 8}); // 2 3 1 3 6 7 8 l.Remove(1); // 2 3 3 6 7 8 l.RemoveAll(x =\u0026gt; x == 3); // 2 6 7 8 bool res = l.Contains(9); // true int idx = l.IndexOf(7); // 2 LinkedList\u0026lt;T\u0026gt; 이중 연결리스트로 구현되어 있다. 포인터만 변경하면 되므로 중간 삽입, 삭제가 시간복잡도 1만에 이루어진다. 임의접근이 안 되기 때문에 처음부터 순차적으로 살펴봐야 한다. 메서드 기능 AddFirst(T) 개체를 리스트의 맨 앞에 추가한다. AddLast(T) 개체를 리스트의 맨 뒤에 추가한다. AddBefore(LinkedListNode\\\u0026lt;T\\\u0026gt;, LinkedListNode\\\u0026lt;T\\\u0026gt;) 개체를 해당 인덱스 위치 앞에 추가한다. AddAfter(LinkedListNode\\\u0026lt;T\\\u0026gt;, LinkedListNode\\\u0026lt;T\\\u0026gt;) 개체를 해당 인덱스 위치 다음에 추가한다. Remove(T) 처음 발견되는 해당 개체를 삭제한다. RemoveFirst() 맨 앞의 개체를 제거한다. RemoveLast() 맨 뒤의 개체를 제거한다. Clear() 개체들을 모두 제거한다. Contains(T) 개체를 포함하고 있는지 확인한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int[] input = new[] { 1 }; LinkedList\u0026lt;int\u0026gt; ll = new LinkedList\u0026lt;int\u0026gt; (input); ll.AddFirst(0); // 0, 1 ll.AddLast(4); // 0, 1, 4 ll.AddAfter(ll.Find(1), new LinkedListNode\u0026lt;int\u0026gt;(3)); // 0, 1, 3, 4 ll.AddBefore(ll.Find(3), new LinkedListNode\u0026lt;int\u0026gt;(2)); // 0, 1, 2, 3, 4 ll.Remove(3); // 0, 1, 2, 4 ll.RemoveFirst(); // 1, 2, 4 ll.RemoveLast(); // 1, 2 bool res = ll.Contains(1); // true LinkedListNode\u0026lt;int\u0026gt; node = ll.First; for (int i = 0; i \u0026lt; ll.Count; i++) { Console.Write(node.Value + \u0026#34; \u0026#34;); // 1, 2 node = node.Next; } Dictionary\u0026lt;TKey, TValue\u0026gt; 인덱스 번호가 아닌, 키를 사용해서 값을 얻는다. 메서드 기능 Add(TKey, TValue) 개체를 추가한다. Remove(TKey) 지정된 키를 가진 개체를 삭제한다. Remove(TKey, TValue) 지정된 키를 가진 개체를 삭제하고, 두번째 필드에 값을 저장한다. Clear() 개체들을 모두 제거한다. ContainsKey(TKey) 키를 포함하고 있는지 확인한다. ContainsValue(TValue) 값을 포함하고 있는지 확인한다. Reverse() 개체들을 현재 상대의 반대로 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 Dictionary\u0026lt;int, string\u0026gt; d = new Dictionary\u0026lt;int, string\u0026gt; { { 1, \u0026#34;First\u0026#34; }, { 2, \u0026#34;Second\u0026#34; }, { 3, \u0026#34;Third\u0026#34;} }; d.Add(4, \u0026#34;Forth\u0026#34;); // First, Second, Third, Forth d.Remove(1); // Second, Third, Forth d.Remove(2, out var deletedThis); // Third, Forth | deletedThis = Second d[4] = \u0026#34;Fifth\u0026#34;; // Third, Fifth bool resKey = d.ContainsKey(1); // false bool resVal = d.ContainsValue(\u0026#34;Fifth\u0026#34;); // true References https://blog.naver.com/PostView.nhn?blogId=tutorials_korea\u0026logNo=221610337593\u0026redirect=Dlog\u0026widgetTypeCall=true\u0026directAccess=false https://www.csharpstudy.com/DevNote/Article/31 ","date":"2022-04-19T04:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/c-sharp-04/","title":"[C#] 컬렉션"},{"content":" virtual table 한 클래스가 해당 클래스 or 상위 클래스에서 virtual 메서드를 갖는다면, 해당 클래스의 Method Table 메타데이터 내에 Virtual Table을 갖게 된다. C#은 모든 클래스가 System.Object 의 상속을 받으므로 모든 클래스가 Virtual Table을 갖다고 볼 수 있겠다. 4개의 가상메서드(ToString(), Equals(), GetHashCode(), Finalize())를 자신의 Virtual Table안에 갖게 된다. 해당 클래스의 메서드는 virtual이 아니어도 모두 데이블에 추가된다. override : virtual 메서드 동작원리 부모클래스의 virtual 메서드를 자식클래스에서 override하면 (1) 자식클래스의 Virtual Table에 있는 부모 클래스의 가상 메서드 슬롯에, 자식클래스의 override 메서드의 포인터를 집어 넣고, (2) 별도의 파생클래스 메서드 슬롯을 새로 만들지 않는다. 그래서 누군가 타입 A로 메서드를 요구하면, 부모클래스 A의 가상 메서드 슬롯에 이미 overriding된 가상 메서드 포인터를 리턴하고, 타입 B로 메서드를 요구하면, 파생클래스 메서드 슬롯에는 해당 메서드가 없으니 부모클래스의 가상메서드를 리턴하는데, 실제 그곳에는 overriding된 가상 메서드 포인터가 있어서 그것을 리턴하는 것이다. new : 메서드 hiding 동작원리 (new 키워드가 없어도 동일한 효과를 낸다.) 자식클래스에서 override를 쓰지 않고 부모클래스와 동일한 메서드명을 사용하면, 자식클래스에서는 부모클래스의 메서드를 더이상 사용할 수 없게 된다는 것이다. 부모클래스의 가상 메서드 슬롯에 override 되지 않고, 자식 클래스의 메서드 슬롯에 해당 메서드가 새로 추가된다. 따라서 타입 A로 호출하면 A의 메서드를 호출하고, 타입 B로 호출하면 B의 메서드를 호출한다. 생성자와 virtual 메서드 virtual 메서드를 생성자에서 부르면 어떻게 될까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Mother { public Mother() { DoSomething(); } public virtual void DoSomething() { Console.Write(\u0026#34;Mother \u0026#34;); } } public class Child : Mother { public Child() { DoSomething(); } public override void DoSomething() { Console.Write(\u0026#34;Child \u0026#34;); } } class Main { public void Run() { Mother m = new Mother(); // Mother Child c = new Child(); // Child Child Mother mc = new Child(); // Child Child } } 자식 클래스의 생성자 내부 코드가 먼저일까, 부모 클래스의 생성자 호출이 먼저일까? 결론: 생성자에서는 가상함수를 호출하면 안 된다! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Base { // (4) 부모 클래스의 생성자 호출 protected Base() { // (5) 가상 함수 호출 VFunc(); // 무엇이 출력될까? 정답은 Set by initializer! // 만약 VFunc()가 abstract 메서드라면 -\u0026gt; 똑같이 Set by initializer! } protected virtual void VFunc() { Console.WriteLine(\u0026#34;VFunc in Base\u0026#34;); } } class Derived : Base { // (3) Derived의 멤버 초기화 readonly string msg = \u0026#34;Set by initializer\u0026#34;; // (2) Derived 생성자 호출 public Derived(string msg) { // (마지막) 생성이 완료된 후에 생성자의 스코프 안으로 진입 this.msg = msg; } // (6) 가상 함수 실행 protected override void VFunc() { Console.WriteLine(msg); } } class Main { public void Run() { // (1) Derived 객체 생성 var d = new Derived(\u0026#34;Constructed in main\u0026#34;); } } 혹시 C++은 어떨까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; class Base { protected: // (3) 부모 클래스의 생성자 호출 Base() { // (4) 가상 함수 호출 VFunc(); // 무엇이 출력될까? 정답은 VFunc in Base! // 만약 VFunc()가 순수 가상 함수라면 -\u0026gt; 컴파일 에러가 발생한다! } // (5) 가상 함수 실행 virtual void VFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;VFunc in Base\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { private: // (6) Derived의 멤버 초기화 std::string msg = \u0026#34;Set by initializer\u0026#34;; public: // (2) Derived 생성자 호출 Derived(const std::string\u0026amp; msg) { // (마지막) 생성이 완료된 후에 생성자의 스코프 안으로 진입 this-\u0026gt;msg = msg; } protected: virtual void VFunc() override { std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; int main() { // (1) Derived 객체 생성 auto* d = new Derived(\u0026#34;Constructed in main\u0026#34;); } References https://www.csharpstudy.com/DevNote/Article/28 https://blog.naver.com/bluekms21/222324955246 ","date":"2022-04-19T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/c-sharp-03/","title":"[C#] virtual 메서드"},{"content":" 프로그램을 실행하면 4개의 힙이 생긴다. 이름 설명 Process Heap JIT Code Heap 모든 메서드는 호출시에 JIT 컴파일되며 그 결과(native code)는 프로그램의 \u0026lsquo;데이타가 저장되는 Managed Heap\u0026rsquo;과 전혀 다른 JIT Code Heap 영역에 저장된다. JIT 컴파일된 코드 영역은 (비록 메모리가 모자라 Paging을 할 수는 있으나) Code Heap에서 프로그램이 종료될 때까지(좀 더 정확히 AppDomain이 종료될 때까지) Clear되지 않는다. 이 영역은 GC가 관리하지 않는 영역이며, 관리할 수 없는 영역이다. Small Object Heap GC가 관리하는 Managed Heap, 클래스의 필드들이 담긴다. Large Object Heap GC가 관리하는 Managed Heap, 클래스의 필드들이 담긴다. 클래스의 객체를 생성하면 다음과 같은 구조가 Managed Heap에 생긴다. 구성요소 설명 Object Header SyncBlock의 인덱스 값을 가진다. 여기에는 객체의 lock, 해쉬값, Thunking 데이터, AppDomain 정보를 담고있다. 필요하지 않은 경우 경우 기본적으로 0을 할당한다. Type Handle Method Table을 가리키는 포인터이다. 객체 필드들 부모 클래스의 필드들이 먼저 공간을 차지하고, 자식클래스의 필드들이 그 뒤에 추가된다. 객체의 메모리 레이아웃 CLR은 기본적으로 Optimiazation의 일환으로 클래스 필드의 순서를 자동으로 변경하는데 이것을 Auto Layout이라 부른다. Auto Layout은 Managed Memory 상에서 클래스 필드의 순서를 자동으로 재배치한다. class와 같은 참조 타입은 디폴트로 Auto Layout을 사용한다. struct와 같은 값 타입은 디폴트로 Squential Layout을 사용한다. [StructLayout(LayoutKind.Explicit, Pack = 1)] 과 같이 사용해서 Managed Memory 상에서 필드에 저장된 [FieldOffset()] 속성에 따라 메모리 위치가 설정된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 [StructLayout(LayoutKind.Explicit, Pack = 1)] class MyClass { [FieldOffset(0)] public int i; [FieldOffset(4)] public double d; [FieldOffset(12)] public byte b; } // MyClass 라는 클래스에 Explicit 레이아웃을 사용하여 // 필드 i 가 처음에, 필드 d가 4번째 바이트 위치에, 필드 b가 12번째에 각각 위치하게 됨을 지정하고 있다. struct는 값형식, class는 참조형식 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Employee { public string Name { get; set; } public int Salary { get; set; } } class HR { public void RaiseSalary(Employee emp) { emp.Salary = emp.Salary + 1000; // struct는 값형식이므로 여기서 올린 Salary는 // 복제본의 Salary이다. // 따라서 원본이 변하지는 않는다. } } class Main { public void Run() { Employee emp = new Employee(); emp.Name = \u0026#34;Lee\u0026#34;; emp.Salary = 9000; HR hr = new HR(); Console.WriteLine(emp.Salary); // 인상전 9000 hr.RaiseSalary(emp); Console.WriteLine(emp.Salary); // 인상후 9000 ??? } } interface를 상속받는 struct의 주의점 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public interface IAdd { void AddOne(); } struct MyValue : IAdd { int value; public int Value =\u0026gt; value; public MyValue(int value) { this.value = value; } public void AddOne() { value++; } } class Main { public void Run() { MyValue v1 = new MyValue(3); v1.AddOne(); Console.WriteLine(v1.Value); // 4. 좋다. MyValue v2 = new MyValue(3); IAdd itf = v2 as IAdd; itf.AddOne(); Console.WriteLine(v2.Value); // 3. ??? // struct는 값 형식이다. // 그래서 인터페이스로 박싱하면 (값 -\u0026gt; 참조) // 스택에 있던 값이 힙으로 복사되고, 힙에 있는 값이 증가된다. // 그래서 기존 스택의 값을 출력하면 그대로이다. } } method hiding에 대하여 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Animal { public void Eat(int kg) { Console.WriteLine(\u0026#34;Animal.Eat: {0} kg\u0026#34;, kg); } } class Dog : Animal { public void Eat(long kg) { Console.WriteLine(\u0026#34;Dog.Eat: {0} kg\u0026#34;, kg); } } class Bulldog : Dog { public void Eat(string kg) { Console.WriteLine(\u0026#34;Bulldog.Eat: {0} kg\u0026#34;, kg); } } class Main { public void Run() { Bulldog bulldog = new Bulldog(); int kg = 2; bulldog.Eat(kg); // Dog.Eat() 호출 ((Animal)bulldog).Eat(kg); // Animal.Eat() 호출 // 메서드 검색은 동일 메서드 명으로 // 동일 타입 or 호환 가능한 타입의 파라미터를 발견할 때까자 // 상위 클래스를 찾아 가면서 진행된다. // 그래서 일단 중간에 조건에 맞는 메서드를 발견하면 검색을 중지하고 // 해당 메서드를 사용한다. // 특정 메서드를 지정해서 호출하고 싶다면, // 해당 클래스로 캐스팅할 후 메서드를 호출하면 된다. } } ref를 클래스에 사용하는 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class DataSet { public List\u0026lt;DataTable\u0026gt; Tables = new List\u0026lt;DataTable\u0026gt;(); } class DataTable { public List\u0026lt;string\u0026gt; Columns = new List\u0026lt;string\u0026gt;(); } class Main { public void AddTable(DataSet ds) // ref로 해야 함. { DataSet newDs = new DataSet(); DataTable dt = new DataTable(); dt.Columns.Add(\u0026#34;ColA\u0026#34;); newDs.Tables.Add(dt); ds = newDs; // ds 내부의 멤버를 변경할 순 있지만, // 다른 새로운 레퍼런스 객체를 할당할 순 없다. // 그래서 참조형식인 class도 ref를 사용해야 한다. } public void Run() { DataSet ds = new DataSet(); AddTable(ds); Console.WriteLine(ds.Tables.Count); // 0이 나온다. ??? } } References https://web.archive.org/web/20150515023057/https://msdn.microsoft.com/en-us/magazine/cc163791.aspx http://www.csharpstudy.com/DevNote/Article/5 http://www.csharpstudy.com/Mistake ","date":"2022-04-19T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/c-sharp-02/","title":"[C#] 객체와 메모리"},{"content":" C# 컴파일 과정 C# 코드를 빌드하면 CIL 이라는 중간 코드(Intermediate Language; 어셈블리 코드의 일종) 를 만들어 낸다. 프로그램 실행시 런타임에 CLR이 이 IL 코드를 읽어서 JIT 컴파일(Just In Time Compile; 적시 컴파일) 방식을 이용해서 Native 코드로 변경한다. JIT 컴파일이란, 매번 실행될 때마다 실시간으로 컴파일을 해서 실행한다는 의미이다. 장점 IL 방식의 가장 큰 장점은 실행 머신 환경 (32/64 bit, x86/AMD 등)에 관계없이 .Net Framework가 설치된 어떤 환경에서도 동일 코드를 실행할 수 있다는 것이다. 단점 IL 방식의 단점은 실행시 어쨌든 IL 코드를 컴파일해야 한다는 것인데, 이는 속도를 저하시키는 원인이 된다. .NET에서는 이러한 속도 저하를 최대한 줄이기 위해 프로그램 실행시 전체 IL 코드를 컴파일하는 것이 아니라 호출되는 메서드 단위로 컴파일을 진행한다. 즉 실행 중 어떤 메서드가 호출되면 그 메서드만 JIT 컴파일러가 Native로 변경하는 것이다. 따라서 만약 프로그램 실행 전 과정에서 어떤 메서드가 한번도 호출되지 않는다면 그 메서드는 Native 코드로 변경되지 않는다. 이 외에도 CLR은… 프로그램의 예외가 발생했을 때 이것을 처리하도록 도와준다. 언어 간의 상속을 지원한다. COM과의 상호 운영성을 지원한다. 자동 메모리 관리 기능인 가비지 컬렉션(Garbage Collection)을 제공한다. .NET Assembly 어셈블리란 버전 관리되고 배포되는 프로그램의 단위이다. 실행 파일(.exe) 또는 동적 연결 라이브러리(.dll) 파일의 형태를 가진다. 응용 프로그램 하나에서만 사용하는 전용 어셈블리와, 여러 프로그램에서 공유하는 공유 어셈블리가 있다. .NET 플랫폼에서는 한 덩어리의 실행 파일을 여러 개의 어셈블리 파일로 나눌 수 있다. 따라서 바이너리 파일이 하나인 어셈블리(단일 파일 어셈블리)가 될 수도 있고, 여러 바이너리 파일이 모여서 다중 파일 어셈블리가 될 수도 있다. 다중 파일 어셈블리에서, 컴파일 완료된 바이너리 파일의 각각을 모듈이라고 한다. 이때 어셈블리에 관한 정보를 가지고 있는 Manifest를 가진 모듈을 주모듈, 아닌 경우를 부모듈이라고 한다. 구성요소 설명 Manifest 어셈블리의 버전 요구 사항과 보안 ID를 지정하는 데 필요한 모든 메타데이터와 어셈블리의 범위를 정의한다. 리소스나 다른 모듈에 대한 참조를 확인하는 데 필요한 모든 메타데이터를 포함한다. 즉, 어셈블리 내의 모든 모듈의 참조 정보를 갖는 메타데이터이다. Type Metadata 어셈블리 내에서 사용되는 모든 타입에 대한 구체적인 정보를 가지고 있다. 이것 덕분에 리플렉션(객체의 클래스 타입, 메서드, 프로퍼티 등의 메타 정보를 런타임 중에 알아내는 기능)이 가능하다 CIL Code 공통 언어 기반과 닷넷 프레임워크에서 인간이 이해할 수 있는 가장 낮은 수준의 프로그래밍 언어이다. 객체 지향 어셈블리어이며, 완전한 스택기반이다. CLR이 런타임에 이 코드를 Native 코드로 변경한다. References https://docs.microsoft.com/ko-kr/dotnet/standard/assembly/ https://blog.shovelman.dev/634 https://rito15.github.io/posts/cs-dotnet-compile/ ","date":"2022-04-19T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/c-sharp-01/","title":"[C#] 컴파일 과정"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n프로세스와 스레드 프로세스(Process) 프로그램이 실행되어 메모리에 적재된 인스턴스이다. 스레드(Thread) 프로세스 내에서 실행되는 흐름의 단위이다. 운영체제가 CPU 시간을 할당하는 기본 단위이다. 멀티 스레드의 장점 응답성을 높일 수 있다. 자원 공유가 쉽다. 자원을 공유하므로 경제적이다. 멀티 스레드의 단점 구현이 까다롭다. 스레드를 너무 많이 사용하면 문맥교환이 잦아져서 오히려 성능이 더 저하된다. 스레드 시작하기 .NET은 스레드를 제어하는 System.Threading.Thread 클래스를 제공한다. Thread의 인스턴스를 생성한다. 인수로 실행할 메소드를 넘긴다. Thread.Start()메소드를 호출해서 스레드를 시작한다. Thread.Join()메소드를 호출해서 스레드가 끝날 때까지 기다린다. 스레드 임의로 종료시키기 Thread.Abort()메소드를 호출하면 즉시 종료되지는 않는다. CLR은 해당 스레드가 실행 중이던 코드에 ThreadAbortException을 던진다. 이 때 예외를 catch하는 코드가 있으면 처리한 다음 finally 블록까지 실행한 후에야 해당 스레드는 완전히 종료된다. 왠만하면 사용하지 않는 것이 좋다. 해당 스레드가 독점 자원을 잠근 후 종료되면, 그 자원은 해제되지 못하기 때문이다. 스레드의 상태 변화 .NET은 스레드의 상태를 ThreadState 열거형에 정의해두었다. 상태 설명 Unstarted 스레드 객체를 생성한 후 Thread.Start() 메소드가 호출되기 전의 상태이다. Running 스레드가 시작하여 동작 중인 상태이다. Unstarted에서 Thread.Start()하면 이 상태가 된다. Suspended 스레드의 일시 중단 상태이다. Thread.Suspend() 메소드를 통해 이 상태로 만들 수 있으며, Thread.Resume() 메소드를 통해 다시 Running 상태로 만들 수 있다. WaitSleepJoin 스레드가 블록(Block)된 상태이다. Monitor.Enter()나 Thread.Sleep()나 Thread.Join() 메소드를 호출하면 이 상태가 된다. Aborted 스레드가 취소된 상태이다. Thread.Abort() 메소드를 호출하면 이 상태가 된다. 이후 Stopped 상태로 전환되어 완전히 중지된다. Stopped 스레드가 중지된 상태이다. Thread.Abort() 메소드를 호출하거나 실행 중인 메소드가 종료되면 이 상태가 된다. Background 스레드가 백그라운드로 동작하고 있음을 나타낸다. 포어그라운드의 경우 스레드가 하나라도 살아 있으면 프로세스가 죽지 않는다. 반면 백그라운드의 경우 스레드가 살아 있는지와 관계없이 프로세스가 죽으면 스레드도 모두 죽는다. ThreadState 열거형은 Flags애트리뷰트를 갖고 있다. 따라서 이 열거형의 요소들의 집합으로 표현할 수 있다. 즉, 비트 필드(Bit field)로 처리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 [Flags] enum MyEnum { Apple = 1 \u0026lt;\u0026lt; 0, Orange = 1 \u0026lt;\u0026lt; 1, Kiwi = 1 \u0026lt;\u0026lt; 2, Mango = 1 \u0026lt;\u0026lt; 3, }; Console.WriteLine((MyEnum) 1); // Apple Console.WriteLine((MyEnum) (1 | 4)); // Apple, Kiwi // Flags 애트리뷰트를 갖고 있는 열거형은 요소의 집합으로 표현될 수 있다. 비트 연산을 통해 ThreadState 필드의 값을 확인할 수 있다. 상태 10진수 2진수 Running 0 000000000 StopRequested 1 000000001 SuspendRequested 2 000000010 Background 4 000000100 Unstarted 8 000001000 Stopped 16 000010000 WaitSleepJoin 32 000100000 Suspended 64 001000000 AbortRequested 128 010000000 Aborted 256 100000000 1 2 3 4 5 6 Thread th = new Thread(...); if ((th.ThreadState \u0026amp; ThreadState.Aborted) == ThreadState.Aborted) Console.WriteLine(\u0026#34;스레드가 정지했습니다.\u0026#34;); else if ((th.ThreadState \u0026amp; ThreadState.Stopped) == ThreadState.Stopped) Console.WriteLine(\u0026#34;스레드가 취소되었습니다.\u0026#34;); 인터럽트: 스레드를 임의로 종료하는 다른 방법 Thread.Interrupt()메소드 Thread.Abort()메소드는 강제로 종료하지만, Thread.Interrupt()메소드는 스레드가 동작중인 상태(Running 상태)를 피해서 WaitJoinSleep상태에 들어갔을 때 ThreadInterruptedException 예외를 던져서 스레드를 중지시킨다. 절대로 중단되면 안 되는 작업을 하고 있을 때는 중단되지 않는다는 보장을 받을 수 있다. 스레드 간의 동기화 동기화(Synchronization) 스레드의 자원에 대한 접근을 제어하는 방법이다. 스레드 동기화에서 가장 중요한 것은 자원을 한 번에 하나의 스레드가 사용하도록 보장하는 것이다. .NET은 lock 키워드와 Monitor 클래스를 제공한다. lock 키워드로 동기화하기\nlock 키워드로 코드 영역을 감싸주면 크리티컬 섹션으로 바꿀 수 있다. 한 스레드가 그 코드를 실행하고 마칠 때까지 다른 스레드는 그 코드 영역을 실행할 수 없다. lock 키원드의 매개변수로 사용하는 객체로 부적절한 것들이 있다. 외부 코드에서도 접근할 수 있는 것은 안 된다.\nthis Type 형식 typeof 연산자나 GetType()메소드는 피하자. string 형식 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Counter { const int LOOP_COUNT = 100; private readonly object thisLock; private int count; public int Count { get =\u0026gt; count; } public Counter() { thisLock = new object(); count = 0; } public void Increase() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { lock (thisLock) // 여기는 크리티컬 섹션이다 { count++; Console.WriteLine($\u0026#34;Increase: {count}\u0026#34;); } Thread.Sleep(1); } } public void Decrease() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { lock (thisLock) // 여기는 크리티컬 섹션이다 { count--; Console.WriteLine($\u0026#34;Decrease: {count}\u0026#34;); } Thread.Sleep(1); } } } class MainApp { static void Main(string[] args) { Counter counter = new Counter(); // 두 개의 스레드 Thread inc = new Thread(new ThreadStart(counter.Increase)); Thread dec = new Thread(new ThreadStart(counter.Decrease)); // 스레드 시작 inc.Start(); dec.Start(); // 스레드가 끝날 때까지 기다린다 inc.Join(); dec.Join(); Console.WriteLine($\u0026#34;Count: {counter.Count}\u0026#34;); // 0 } } Monitor 클래스로 동기화하기 lock 키워드로 똑같은 기능을 하는 Monitor.Enter()(크리티컬 섹션 만들기)와 Monitor.Exit()(크리티컬 섹션 제거하기)이 있다. lock 키워드도 사실은 이 두 메서드들을 바탕으로 구현되어있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void Increase() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { Monitor.Enter(thisLock); try { count++; } finally { Monitor.Exit(thisLock); } Thread.Sleep(1); } } lock보다 좀 더 섬세하게 멀티 스레드 간의 동기화를 가능하게 해주는 메서드들\u0026hellip; Monitor.Wait()메서드 스레드를 WaitSleepJoin상태로 만든다. 해당 스레드는 갖고 있던 lock을 내려놓고 Waiting Queue에 입력된다. Monitor.Pulse()메서드 CLR은 Waiting Queue에서 첫 번째 위치에 있는 스레드를 꺼내서 Ready Queue에 입력시킨다. 그 스레드는 차례로 lock을 얻어서 Running상태에 들어간다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void Increase() { int loopCount = LOOP_COUNT; while (loopCount-- \u0026gt; 0) { lock (thisLock) { // count가 0보다 크거나 // 다른 스레드에 의해 lockedCount가 true가 되면 // Wait()으로 블록된다. while (count \u0026gt; 0 || lockedCount == true) Monitor.Wait(thisLock); lockedCount = true; // 다른 스레드가 사용하지 못하도록한다. count++; lockedCount = false; Monitor.Pulse(thisLock); // 다른 스레드를 깨운다. } Thread.Sleep(1); } } Task와 Task 그리고 Parallel 지금까지 보았던 멀티 스레드는\u0026hellip; 여러 개의 작업을 각각 처리해야하는 상황이었다. (쪼갠 것 아님) 지금부터 볼 병렬 처리는\u0026hellip; 하나의 작업을 쪼갠 뒤 쪼개진 작업들을 동시에 처리하는 것이다. 비동기(Asynchronous) 처리는\u0026hellip; 메소드를 호출한 뒤에 메소드의 종료를 기다리지 않고 바로 다음 코드를 실행하는 것이다. System.Threading.Tasks.Task 클래스 Task 클래스 비동기적으로 실행되는 단일 작업이다. 인스턴스를 생성할 때 Action 대리자를 넘겨받는다. 즉, 반환형을 갖지 않는 메소드, 익명 메소드, 무명 함수 등을 넘겨받는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 실행할 작업물 Action action = () =\u0026gt; { Thread.Sleep(1000); // 이 코드에 상관없이 \u0026#34;동기\u0026#34;가 출력된다. Console.WriteLine(\u0026#34;비동기\u0026#34;); }; // Task로 할당 Task task = new Task(action); // 비동기로 실행한다. task.Start(); Console.WriteLine(\u0026#34;동기\u0026#34;); // 비동기 코드가 완료될 때까지 대기한다. task.Wait(); 1 2 3 4 5 6 7 8 9 10 11 12 // 위와 같은 코드인데 // Task의 생성과 시작을 한번에 한다. var task = Task.Run(() =\u0026gt; { Thread.Sleep(1000); Console.WriteLine(\u0026#34;비동기\u0026#34;); }); Console.WriteLine(\u0026#34;동기\u0026#34;); task.Wait(); 코드의 비동기 실행 결과를 주는 Task 클래스 Task\u0026lt;Result\u0026gt; 클래스 비동기 실행 결과를 손쉽게 얻을 수 있다. 인스턴스를 생성할 때 Func 대리자를 넘겨받아서 결과를 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var task = Task\u0026lt;List\u0026lt;int\u0026gt;\u0026gt;.Run(() =\u0026gt; { Thread.Sleep(1000); List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); list.Add(3); list.Add(4); list.Add(5); return list; }); task.Wait(); List\u0026lt;int\u0026gt; total = new List\u0026lt;int\u0026gt;(); total.Add(0); total.Add(1); total.Add(2); total.AddRange(task.Result.ToArray()); // 0, 1, 2, 3, 4, 5 손쉬운 병렬 처리를 가능케 하는 Parallel 클래스 System.Threading.Tasks.Parallel 클래스 For(), Foreach() 등의 메소드로 병렬 처리를 좀 더 쉽게 구현할 수 있다. 해당 메소드를 병렬로 호출할 때 몇 개의 스레드를 사용할지는 Parallel클래스가 내부적으로 판단하여 최적화한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;int\u0026gt; total = new List\u0026lt;int\u0026gt;(); // 0부터 100사이의 정수를 메소드의 인수로 넘긴다. // 병렬로 처리된다. Parallel.For(0, 100, (int i) =\u0026gt; { if (i % 2 == 0) lock (total) total.Add(i); }); for (int i = 0; i \u0026lt; total.Count; i++) Console.Write($\u0026#34;{total[i]} \u0026#34;); async 한정자와 await 연산자로 만드는 비동기 코드 async 한정자\n컴파일러에게 해당 메서드가 비동기 작업이 포함된 await를 가지고 있음을 알려준다. 내부에서 await 연산자를 찾으면 그곳에서 호출자에게 제어를 돌려준다. 내부에서 await 연산자를 만나지 못하면 제어를 돌려주지 않으므로, 그냥 동기적으로 실행하게 된다. 반환 형식 void: 실행하고 잊어버릴 작업을 수행하는 메소드일 때. 리턴형이 없으므로 비동기 메서드를 호출하는 쪽에서 비동기 제어를 할 수 없게 된다. Task: 리턴값이 없는 경우. Task\u0026lt;Result\u0026gt;: 리턴값이 있는 경우. await 연산자\n단항 연산자이며 awaitable 클래스(GetAwaiter()메서드를 갖는다)를 인수로 갖는다. 이것은 Task 혹은 Task\u0026lt;T\u0026gt; 가 일반적이다. 이 작업을 하는 동안 스레드가 차단되지 않도록(다른 일도 할 수 있도록)한다. 그리고 그 결과를 사용하기 전에 해당 Task가 끝날 때까지 기다린다. 완료 되면 다음 실행문부터 실행을 계속한다. async 메소드의 리턴형 종류 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // void public async void AsyncFunc() { } // Task public async Task AsyncFunc() { await Task.Delay(1000); } // Task\u0026lt;TResult\u0026gt; public async Task\u0026lt;int\u0026gt; AsyncFunc() { await Task.Delay(1000); return 1; } void 를 반환하는 async 메서드 1 2 3 4 5 6 7 8 9 10 11 public static void Main(string[] args) { TaskTest(); System.Console.WriteLine(\u0026#34;Main Thread is NOT Blocked\u0026#34;); Console.ReadLine(); } private static async void TaskTest() { await Task.Delay(5000); // 5초를 기다린다. System.Console.WriteLine(\u0026#34;TaskTest Done\u0026#34;); } Task를 반환하는 async 메서드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // async 한정자가 있으므로 await를 가질 수 있다. public static async Task Main(string[] args) { Task t = TaskTest1(); System.Console.WriteLine(\u0026#34;Do Something Before TaskTest\u0026#34;); await t; // 여기서 t가 끝날 때까지 기다린다. System.Console.WriteLine(\u0026#34;Do Something after TaskTest\u0026#34;); Console.ReadLine(); } private static async Task TaskTest1() { await Task.Delay(5000); // 5초를 기다린다. System.Console.WriteLine(\u0026#34;TaskTest Done\u0026#34;); } Task\u0026lt;TResult\u0026gt;를 반환하는 async 메서드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static async Task Main(string[] args) { Task\u0026lt;int\u0026gt; t = TaskTest(); for(int i = 0; i \u0026lt; 10; i++) { System.Console.WriteLine(\u0026#34;Do Something Before TaskTest\u0026#34;); } int UID = await t; // await을 통해서 반환값을 추출할 수 있다. Console.WriteLine($\u0026#34;UserID : {UID}\u0026#34;); Console.ReadLine(); } private static async Task\u0026lt;int\u0026gt; TaskTest() { int UID = await ...; // DB or server에서 UID 얻어오는 비동기 메서드 호출 System.Console.WriteLine(\u0026#34;TaskTest Done\u0026#34;); return UID; } await와 async 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 async static private void AsyncMethod(int count) { Console.WriteLine(\u0026#34;B\u0026#34;); // 호출자에게 제어를 돌려주고 아래 코드는 비동기적으로 처리된다. // 아래 Task가 끝나야지 다음 문장이 실행 된다. await Task.Run(async () =\u0026gt; { for (int i = 0; i \u0026lt; count; i++) { Console.WriteLine($\u0026#34;{i} / {count} ...\u0026#34;); await Task.Delay(100); // Thread.Sleep()의 비동기 버전이다. } }); Console.WriteLine(\u0026#34;D\u0026#34;); } static void Caller() { Console.WriteLine(\u0026#34;A\u0026#34;); AsyncMethod(3); Console.WriteLine(\u0026#34;C\u0026#34;); } static void Main(string[] args) { Caller(); Console.ReadLine(); // (프로그램 종료 방지) } 1 2 3 4 5 6 7 A B C 0 / 3 ... 1 / 3 ... 2 / 3 ... D ","date":"2022-04-18T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-19/","title":"[This is C#] Chapter 19. 스레드와 태스크"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n람다식 람다식(Lambda Expression) Chapter 13에서도 보았던 익명 메소드를 만들기 위해 사용한다. 림다식으로 만드는 익명 메소드는 무명 함수(Anonymouse Function) 라고 부른다. C# 컴파일러는 형식 유추(Type Inference)라는 기능을 제공한다. 형식 유추를 사용하면 람다식에서 매개변수의 형식을 제거할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 delegate int Calculate(int a, int b); class MainApp { static void Main(string[] args) { // 익명 메소드 Calculate calc1 = delegate (int a, int b) { return a + b; }; // 람다식으로 만든 무명 함수 (형식 유추로 매개변수의 형식을 제거할 수 있다.) Calculate calc2 = (a, b) =\u0026gt; a + b; } } 문 형식의 람다식 문 형식의 람다 식(Statement Lambda) a + b같은 식이 아니라 if (a == b) return 0; else return 1;같은 문장을 사용할 수 있는 람다 식이다. =\u0026gt;연산자의 오른편이 { }과 같은 코드 블록을 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 delegate void DoSomething(); class MainApp { static void Main(string[] args) { // 문 형식의 람다 식 DoSomething doIt = () =\u0026gt; { Console.WriteLine(\u0026#34;뭔가를\u0026#34;); Console.WriteLine(\u0026#34;출력해\u0026#34;); Console.WriteLine(\u0026#34;보자!\u0026#34;); }; doIt(); } } Func와 Action으로 더 간편하게 무명 함수 만들기 .NET 안에 미리 선언되어 있는 대리자들이다. Func 대리자 Func 대리자 결과를 반환하는 메소드를 참조하기 위해 만들어졌다. 1 2 3 4 5 6 static void Main(string[] args) { Func\u0026lt;int\u0026gt; func1 = () =\u0026gt; 1; Func\u0026lt;int, int\u0026gt; func2 = (a) =\u0026gt; a + 1; Func\u0026lt;int, int, int\u0026gt; func3 = (a, b) =\u0026gt; a + b + 1; } Action 대리자 Action 대리자 반환 형식이 없는 메소드를 참조하기 위해 만들어졌다. 1 2 3 4 5 6 7 8 9 static void Main(string[] args) { Action action1 = () =\u0026gt; Console.WriteLine(\u0026#34;Hello\u0026#34;); int result = 0; Action\u0026lt;int\u0026gt; action2 = (a) =\u0026gt; result = a; Action\u0026lt;int, int\u0026gt; action3 = (a, b) =\u0026gt; result = a + b; } 식 트리 식 트리(Expression Tree) 식을 트리 구조로 표현한 것이다. C#은 프로그래머가 코드로 직접 식 트리를 조립하고 컴파일해서 사용할 수 있다. 식 드리를 다루는 데 필요한 클래스들은 System.Linq.Expressions 네임스페이스 안에 준비되어 있다. 모두 Expression 클래스의 파생 클래스들이다. Expression 클래스 자신은 abstract 클래스여서 자신의 인스턴스를 만들 수는 없지만, 파생 클래스의 인스턴스를 생성하는 정적 팩토리 메소드를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Expression const1 = Expression.Constant(1); Expression const2 = Expression.Constant(2); Expression leftExp = Expression.Multiply(const1, const2); // 1 * 2 Expression param1 = Expression.Parameter(typeof(int)); // x Expression param2 = Expression.Parameter(typeof(int)); // y Expression righExp = Expression.Subtract(param1, param2); // x - y Expression exp = Expression.Add(leftExp, righExp); // (1 * 2) + (x - y) // body Expression\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt; expression = Expression\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt;.Lambda\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt;( exp, new ParameterExpression[] {(ParameterExpression) param1, (ParameterExpression) param2} ); Func\u0026lt;int, int, int\u0026gt; func = expression.Compile(); Console.WriteLine($\u0026#34;{func(7, 8)}\u0026#34;); // 1 람다 식을 이용하면 더 간편하게 식 트리를 만들 수 있다. 다만 이 경우에는 동적으로 식 트리를 만들기는 어려워진다. 1 2 3 4 5 Expression\u0026lt;Func\u0026lt;int, int, int\u0026gt;\u0026gt; expression = (a, b) =\u0026gt; (1 * 2) + (a - b); Func\u0026lt;int, int, int\u0026gt; func = expression.Compile(); Console.WriteLine($\u0026#34;{func(7, 8)}\u0026#34;); // 1 식으로 이루어지는 멤버 클래스의 멤버 중에서 본문이 중괄호로 만들어져 있는 것들 메소드, 생성자, 종료자, 프로퍼티, 인덱서 이것은 모두 본문을 식으로만 구현할 수 있다. 이것을 식 본문 멤버(Expression-Bodied Member) 라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MyList { private List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); // 읽기 전용 프로퍼티와 인덱서 public int Capacity =\u0026gt; list.Capacity; public int this[int idx] =\u0026gt; list[idx]; // 읽기, 쓰기 모두 가능한 프로퍼티와 인덱서 public int Capacity { get =\u0026gt; list.Capacity; set =\u0026gt; list.Capacity = value; } public int this[int idx] { get =\u0026gt; list[idx]; set =\u0026gt; list[idx] = value; } // 생성자와 소멸자 public MyList() =\u0026gt; Console.WriteLine(\u0026#34;Hello\u0026#34;); ~MyList() =\u0026gt; Console.WriteLine(\u0026#34;Bye\u0026#34;); // 메서드들 public void Add(int val) =\u0026gt; list.Add(val); public void Remove(int val) =\u0026gt; list.Remove(val); } ","date":"2022-04-17T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-14/","title":"[This is C#] Chapter 14. 람다식"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n대리자 대리자(Delegate) 메소드에 대한 참조이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 델리게이트 형식(Type) delegate int MyDelegate(int a, int b); class Calc { public int Add(int x, int y) { return x + y; } public int Minus(int x, int y) { return x - y; } } class MainApp { static void Main(string[] args) { Calc calc = new Calc(); // 델리게이트 인스턴스 생성 및 등록 MyDelegate callback = new MyDelegate(calc.Add); // 델리게이트 호출 Console.WriteLine($\u0026#34;{callback(3, 4)}\u0026#34;); // 7 callback = new MyDelegate(calc.Minus); Console.WriteLine($\u0026#34;{callback(5, 4)}\u0026#34;); // 1 } } 대리자는 왜, 언제 사용할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 delegate int Compare(int a, int b); class MainApp { static int AscendCompare(int a, int b) { if (a \u0026gt; b) return 1; else if (a == b) return 0; else return -1; } static int DescendCompare(int a, int b) { if (a \u0026lt; b) return 1; else if (a == b) return 0; else return -1; } // 델리게이트를 매개변수로 사용함 static void BubbleSort(int[] data, Compare comparer) { int temp = 0; for (int i = 0; i \u0026lt; data.Length - 1; i++) { for (int j = 0; j \u0026lt; data.Length - (i + 1); j++) { if (comparer(data[j], data[j + 1]) \u0026gt; 0) { temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } } static void Main(string[] args) { int[] arr = {8, 7, 3, 5, 1}; BubbleSort(arr, new Compare(AscendCompare)); for (int i = 0; i \u0026lt; arr.Length; i++) Console.Write($\u0026#34;{arr[i]} \u0026#34;); // 1 3 5 7 8 } } 일반화 대리자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 delegate int Compare\u0026lt;T\u0026gt;(T a, T b); class MainApp { // System.Int32와 같은 모든 수치 형식과 System.String은 모두 IComparable을 상속해서 CompareTo()를 구현하고 있다. // CompareTo()는 매개변수가 자신보다 크면 -1, 같으면 0, 작으면 1을 반환한다. static int AscendCompare\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b); } static int DescendCompare\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b) * -1; } // 델리게이트를 매개변수로 사용함 static void BubbleSort\u0026lt;T\u0026gt;(T[] data, Compare\u0026lt;T\u0026gt; comparer) { T temp; for (int i = 0; i \u0026lt; data.Length - 1; i++) { for (int j = 0; j \u0026lt; data.Length - (i + 1); j++) { if (comparer(data[j], data[j + 1]) \u0026gt; 0) { temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } } static void Main(string[] args) { int[] arr = {8, 7, 3, 5, 1}; BubbleSort\u0026lt;int\u0026gt;(arr, new Compare\u0026lt;int\u0026gt;(AscendCompare)); for (int i = 0; i \u0026lt; arr.Length; i++) Console.Write($\u0026#34;{arr[i]} \u0026#34;); // 1 3 5 7 8 } } 대리자 체인 대리자 하나가 여러 개의 메소드를 동시에 참조할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 delegate void Notify(string mesg); class MainApp { static void Call119(string location) { Console.WriteLine(\u0026#34;Call119\u0026#34;); } static void ShotOut(string location) { Console.WriteLine(\u0026#34;ShotOut\u0026#34;); } static void Escape(string location) { Console.WriteLine(\u0026#34;Escape\u0026#34;); } static void Main(string[] args) { // 델리게이트 체인 (추가 방법1) Notify notify1 = new Notify(Call119); notify1 += ShotOut; notify1 += Escape; // (추가 방법2) Notify notify2 = new Notify(Call119) + new Notify(ShotOut) + new Notify(Escape); // (추가 방법3) Notify notify3 = (Notify) Delegate.Combine(new Notify(Call119), new Notify(ShotOut), new Notify(Escape)); // (삭제 방법1) notify1 -= Call119; // ShotOut Escape // (삭제 방법2) notify3에서 notify2에 있는 것을 뺀다. notify3 = (Notify) Delegate.Remove(notify3, notify1); // Call119 } } 익명 메소드 익명 메소드(Anonymous Method) 이름이 없는 메소드이다. 메소드가 델리게이트에 의해 참조 된 후로 사용할 일이 다시 없다고 한다면 익명 메소드로 선언하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 delegate int Calculate(int a, int b); class MainApp { static void Main(string[] args) { // 익명 메소드 Calculate calc = delegate(int a, int b) { return a + b; }; calc(1, 3); // 4 } } 이벤트 이벤트\n델리게이트에 event 키워드를 붙여서 사용한다. 이벤트와 델리게이트의 차이점\n이벤트는 public 한정자로 선언돼 있어도 자신이 선언된 클래스 외부에서는 호출이 불가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 델리게이트 형식 delegate void Notify(string mesg); class MyClass { // 델리게이트 인스턴스 생성 + event 한정자 public event Notify OnSomethingHappened; public void DoSometing(int number) { // 이벤트 호출 if (number % 2 == 0) OnSomethingHappened(String.Format(\u0026#34;{0} : 짝\u0026#34;, number)); } } class MainApp { static public void PrintMesg(string mesg) { Console.WriteLine(mesg); } static void Main(string[] args) { MyClass myClass = new MyClass(); // 이벤트 등록 myClass.OnSomethingHappened += new Notify(PrintMesg); for (int i = 1; i \u0026lt; 30; i++) { myClass.DoSometing(i); } // event 한정자를 붙이면 클래스 밖에서 호출이 안 된다. myClass.OnSomethingHappened(\u0026#34;클래스 밖에서 호출해보기\u0026#34;); // 컴파일 에러! } } 미리 정의된 대리자들 델리게이트는 형식을 만들고, 인스턴스를 또 생성하여서 사용해야한다. 모든 타입의 형태로 미리 정의된 델리게이트를 간단하게 쓸 수 있는 기능이 바로 Action 과 Func 이다. 이것들은 별도로 미리 정의하지 않아도 한 줄로 표현 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // delegate의 경우 미리 정의해야 한다. delegate void MyDelegate(string mesg); public class MyClass { static void Main(string[] args) { // 그리고 인스턴스를 만들어서 사용한다. // C# 2.0에서는 new 없이 간단하게 인스턴스를 만들 수 있다. MyDelegate myDelegate = ShowMessage; myDelegate(\u0026#34;Hello\u0026#34;); } static void ShowMessage(string mesg) { Console.WriteLine(mesg); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class MyClass { static void Main(string[] args) { // Action의 경우 바로 쓸 수 있다. Action\u0026lt;string\u0026gt; myAction = ShowMessage; myAction(\u0026#34;Hello\u0026#34;); } static void ShowMessage(string mesg) { Console.WriteLine(mesg); } } Action 대리자 반환값이 없는 대리자이다. 매개변수를 16개까지 넣을 수 있다. Action, Action\u0026lt;T\u0026gt;, Action\u0026lt;T1, T2\u0026gt; \u0026hellip; Func 대리자 반환값이 1개 있는 대리자이다. 매개변수를 16개까지 넣을 수 있다. Func\u0026lt;TResult\u0026gt;, Func\u0026lt;T, TResult\u0026gt;, Func\u0026lt;T1, T2, TResult\u0026gt; \u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MyClass { static void Main(string[] args) { Func\u0026lt;int, int, int\u0026gt; myAction = Add; Console.WriteLine(myAction(1, 2)); } static int Add(int a, int b) { return a + b; } } EventHandler 대리자 형식이 지정된 대리자이다. 반환값은 없다. 첫 번째 매개변수는 object 이며 이벤트를 발생시키는 인스턴스를 참조한다. 두 번째 매개변수는 EventArgs 에서 파생된 것이며 이벤트 데이터를 보유한다. EventHandler 이벤트 데이터가 없는 이벤트를 처리할 때 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Publisher { // 이벤트 데이터가 없는 이벤트를 처리할 때 public event EventHandler MyEventHandler; public void DoSometing() { MyEventHandler(this, EventArgs.Empty); } } public class Subscriber { public void HanldeEvent(object sender, EventArgs e) { Console.WriteLine(\u0026#34;Something happened to \u0026#34; + sender.ToString()); Console.ReadLine(); } } public class MainApp { static void Main(string[] args) { Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.MyEventHandler += subscriber.HanldeEvent; publisher.DoSometing(); } } EventHandler\u0026lt;EventArgs\u0026gt; 이벤트 데이터가 있는 이벤트를 처리할 때 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 이벤트 데이터 public class MyEventArgs : EventArgs { public int Id { get; set; } public string Name { get; set; } } public class Publisher { // 이벤트 데이터가 있는 이벤트를 처리할 때 public event EventHandler\u0026lt;MyEventArgs\u0026gt; MyEventHandler; public void DoSometing() { MyEventArgs myArgs = new MyEventArgs(); myArgs.Id = 1; myArgs.Name = \u0026#34;Kim\u0026#34;; MyEventHandler(this, myArgs); } } public class Subscriber { public void HanldeEvent(object sender, MyEventArgs e) { Console.WriteLine(\u0026#34;Something happened to \u0026#34; + sender.ToString()); Console.WriteLine(\u0026#34;Name: \u0026#34; + e.Name + \u0026#34;, Id: \u0026#34; + e.Id); Console.ReadLine(); } } public class MainApp { static void Main(string[] args) { Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.MyEventHandler += subscriber.HanldeEvent; publisher.DoSometing(); } } 대리자를 호출하는 Invoke() 메서드 지금까지 우리는 단순히 대리자를 일반 메서드처럼 호출했지만, 본래는 Invoke() 메서드를 호출하는 것이다. 1 2 3 4 Action myAction = MyMethod; myAction.Invoke(); // Invoke() 메서드 사용 myAction(); // 생략 가능 이벤트 구독할 때 가비지를 발생시키지 않는 방법 참고 사이트 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private event Action cashedAction; private event Action myAction; void Awake() { // 미리 모두 캐시해 놓고 나중에 추가한다. cashedAction = MyMethod; // new Action(MyMethod)이므로 가비지발생 } void Start() { myAction += cashedAction; // 여기서는 가비지가 발생하지 않게된다. } void MyMethod() { //... } 중복으로 이벤트를 구독 할 위험을 줄여주는 방법 event 키워드가 있는 경우 add{} 와 remove{} 접근자를 정의할 수 있다. add{} 에서 이벤트를 구독할 때, 한번 뺀 후 추가함으로써 중복으로 구독할 위험을 줄여준다. 1 2 3 4 5 6 7 8 9 10 11 12 private event Action myAction { add { myAction -= value; // 중복으로 넣을 위험을 줄여준다. myAction += value; } remove { myAction -= value; } } ","date":"2022-04-17T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-13/","title":"[This is C#] Chapter 13. 대리자와 이벤트"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n일반화 프로그래밍 일반화(Generalization) 공통된 개념을 찾아 묶는 것이다. 일반화 메소드 일반화 메소드(Generic Method) 데이터 형식을 일반화한 메소드이다. 구체적인 형식대신 형식 매개변수(Type Parameter) 가 들어간다. 1 2 3 4 5 6 // 일반화 메소드. T는 형식 매개변수이다. void CopyArr\u0026lt;T\u0026gt;(T[] source, T[] target) { for (int i = 0; i \u0026lt; source.Length; i++) target[i] = source[i]; } 일반화 클래스 일반화 클래스(Generic Class) 데이터 형식을 일반화한 클래스이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 제네릭 클래스 class GenericArr\u0026lt;T\u0026gt; { private T[] arr = new T[3]; // 인덱서 public T this[int idx] { get { return arr[idx]; } set { if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;T\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } } class MainApp { static void Main(string[] args) { GenericArr\u0026lt;int\u0026gt; m = new GenericArr\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; for (int i = 0; i \u0026lt; 5; i++) Console.WriteLine($\u0026#34;{m[i]}\u0026#34;); // 0, 1, 2, 3, 4 } } 형식 매개변수 제약시키기 형식 매개변수 T는 모든 데이터 형식을 대신할 수 있다. 이것은 where절을 추가함으로써 제약시킬 수 있다. 제약 설명 where T : struct T는 값 형식이어야 한다. where T : class T는 참조 형식이어야 한다. where T : new() T는 반드시 매개변수가 없는 생성자가 있어야 한다. where T : 기반 클래스 이름 T는 명시한 기반 클래스이거나 그의 파생 클래스여야 한다. where T : 인터페이스 이름 T는 명시한 인터페이스를 구현해야한다. 여러 개의 인터페이스를 명시할 수도 있다. where T : U T는 U로부터 상속받은 클래스여야한다. 일반화 컬렉션 System.Collections.Generic 네임스페이스는 다양한 일반화 컬렉션들을 담고 있다. 일반화 컬렉션은 박싱과 언박싱같은 형식 변환이 매번 일어나지 않기 때문에 좋다. 용도 제네릭 논-제네릭 인덱스 별로 엑세스 List\u0026lt;T\u0026gt; Array, ArrayList 순서대로 액세스 LinkedList\u0026lt;T\u0026gt; FIFO 방식으로 사용 Queue\u0026lt;T\u0026gt; Queue LIFO 방식으로 사용 Stack\u0026lt;T\u0026gt; Stack 키/값 쌍으로 저장 Dictionary\u0026lt;TKey, TValue\u0026gt; Hashtable 추가, 삭제 시 알림 표시 ObservableCollection\u0026lt;T\u0026gt; 정렬된 컬렉션 SortedList\u0026lt;TKey, TValue\u0026gt; SortedList 수학 함수용 집합 HashSet\u0026lt;T\u0026gt; foreach를 사용할 수 있는 일반화 클래스 IEnumerable\u0026lt;T\u0026gt;인터페이스를 구현하면 형식 변환 없이 일반화 클래스로 foreach를 사용할 수 있겠다. IEnumerator GetEnumerator() IEnumerator\u0026lt;T\u0026gt; GetEnumerator() bool MoveNext() void Reset() object Current {get;} T Currnet {get;} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class MyList\u0026lt;T\u0026gt; : IEnumerable\u0026lt;T\u0026gt;, IEnumerator\u0026lt;T\u0026gt; { private T[] arr = new T[3]; private int pos = -1; // 인덱서 public T this[int idx] { get { return arr[idx]; } set { if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;T\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } // IEnumerator의 메소드 및 프로퍼티 object IEnumerator.Current { get { return arr[pos]; } } public T Current { get { return arr[pos]; } } public bool MoveNext() { if (pos == arr.Length - 1) { Reset(); return false; } pos++; return (pos \u0026lt; arr.Length); } public void Reset() { pos = -1; } // IEnumerable의 메소드 IEnumerator IEnumerable.GetEnumerator() { return this; } public IEnumerator\u0026lt;T\u0026gt; GetEnumerator() { return this; } public void Dispose() { //... } } class MainApp { static void Main(string[] args) { MyList\u0026lt;int\u0026gt; m = new MyList\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; // foreach문이 가능! foreach (int number in m) Console.WriteLine($\u0026#34;{ number }\u0026#34;); // 0, 1, 2, 3, 4 } } ","date":"2022-04-16T05:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-11/","title":"[This is C#] Chapter 11. 일반화 프로그래밍"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n배열 배열을 선언하는 방법 1 2 // 요소가 5개인 int형 배열 int[] arr = new int[5]; System.Index형식과 ^연산자 ^연산자는 컬렉션의 마지막부터 연순으로 인덱스를 지정하는 기능을 갖고 있다. 따라서 ^1은 컬렉션의 마지막요소를 나타내는 인덱스이다. Length - 1이라고 생각하면 쉽다. 1 2 3 4 5 6 // 배열의 마지막 요소에 접근하기 System.Index last = ^1; arr[last] = 5; // 이렇게 간결하게 할 수도 있다. arr[^1] = 5; 배열을 초기화하는 방법 세 가지 배열을 초기화하는 방법 세 가지 1 2 3 string[] arr1 = new string[3] { \u0026#34;Hi\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34; }; string[] arr2 = new string[] { \u0026#34;Hi\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34; }; string[] arr3 = { \u0026#34;Hi\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34; }; System.Array .NET의 CTS에서 배열은 System.Array에서 파생된 것이다. 따라서 System.Array 클래스에 있는 메소드와 프로퍼티를 이용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private static void Print(int val) { Console.WriteLine($\u0026#34;{val} \u0026#34;); } private static bool CheckPassed(int score) { return score \u0026gt;= 60; } static void Main(string[] args) { int[] scores = new int[] {90, 80, 70, 60, 50}; // 정렬하기 Array.Sort(scores); // 출력하기 //Array.ForEach\u0026lt;int\u0026gt;(scores, new Action\u0026lt;int\u0026gt;(Print)); // 차원 int rank = scores.Rank; // 길이 int length = scores.Length; // 이진 탐색하기 int bs = Array.BinarySearch\u0026lt;int\u0026gt;(scores, 80); // 모든 요소가 조건에 부합하는지 bool isTrue = Array.TrueForAll\u0026lt;int\u0026gt;(scores, CheckPassed); // 조건에 부합하는 첫 번째 요소의 인덱스 찾기 int findIdx = Array.FindIndex\u0026lt;int\u0026gt;(scores, (score) =\u0026gt; score \u0026lt; 60); // 길이 변경하기 Array.Resize\u0026lt;int\u0026gt;(ref scores, 10); // 숫자는 0으로, 논리는 false로, 참조는 null로 초기화하기 // 3번째 인덱스부터 7개 요소를 초기화한다. Array.Clear(scores, 3, 7); // 복사하기 // scores의 0번째 인덱스부터 3개 요소를 sliced의 0번째 인덱스를 시작으로 복사한다. int[] sliced = new int[3]; Array.Copy(scores, 0, sliced, 0, 3); } 배열 분할하기 System.Range 객체를 사용하면 배열을 쉽게 분할할 수 있다. 시작 인덱스..마지막 인덱스 마지막 인덱스는 포함하지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int[] arr = new int[6]; // 배열 분할하기 System.Range range = 0..4; // 0~3 인덱스 int[] sliced1 = arr[range]; // 이렇게 간결하게 할 수도 있다. int[] sliced2 = arr[0..4]; // 생략하면 첫 시작과 끝을 의미한다. int[] sliced3 = arr[..]; // 0~5 전체 int[] sliced4 = arr[..4]; // 0~3 int[] sliced5 = arr[2..]; // 2~5 // ^연산자를 사용할수도 있다. int[] sliced6 = arr[..^3]; // 0~3 2차원 배열 2차원 배열 1 2 3 4 5 6 7 8 // 2차원 배열의 선언 int[,] arr2d = new int[2, 3]; // 2행 3열 arr2d[0, 2] = 1; // 1행 3열 // 2차원 배열의 초기화 int[,] arr2d1 = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } }; int[,] arr2d2 = new int[,] { { 1, 2, 3 }, { 4, 5, 6 } }; int[,] arr2d3 = { { 1, 2, 3 }, { 4, 5, 6 } }; 다차원 배열 3차원 배열 왠만하면 쓰지 않는 것이 좋다. 1 2 3 4 5 6 7 int[,,] arr3d = new int[4, 3, 2] { { {1, 2}, {3, 4}, {5, 6} }, { {1, 2}, {3, 4}, {5, 6} }, { {1, 2}, {3, 4}, {5, 6} }, { {1, 2}, {3, 4}, {5, 6} } }; 가변 배열 가변 배열(Jagged Array) 다양한 길이의 배열을 요소로 갖는 다차원 배열이다. \u0026lsquo;Jagged\u0026rsquo;란 \u0026lsquo;들쭉날쭉한\u0026rsquo;을 의미한다. 1 2 3 4 5 6 7 8 9 10 int[][] jagged = new int[3][]; jagged[0] = new int[5] {1, 2, 3, 4, 5}; jagged[1] = new int[3] {10, 20, 30}; jagged[2] = new int[2] {100, 200}; string[][] jagged2 = new string[2][] { new string[3] {\u0026#34;Hello\u0026#34;, \u0026#34;Hi\u0026#34;, \u0026#34;What\u0026#39;s up\u0026#34;}, new string[2] {\u0026#34;Good\u0026#34;, \u0026#34;Bye\u0026#34;} }; 컬렉션 맛보기 컬렉션(Collection)\n.NET이 제공하는 데이터를 담는 자료구조이다. ICollection 인터페이스를 상속해야한다. ArrayList는 다양한 형식을 객체를 담을 수 있다.\n이것은 매개변수로 object형식을 받고 있기 때문이다. 하지만 박싱과 언박싱은 오버헤드가 많아지므로 피하는 것이 좋다. 해결방법은? 나중에 일반화 컬렉션에서 찾아보도록 하자. 컬렉션 초기화 방법\nArrayList, Stack, Queue는 배열로 초기화할 수 있다. ArrayList는 컬렉션 초기자를 사용해서 초기화할 수 있다. Hashtable은 컬렉션 초기자나 딕셔너리 초기자를 사용해서 초기화할 수 있다. 컬렉션 초기자를 사용하기 위해서는 IEnumerable인터페이스와 Add()메소드를 구현해야한다. Stack과 Queue는 Add()메소드를 구현하지 않기 때문에 컬렉션 초기자를 사용하지 못한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int[] arr = {1, 2, 3}; // 배열을 이용한 초기화 ArrayList list = new ArrayList(arr); Stack stack = new Stack(arr); Queue queue = new Queue(arr); // 컬렉션 초기자를 이용한 초기화 ArrayList list2 = new ArrayList() {1, 2, 3}; Hashtable hashtable = new Hashtable() { { \u0026#34;하나\u0026#34;, 1 }, { \u0026#34;둘\u0026#34;, 2 } , { \u0026#34;셋\u0026#34;, 3 } }; // 딕셔너리 초기자를 이용한 초기화 Hashtable hashtable2 = new Hashtable() { [\u0026#34;하나\u0026#34;] = 1, [\u0026#34;둘\u0026#34;] = 2, [\u0026#34;셋\u0026#34;] = 3 }; 인덱서 인덱서(Indexer) 인덱스를 이용해서 객체 내의 데이터에 접근하게 해주는 프로퍼티이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MyList { private int[] arr = new int[3]; // 인덱서 public int this[int idx] { get { return arr[idx]; } set { // 사이즈 보다 인덱스가 크면 늘린 후 저장한다. if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;int\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } } class MainApp { static void Main(string[] args) { MyList m = new MyList(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; for (int i = 0; i \u0026lt; 5; i++) Console.WriteLine($\u0026#34;{m[i]}\u0026#34;); // 0, 1, 2, 3, 4 } } foreach가 가능한 객체 만들기 foreach가 가능하기 위해서는 IEnumerable을 상속해야한다. 이 인터페이스는 IEnumerator GetEnumerator()라는 메소드 하나만 갖고 있다. yield문을 이용하면 따로 구현하지 않아도 컴파일러가 자동으로 처리해준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyList : IEnumerable { private int[] arr = new int[3] {0, 1, 2}; public IEnumerator GetEnumerator() { yield return arr[0]; yield return arr[1]; yield return arr[2]; yield break; yield return arr[3]; // 이 코드는 실행되지 않는다. } } class MainApp { static void Main(string[] args) { MyList m = new MyList(); foreach (int number in m) Console.WriteLine($\u0026#34;{ number }\u0026#34;); // 0, 1, 2 } } yield문 없이 IEnumerator를 직접 구현해보자.\nIEnumerator의 메소드 및 프로퍼티\n메소드 및 프로퍼티 설명 bool MoveNext() 다음 요소로 이동한다. 컬렉션의 끝을 넘어선 경우에는 false, 이동이 성공한 경우에는 true를 반환한다. void Reset() 컬렉션의 첫 번째 위치의 \u0026lsquo;앞\u0026rsquo;으로 이동한다. 첫 번째 위치로 이동하는 것은 MoveNext()를 호출한 다음에 이루어지므로 -1이다. object Current {get;} 컬렉션의 현재 요소를 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class MyList : IEnumerable, IEnumerator { private int[] arr = new int[3]; private int pos = -1; // 인덱서 public int this[int idx] { get { return arr[idx]; } set { if (idx \u0026gt;= arr.Length) Array.Resize\u0026lt;int\u0026gt;(ref arr, idx + 1); arr[idx] = value; } } // IEnumerator의 메소드 및 프로퍼티 public object Current { get { return arr[pos]; } } public bool MoveNext() { if (pos == arr.Length - 1) { Reset(); return false; } pos++; return (pos \u0026lt; arr.Length); } public void Reset() { pos = -1; } // IEnumerable의 메소드 public IEnumerator GetEnumerator() { return this; } } class MainApp { static void Main(string[] args) { MyList m = new MyList(); for (int i = 0; i \u0026lt; 5; i++) m[i] = i; // foreach문이 가능! foreach (int number in m) Console.WriteLine($\u0026#34;{ number }\u0026#34;); // 0, 1, 2, 3, 4 } } ","date":"2022-04-16T04:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-10/","title":"[This is C#] Chapter 10. 배열과 컬렉션 그리고 인덱서"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\npublic 필드의 유혹 은닉성을 위해서 필드를 private 으로 선언했다. 어떻게 편리하게 접근하고 값을 변경할 수 있을까? 메소드보다 프로퍼티 getter와 setter를 만드는 대신 프로퍼티를 사용해볼 수 있겠다. 프로퍼티(Property) get{}, set{}을 일컬어 접근자(Accessor)라고 한다. 쓰기 전용 프로퍼티 → set{} 접근자를 구현하지 않으면 되겠다. 읽기 전용 프로퍼티 → get{} 접근자를 구현하지 않으면 되겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyClass { private int num; // 필드 public int Num // 프로퍼티 { get { return num; } // get 접근자 set { num = value; } // set 접근자 } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); int num = a.Num; // get 접근자로 읽기 가능 a.Num = 1; // set 접근자로 쓰기 가능 } } 자동 구현 프로퍼티 자동 구현 프로퍼티(Auto-Implemented Property) get{} , set{} 접근자에 조건이 없는 단순한 경우 좀 더 간결하게 코드를 작성할 수 있는 방법이다. 다음과 같은 코드는 위의 코드와 같은 코드가 된다. 1 2 3 4 class MyClass { public int Num { get; set; } // 자동 구현 프로퍼티 } 자동구현 프로퍼티는 선언과 동시화 초기화를 할 수 있다. 1 2 3 4 class MyClass { public int Num { get; set; } = 29; // 선언과 동시에 초기화 가능 } 프로퍼티로 초기화하기 객체를 생성할 때 생성자에 매개변수를 넘기는 대신, 프로퍼티를 사용해서 각 필드를 초기화할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyClass { public int Age { get; set; } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass() // 프로퍼티를 사용해 초기화할 수 있다 { Age = 1 }; } } 읽기 전용 프로퍼티 (1) 초기화 전용(Init-Only) 자동 구현 프로퍼티 (C# 9.0) init 접근자를 사용한다. 객체를 초기화할 때 한 번 초기화가 이루어진 이후에는 변경할 수 없는 읽기 전용 프로퍼티이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyClass { public string Name { get; init; } // init 접근자 사용 } class MainApp { static void Main(string[] args) { MyClass a = new MyClass() // 초기화를 하였다. { Name = \u0026#34;Kim\u0026#34; }; a.Name = \u0026#34;Lee\u0026#34;; // (X) 초기화 후에는 변경이 불가능하다. } } (2) set{} 접근자를 지정하지 않는다. 생성자에서만 초기화가 가능하다. init{} 접근자의 경우처럼 프로퍼티를 사용해서 초기화할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyClass { public string Name { get; } // set 접근자가 없는 읽기 전용 프로퍼티는 public MyClass() { Name = \u0026#34;Kim\u0026#34;; // 생성자에서만 초기화할 수 있다. } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass() { Name = \u0026#34;Kim\u0026#34; // (X) 프로퍼티를 사용해 초기화하는 것이 불가능하다 }; } } (3) private set{} 클래스 내 다른 메서드에서 값을 변경할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyClass { public string Name { get; private set; } // private set인 읽기 전용 프로퍼티 public MyClass() { Name = \u0026#34;Kim\u0026#34;; } public void ChangeName() { Name = \u0026#34;Lee\u0026#34;; // 클래스 내 다른 메서드에서 값을 변경할 수 있다. } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); } } 읽기 전용 Collection 프로퍼티 컬렉션의 경우에는 어떻게 읽기 전용 프로퍼티를 만들어야 할까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Mine { List\u0026lt;int\u0026gt; keys = new List\u0026lt;int\u0026gt;(); public List\u0026lt;int\u0026gt; Keys =\u0026gt; keys; // 이렇게하면 } class Main { public void Run() { Mine m = new Mine(); m.Keys.Add(1); // Keys에 요소를 추가 삭제할 수 있다는 문제가 있다. } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Mine { List\u0026lt;int\u0026gt; keys = new List\u0026lt;int\u0026gt;(); public IEnumerable\u0026lt;int\u0026gt; Keys =\u0026gt; keys; // 리턴 타입을 읽기 전용인 IEnumerable로 변경하면 } class Main { public void Run() { Mine m = new Mine(); m.Keys.Add(1); // 컴파일 에러! Keys에 요소를 추가 삭제할 수 없다. int val = m.Keys[1]; // 하지만 이것도 안 된다는 문제가 있다. } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Mine { List\u0026lt;int\u0026gt; keys = new List\u0026lt;int\u0026gt;(); public ReadOnlyCollection\u0026lt;int\u0026gt; Keys =\u0026gt; new ReadOnlyCollection\u0026lt;int\u0026gt;(keys); // 그래서 이렇게 사용하면 } class Main { public void Run() { Mine m = new Mine(); m.Keys.Add(1); // 컴파일 에러 int val = m.Keys[1]; // 이것은 접근이 가능하다 } } 레코드 형식으로 만드는 불변 객체 레코드(Record) 데이터 복사와 비교를 손쉽게 할 수 있는 불변 객체이다. 참조 형식이다. 레코드 선언하기 레코드 선언하기 record키워드와 초기화 전용 자동 구현 프로퍼티를 함께 이용해서 선언한다. 쓰기 기능한 프로퍼티와 필드도 넣을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 record RTransaction { public string From { get; init; } public string To { get; init; } public int Amount { get; init; } } class MainApp { static void Main(string[] args) { RTransaction r1 = new RTransaction { From=\u0026#34;Alice\u0026#34;, To=\u0026#34;Bob\u0026#34;, Amount=100 }; RTransaction r2 = new RTransaction { From=\u0026#34;John\u0026#34;, To=\u0026#34;Max\u0026#34;, Amount=200 }; } } with을 이용한 레코드 복사 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 record RTransaction { public string From { get; set; } public string To { get; set; } public int Amount { get; set; } } class MainApp { static void Main(string[] args) { RTransaction r1 = new RTransaction { From=\u0026#34;Alice\u0026#34;, To=\u0026#34;Bob\u0026#34;, Amount=100 }; RTransaction r2 = r1 with { To=\u0026#34;Max\u0026#34; }; // To만 Max로 바꾸면서 r1을 r2에 복사한다. } } 레코드 객체 비교하기 컴파일러는 레코드의 상태를 비교하는 Equals() 메소드를 자동으로 구현한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 record RTransaction { public string From { get; set; } public string To { get; set; } public int Amount { get; set; } } class MainApp { static void Main(string[] args) { RTransaction r1 = new RTransaction { From=\u0026#34;Alice\u0026#34;, To=\u0026#34;Bob\u0026#34;, Amount=100 }; RTransaction r2 = r1 with { To=\u0026#34;Max\u0026#34; }; Console.WriteLine($\u0026#34;{r1.Equals(r2)}\u0026#34;); // False } } 무명 형식 무명 형식(Anonymous Type) int, MyClass같은 형식 이름이 없는 것이다. 괄호 사이에 임의의 프로퍼티 이름을 적고, 값을 할당하면 무명 형식의 프로퍼티가 만들어진다. 선언과 동시에 인스턴스를 할당한다. 1 var a = new { Name = \u0026#34;Kim\u0026#34;, Age = 1 }; // 선언과 동시에 인스턴스 할당 인스턴스가 한 번 만들어지고 난 후에는 변경이 불가능하다. 즉, 읽기만 가능하다. 1 2 3 4 5 6 var a = new { Name = \u0026#34;Kim\u0026#34;, Age = 1 }; string name = a.Name; // 프로퍼티애 접근해서 읽기 가능 int age = a.Age; a.Name = \u0026#34;Lee\u0026#34;; // (X) 인스턴스가 한 번 만들어진 후에는 변경이 불가능하다 인터페이스의 프로퍼티 인터페이스의 프로퍼티 당연히 인터페이스의 프로퍼티는 구현을 갖지 않는다. 그래서 클래스의 자동 구현 프로퍼티 선언과 그 모습이 동일하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 interface IMyInterface { string Name { get; } } class MyClass : IMyInterface { private string name; public string Name { get { return name; } } } 추상 클래스의 추상 프로퍼티 추상 프로퍼티는 어떻게 선언할 수 있을까? 인터페이스처럼 구현을 비워놓을 수는 없다. 그러면 C# 컴파일러가 자동 구현 프로퍼티로 간주하고 구현을 자동으로 채워 넣을 것이다. 따라서 abstract 한정자를 이용해서 선언한다. 추상 프로퍼티는 추상 메서드와 마찬가지로 자식 클래스에서 반드시 오버라이드 해야한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 abstract class MyAbstractClass { // 구현을 가지는 프로퍼티의 경우 private string name; public string Name { get { return name; } } // 구현이 없는 abstract 프로퍼티의 경우 public abstract int Number { get; set; } } class MyClass : MyAbstractClass { // abstract 프로퍼티는 반드시 재정의해야 한다. public override int Number { get; set; } } 람다식과 프로퍼티 프로퍼티는 본문을 간단하게 람다식으로 구현할 수 있다. 이것을 식 본문 멤버(Expression-Bodied Member) 라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyClass { // 읽기, 쓰기 모두 가능한 프로퍼티 private string name; public string Name { get =\u0026gt; name; set =\u0026gt; name = value; } // 읽기 전용 프로퍼티 private int age; public int Age =\u0026gt; age; } 참고 자료 https://www.csharpstudy.com/Mistake/Article/17 ","date":"2022-04-16T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-09/","title":"[This is C#] Chapter 9. 프로퍼티"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n인터페이스의 선언 인터페이스(Interface) 메소드, 이벤트, 인덱서, 프로퍼티만을 가질 수 있다. 인터페이스는 파생 클래스가 반드시 자신이 가진 것을 구현하도록 강제한다. 접근 제한 한정자를 사용할 수 없고, 모든 것이 public으로 선언된다. 인스턴스도 만들 수 없다. 참조는 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface IInterface { void Method(); } class MyClass : IInterface { public void Method() { //... } } class MainApp { static void Main(string[] args) { IInterface a = new MyClass(); a.Method(); } } 인터페이스를 상속하는 인터페이스 인터페이스를 상속할 수 있는 것 클래스 구조체 인터페이스 이미 해당 인터페이스를 상속하는 클래스들이 많거나, 상속하려는 인터페이스가 소스 코드가 아닌 어셈블리로만 제공되는 경우, 인터페이스를 상속하는 인터페이스를 만들 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 interface IBase { void BaseMethod(); } interface IDerived : IBase // 인터페이스를 상속하는 인터페이스 { void DerivedMethod(); } class MyClass : IDerived { public void BaseMethod() { //... } public void DerivedMethod() { //... } } class MainApp { static void Main(string[] args) { Derived d = new MyClass(); d.BaseMethod(); d.DerivedMethod(); } } 여러 개의 인터페이스, 한꺼번에 상속하기 C#은 여러 클래스를 한꺼번에 상속할 수 없다. 죽음의 다이아몬드 문제 때문이다. 하지만 여러 인터페이스를 상속할 순 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 interface IRun { void Run(); } interface IFly { void Fly(); } class FlyingCar : IRun, IFly { public void Run() { Console.WriteLine(\u0026#34;Run\u0026#34;); } public void Fly() { Console.WriteLine(\u0026#34;Fly\u0026#34;); } } class MainApp { static void Main(string[] args) { FlyingCar car = new FlyingCar(); car.Run(); car.Fly(); IRun run = new FlyingCar(); run.Run(); IFly fly = new FlyingCar(); fly.Fly(); } } 포함(Containment) 기법 다른 클래스의 기능을 새로운 클래스에 넣는 방법으로써, 물려받고 싶은 기능을 가진 클래스들을 필드로 선언해 넣는 것이다. 1 2 3 4 5 6 7 8 class MyVehicle { Car car = new Car(); Plane plane = new Plane(); public void Run() { car.Run(); } public void Fly() { plane.Fly(); } } 인터페이스의 기본 구현 메소드 기존 인터페이스에 메소드를 추가하고 싶다. 하지만 인터페이스를 상속하는 파생 클래스가 수 없이 많아서 일일이 다 수정하기에는 너무 번거롭다. 그렇다면, 인터페이스에 기본 구현을 제공하는 메소드를 만들자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 interface IInterface { void PreviousMethod(); void NewMethod() // 기본 구현 메소드 { Console.WriteLine(\u0026#34;New Method\u0026#34;); } } class Myclass : IInterface { public void PreviousMethod() { Console.WriteLine(\u0026#34;Previous Method\u0026#34;); } } class MainApp { static void Main(string[] args) { IInterface i = new Myclass(); i.PreviousMethod(); i.NewMethod(); Myclass m = new Myclass(); m.PreviousMethod(); m.NewMethod(); // 컴파일 에러! NewMethod()를 오버라이딩 하진 않았다. } } 명시적인 인터페이스 구현 암묵적 구현 public으로 구현하는 방식이다. 명시적 구현 private으로 구현하며 [인터페이스이름.함수명] 형식으로 함수 이름을 표시한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface IMyInterface { string Name { get; set; } int Age { get; set; } } public class MyClass : IMyInterface { // 암시적인 구현 = public public string Name { get; set; } // 명시적인 구현 = private = 인터페이스로 형변환 시에만 호출할 수 있다. int IMyInterface.Age { get; set; } } class Program { static void Main(string[] args) { MyClass a = new MyClass(); a.Name = \u0026#34;Kim\u0026#34;; a.Age = 1; // (X) 접근 불가 ((IMyInterface)a).Age = 1; // (O) 접근 가능 } } 여러 개의 인터페이스를 상속받을 때, 이름이 같은 서로 다른 멤버를 선언하는 사례도 해결할 수 있겠다. Microsoft 공식문서 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface ILeft { int P { get;} } interface IRight { int P(); } class Middle : ILeft, IRight { public int P() { return 0; } int ILeft.P { get { return 0; } } } 추상 클래스: 인터페이스와 클래스 사이 추상 클래스(Abstract class) 구현을 가질 수 있지만, 인스턴스를 만들 수 없다. 추상 메소드를 가질 수 있다. 추상 메소드는 파생 클래스가 반드시 이 메소드를 구현하도록 강제한다. 추상 메소드는 반드시 public, protected, internal, protected internal 중에 하나여야 한다. private이면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 abstract class AbstractBase { public abstract void AbstractMethod(); } class MyClass : AbstractBase { public override void AbstractMethod() { //... } } 추상 클래스가 또 다른 추상 클래스를 상속하는 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 abstract class AbstractBase { public abstract void AbstractMethod(); } abstract class AbstractDerived : AbstractBase { public abstract override void AbstractMethod(); } class MyClass : AbstractDerived { public override void AbstractMethod() { Console.WriteLine(\u0026#34;Hello\u0026#34;); } } class MainApp { static void Main(string[] args) { AbstractBase b = new MyClass(); b.AbstractMethod(); } } ","date":"2022-04-16T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-08/","title":"[This is C#] Chapter 8. 인터페이스와 추상 클래스"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n객체지향 프로그래밍과 클래스 객체지향 프로그래밍(Object Oriented Programming; OOP) 문제 상황에 맞는 데이터형(클래스)을 만들어서 프로그래밍하는 방법이다. 클래스가 객체를 만들기 위한 청사진이라면, 객체는 그 실체(Instance)라고 볼 수 있다. 따라서 객체를 인스턴스라고 부르기도 한다. 클래스는 복합 데이터 형식이다. 객체는 속성(데이터), 기능(메소드)으로 이루어져 있다. 클래스의 선언과 객체의 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Cat { public string Name; public string Color; public void Meow() { Console.WriteLine(\u0026#34;{0} : 야옹\u0026#34;, Name); } } class MainApp { static void Main(string[] args) { Cat kitty1 = new Cat(); // Cat 객체를 생성한다. kitty1.Name = \u0026#34;키티\u0026#34;; kitty1.Color = \u0026#34;하얀색\u0026#34;; Cat kitty2; // null을 가진다. } } new 연산자와 생성자는 모든 데이터 형식에 사용할 수 있다. int a = new int(); // (O) 생성자와 종료자 생성자 형식 클래스와 이름이 같고, 반환 형식이 없다. 정의 명시적으로 생성자를 정의하지 않아도 컴파일러에서 생성자를 만들어 준다. 하지만 하나라도 생성자를 직접 정의하면, 기본 생성자를 제공하지 않는다. 오버로딩이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Cat { public string Name; public string Color; public Cat() { Name = \u0026#34;\u0026#34;; Color = \u0026#34;\u0026#34;; } public Cat(string _Name, string _Color) { Name = _Name; Color = _Color; } public void Meow() { Console.WriteLine(\u0026#34;{0} : 야옹\u0026#34;, Name); } } 종료자 형식 클래스 이름 앞에 ~를 붙인다. 생성자와 달리 매개변수도 없고, 한정자도 없다. 정의 오버로딩이 불가능하다. 종료자는 되도록 구현하지 않는 것이 좋다. CLR의 가비지 컬렉터가 객체가 소멸되는 시점을 판단해서 종료자를 호출해준다. 가비지 컬렉터가 우리보다 훨씬 똑똑하게 객체의 소멸을 처리할 수 있다. 종료자를 명시적으로 구현하면 가비지 컬렉터는 클래스의 족보를 타고 올라가서 객체로부터 상속받은 Finalize()메소드를 호출한다. 이렇게 되면 성능 저하를 초래할 확률이 높아진다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Cat { public string Name; public string Color; public Cat() { Name = \u0026#34;\u0026#34;; Color = \u0026#34;\u0026#34;; } public Cat(string _Name, string _Color) { Name = _Name; Color = _Color; } ~Cat() { Console.WriteLine(\u0026#34;{0}, 잘가\u0026#34;, Name); } public void Meow() { Console.WriteLine(\u0026#34;{0} : 야옹\u0026#34;, Name); } } 정적 필드와 메소드 정적(static) 필드, 메소드란? 필드나 메소드가 인스턴스가 아닌, 클래스 자체에 소속되도록 하는 것이다. 프로그램 전체에 걸쳐 하나밖에 존재하지 않는다. 인스턴스를 생성하지 않아도 호출이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class MyClass { public static int StaticVal; public int Val; public static void StaticFunc() { //... } public void Func() { //... } } class MainApp { static void Main(string[] args) { // 인스턴스 없이 접근 가능한 static 필드와 메소드 MyClass.StaticVal = 1; MyClass.StaticFunc(); // 인스턴스에 소속되는 필드와 메소드 MyClass mine = new MyClass(); mine.Val = 1; mine.Func(); } } 객체 복사하기 : 얕은 복사와 깊은 복사 얕은 복사(Shallow Copy) 클래스는 태생이 참조 형식이기 때문에 다음 코드와 같은 경우, 두 객체 모두 하나의 힙에 있는 데이터를 가리키게 되는 문제가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyClass { public int Val; } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); a.Val = 1; MyClass copyA = a; copyA.Val = 2; Console.WriteLine(a.Val); // 2 } } 깊은 복사(Deep copy) 우리가 직접 깊은 복사를 수행하는 코드를 만들어서, 다른 힙에 저장되도록 할 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MyClass { public int Val; public MyClass DeepCopy() { MyClass newCopy = new MyClass(); newCopy.Val = Val; return newCopy; } } class MainApp { static void Main(string[] args) { MyClass a = new MyClass(); a.Val = 1; MyClass copyA = a.DeepCopy(); copyA.Val = 2; Console.WriteLine(a.Val); // 1 } } this 키워드 this 키워드\n객체 내부에서 자기 자신의 필드나 메소드에 접근할 때 사용한다. this() 생성자\n자기 자신의 생성자를 가리킨다. 생성자에서만 사용될 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyClass { private int a, b, c; public MyClass() { this.a = 0; } public MyClass(int b) : this() { this.b = b; } public MyClass(int b, int c) : this(b) { this.c = c; } } 접근 한정자로 공개 수준 결정하기 C#에서 제공하는 접근 한정자 6가지 접근 한정자 설명 public 클래스 내부/외부 모든 곳에서 접근할 수 있다. protected 클래스의 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능하다. private 클래스의 내부에서만 접근할 수 있다. 파생 클래스에서도 접근이 불가능하다. internal 같은 어셈블리에 있는 코드에서만 public으로 접근할 수 있다. 다른 어셈블리에 있는 코드에서는 private과 같은 수준의 접근성을 가진다. protected internal 같은 어셈블리에 있는 코드에서만 protected으로 접근할 수 있다. 다른 어셈블리에 있는 코드에서는 private과 같은 수준의 접근성을 가진다. private internal 같은 어셈블리에 있는 클래스에서 생속받은 클래스 내부에서만 접근이 가능하다. 클래스의 멤버의 접근 한정자는 디폴트로 private이다. 상속으로 코드 재활용하기 객체를 생성할 때 기반 클래스의 생성자 → 파생 클래스의 생성자 객체가 소멸될 때 파생 클래스의 소멸자 → 기반 클래스의 소멸자 매개변수를 가지는 기반 클래스의 생성자를 호출하는 방법? base 키워드를 사용한다. 이것은 기반 클래스를 가리킨다. base 키워드로 기반 클래스의 필드나 메서드에 접근할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseClass { public int BaseVal; public BaseClass(int BaseVal) { this.BaseVal = BaseVal; } public void BaseMethod() { //... } } class DerivedClass : BaseClass { public int DerivedVal; // base()를 통해 기반 클래스의 생성자 호출가능. public DerivedClass(int BaseVal, int DerivedVal) : base(BaseVal) { this.DerivedVal = DerivedVal; } public void DerivedMethod() { // base 키워드를 통해 기반 클래스의 필드나 메서드에 접근 가능. int val = base.BaseVal; base.BaseMethod(); } } 상속이 불가능하도록 만드려면? sealed 키워드를 사용한다. 1 2 3 4 5 6 7 8 9 sealed class BaseClass { //... } class DerivedClass : BaseClass // 컴파일 에러! { //... } 기반 클래스와 파생 클래스 사이의 형식 변환, 그리고 is와 as C#에서 형식 변환을 위한 연산자: is, as (Dog)같이 형식을 변환하는 것 보다는 as Dog과 같이 사용하는 것을 권장한다. as는 참조 형식에 대해서만 사용이 가능하므로, 값 형식의 객체는 기존의 형식 변환 연산자를 사용해야 한다. 연산자 설명 is 객체가 해당 형식으로 변환 가능한지 검사해서 그 결과를 bool값으로 반환한다. as 객체를 해당 형식으로 변환한다. 만약 실패하면 null을 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Animal { } class Dog : Animal { public void Bark() { } } class Cat : Animal { public void Meow() { } } class MainApp { static void Main(string[] args) { Animal ani = new Dog(); if (ani is Dog) { Dog dog = (Dog) ani; dog.Bark(); } Cat cat = ani as Cat; if (cat != null) { cat.Meow(); } } } 오버라이딩과 다형성 다형성(Polymorphism) 객체가 여러 형태를 가질 수 있음을 의미한다. 오버라이딩(Overriding) 다형성을 실현하는 방법이다. 기반 클래스의 메소드를 파생 클래스에서 재정의하는 것을 말한다. 기반 클래스의 메소드가 virtual 키워드로 한정되어 있어야 한다. 그리고 파생 클래스의 메소드에서 override 키워드로 한정하여 컴파일러에게 재정의하고 있음을 알린다. private으로 선언한 메소드는 오버라이딩 할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Animal { public virtual void MakeSound() { Console.WriteLine(\u0026#34;Animal\u0026#34;); } } class Dog : Animal { public override void MakeSound() { Console.WriteLine(\u0026#34;Bark\u0026#34;); } } class Cat : Animal { public override void MakeSound() { Console.WriteLine(\u0026#34;Meow\u0026#34;); } } class MainApp { static void Main(string[] args) { Animal ani = new Dog(); ani.MakeSound(); // Bark ani = new Cat(); ani.MakeSound(); // Meow } } 메소드 숨기기 메소드 숨기기(Method Hiding) CLR에게 기반 클래스에서 구현된 버전의 메소드를 감추고, 파생 클래스에서 구현된 버전만 보여주는 것이다. 파생 클래스의 메소드에 new 키워드를 사용한다. 오버라이딩과 다른 점이라면, 아래 코드처럼 메소드를 단순히 숨기기만 한다는 점이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Animal { public virtual void MakeSound() { Console.WriteLine(\u0026#34;Animal\u0026#34;); } } class Dog : Animal { public new void MakeSound() { Console.WriteLine(\u0026#34;Bark\u0026#34;); } } class MainApp { static void Main(string[] args) { Animal ani = new Dog(); ani.MakeSound(); // Animal } } 오버라이딩 봉인하기 메소드를 오버라이딩되지 않도록 봉인하기 sealed 키워드를 사용한다. 기반 클래스에서 virtual로 선언된 메서드를 상속하는 파생 클래스의 메서드만 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Animal { public virtual void MakeSound() { Console.WriteLine(\u0026#34;Animal\u0026#34;); } } class Dog : Animal { public sealed override void MakeSound() // sealed { Console.WriteLine(\u0026#34;Bark\u0026#34;); } } class Bulldog : Dog { public override void MakeSound() // 컴파일 에러! { } } 읽기 전용 필드 읽기 전용 필드 readonly 키워드를 사용한다. 생성자 안에서 한 번 값을 지정하면, 그 후로는 값을 변경할 수 없다. 클래스나 구조체의 멤버로만 존재할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyClass { private readonly int val; public MyClass() { val = 1; // 생성자에서는 readonly 초기화 가능 } public void MyMethod() { val = 1; // 컴파일 에러! } } 중첩 클래스 중첩 클래스(Nested Class) 클래스 안에 선언되어 있는 클래스이다. 자신이 소속되어 있는 클래스의 멤버에 자유롭게 접근할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 class OuterClass { private int val; class NestedClass { public void DoSomething() { OuterClass outer = new OuterClass(); outer.val = 1; // private이라도 접근이 가능하다. } } } 분할 클래스 분할 클래스(Partial Class) 클래스의 구현이 길어질 경우 여러 파일에 나눠서 구현할 수 있게 한다. partial 키워드를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 partial class MyClass { public void Method1() {} public void Method2() {} } partial class MyClass { public void Method3() {} public void Method4() {} } 확장 메소드 확장 메소드(Extension Method) 기반 클래스의 기능을 확장한다. 이것은 기반 클래스를 물려받아서 파생 클래스를 만든 뒤 필드나 메소드를 추가하는 상속과는 다른 것이다. 확장 메소드를 사용하면, string 클래스에 문자열을 뒤집는 기능을 넣을 수도 있고, int형식에 제곱 연산 기능을 넣을 수도 있다. 선언 방법 선언하는 클래스와 메소드는 static한정자로 수식해야 한다. 확장 메소드의 첫번째 매개변수는 반드시 this 키워드와 함께 확장하고자 하는 클래스(형식)의 인스턴스여야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static class IntegerExtension { public static int Power(this int myInt, int exponent) { int result = myInt; for (int i = 1; i \u0026lt; exponent; i++) result = result * myInt; return result; } } class MainApp { static void Main(string[] args) { int pow = 2.Power(4); int a = 2; pow = a.Power(4); } } 구조체 클래스와 구조체의 차이점 특징 클래스 구조체 형식 참조 형식 값 형식 복사 얕은 복사 깊은 복사 인스턴스 생성 new연산자와 생성자 필요 선언만으로 생성 생성자 제한 없음 매개변수 없는 생성자는 선언 불가능 모든 필드를 초기화하지 않는 생성자는 선언 불가능 상속 가능 불가능 변경불가능 선언 불가능 가능(readonly) 읽기 전용 메소드 불가능 가능(readonly) 변경불가능(Immutable) 구조체 readonly 키워드를 사용한다. 해당 구조체의 모든 필드가 readonly로 선언되도록 강제한다. 1 2 3 4 5 6 7 8 9 10 readonly struct ImmutableStruct { public readonly int ImmutableField; // (O) public int MutableField; // 컴파일 에러! public ImmutableStruct(int val) { ImmutableField = val; // 생성자에서만 초기화 가능 } } 읽기 전용 메소드 readonly 키워드를 사용한다. 해당 메소드가 객체의 상태를 바꿀 수 없게 한다. 구조체에서만 가능하다. 1 2 3 4 5 6 7 8 9 struct MyStruct { public int Value; public readonly void TryToChange() // readonly 메소드는 객체의 상태를 바꿀 수 없다 { Value = 1; // 컴파일 에러! } } 튜플 튜플(Tuple) 여러 필드를 담을 수 있는 구조체이다. 구조체이므로 값 형식이다. 명명되지 않은 튜플(Unnamed Tuple) 필드의 이름을 지정하지 않은 튜플 명명된 튜플(Named Tuple) 필드의 이름을 지정한 튜플 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 컴파일러가 튜플의 모양을 보고 직접 형식을 결정하도록 var를 이용해서 선언한다. // 명명되지 않은 튜플 var unnamedTuple = (\u0026#34;박찬호\u0026#34;, 13); Console.WriteLine($\u0026#34;{unnamedTuple.Item1}, {unnamedTuple.Item2}\u0026#34;); // 명명된 튜플 var namedTuple = (Name: \u0026#34;박찬호\u0026#34;, Age: 13); Console.WriteLine($\u0026#34;{namedTuple.Name}, {namedTuple.Age}\u0026#34;); // 튜플 분해하기 var (name, age) = namedTuple; Console.WriteLine($\u0026#34;{name}, {age}\u0026#34;); // 튜플 분해 시 특정 필드 무시하기 var (n, _) = namedTuple; Console.WriteLine($\u0026#34;{n}\u0026#34;); // 튜플 생성과 분해를 한 번에 하기 -\u0026gt; 여러 변수를 단번에 초기화 var (color, value) = (\u0026#34;White\u0026#34;, 33); Console.WriteLine($\u0026#34;{color}, {value}\u0026#34;); 튜플의 분해 튜플은 분해자(Deconstructor)를 구현하고 있기 때문에 분해가 가능하다. 분해한 결과를 switch문이나 switch식의 분기 조건에 활용할 수도 있다. 이것을 위치 패턴 매칭(Positional Pattern Matching)이라고 한다. 1 2 3 4 5 6 7 8 9 10 var alice = (Job: \u0026#34;학생\u0026#34;, Age: 30); var discountRate = alice switch { (\u0026#34;학생\u0026#34;, int n) when n \u0026lt; 18 =\u0026gt; 0.2, (\u0026#34;학생\u0026#34;, _) =\u0026gt; 0.1, (\u0026#34;일반\u0026#34;, int n) when n \u0026lt; 18 =\u0026gt; 0.1, (\u0026#34;일반\u0026#34;, _) =\u0026gt; 0.05, _ =\u0026gt; 0 }; ","date":"2022-04-16T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-07/","title":"[This is C#] Chapter 7. 클래스"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n메소드 메소드(Method) C와 C++에서의 함수(Function)나 파스칼에서의 프로시저(Procedure)와 같은 것이다. 매개변수(Parameter) 메소드가 호출자에게서 전달받은 값을 받는 변수. 인수(Argument) 호출자가 매개변수에 넘기는 값. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Cal { public static int Plus(int a, int b) // a, b는 매개변수 { return a + b; } } class MainApp { static void Main(string[] args) { Cal.Plus(4, 5); // 4, 5는 인수 } } 참조에 의한 전달 ref 키워드를 메소드의 매개변수 앞에 사용한다. 그리고 호출할 때 ref 키워드를 인수 앞에 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MainApp { static void Swap(ref int a, ref int b) { int temp = a; a = b; b = temp; } static void Main(string[] args) { int x = 1, y = 2; Swap(ref x, ref y); Console.WriteLine(\u0026#34;{0}, {1}\u0026#34;, x, y); // 2, 1 } } 참조 반환값 ref 키워드를 메소드의 반환값 앞에 사용한다. 그리고 return문이 반환하는 변수 앞에도 사용한다. 참조로 반환되는 결과를 담는 지역 변수를 참조 지역 변수(Ref local)라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Product { private int price = 100; public ref int GetPrice() { return ref price; } public void PrintPrice() { Console.WriteLine(price); } } class MainApp { static void Main(string[] args) { Product product = new Product(); // 참조 지역 변수 pref ref int pref = ref product.GetPrice(); pref = 200; product.PrintPrice(); // 200 } } 출력 전용 매개변수 두 개 이상의 결과를 요구하는 메소드는 어떻게 만들까? ref보다 좀 더 안전한 out을 사용한다. 출력 전용 매개변수는 out 키워드를 사용한다. 해당 매개변수에 결과를 저장하지 않으면 컴파일러가 에러 메시지를 출력한다. out으로 전달된 값을 사용할 수 없다. 해당 매개변수로 전달할 변수들을 미리 선언할 필요는 없다. (아래 코드의 c, d의 경우) 1 2 3 4 5 6 7 8 9 10 11 12 13 static void Divide(int a, int b, out int quotient, out int remainder) { quotient = a / b; remainder = a % b; } static void Main(string[] args) { int a = 20, b = 3; Divide(a, b, out int c, out int d); Console.WriteLine(\u0026#34;{0}, {1}\u0026#34;, c, d); // 6, 2 } 메소드 오버로딩 메소드 오버로딩(Overloading)\n하나의 메소드 이름으로 여러 개를 구현한 것이다. 방법\n메소드의 이름을 같게 한다. 메소드의 파라미터를 다르게 한다. 가변 개수의 인수 개수가 유연하게 변할 수 있는 인수이다. params 키워드와 배열을 이용해서 선언한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static int Sum(params int[] args) { int sum = 0; for (int i = 0; i \u0026lt; args.Length; i++) sum += args[i]; return sum; } static void Main(string[] args) { int sum = Sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Console.WriteLine(sum); // 55 } 명명된 인수 메소드를 호출할 때 인수의 이름에 근거해서 데이터를 할당할 수 있는 기능이다. 인수가 너무 많아서 어느 매개변수에 어느 인수를 할당하고 있는지 분간이 어려운 경우에 도움이 될 수 있겠다. 1 2 3 4 5 6 7 8 9 static void PrintProfile(string name, string phone) { Console.WriteLine($\u0026#34;{name}, {phone}\u0026#34;); } static void Main(string[] args) { PrintProfile(name: \u0026#34;박찬호\u0026#34;, phone: \u0026#34;000-0000-0000\u0026#34;); // 박찬호, 000-0000-0000 } 선택적 인수 매개변수에 기본값을 줄 수 있다. 그리고 기본값을 가진 매개변수는 메소드를 호출할 때 인수를 생략할 수 있다. 주의할 점은, 이러한 선택적 인수는 항상 필수 인수 뒤에 와야 한다는 것이다. 1 2 3 4 5 6 7 8 9 static void PrintProfile(string name, string phone = \u0026#34;\u0026#34;) { Console.WriteLine($\u0026#34;{name}, {phone}\u0026#34;); } static void Main(string[] args) { PrintProfile(name: \u0026#34;박찬호\u0026#34;); // 박찬호, } 로컬 함수 로컬 함수는 메소드 안에서 선언되고, 선언된 메소드 안에서만 사용되는 특별한 함수이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class SomeClass { public void SomeMethod() { int count = 0; SomeLocalFunction(1, 2); void SomeLocalFunction(int a, int b) { //... count++; // 지역 변수를 사용할 수 있다. } } } ","date":"2022-04-15T04:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-06/","title":"[This is C#] Chapter 6. 메소드로 코드 간추리기"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n분기문 C#이 제공하는 분기문 if문 switch문 switch 문 C# 7.0부터는 switch문에 데이터 형식을 조건으로 사용할 수 있게 되었다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 object obj = null; string s = Console.ReadLine(); if (int.TryParse(s, out int out_i)) obj = out_i; else if (float.TryParse(s, out float out_f)) obj = out_f; else obj = s; switch (obj) { case int i: Console.WriteLine(\u0026#34;int 형식\u0026#34;); break; case float f: Console.WriteLine(\u0026#34;float 형식\u0026#34;); break; default: Console.WriteLine(\u0026#34;모르는 형식\u0026#34;); break; } when절을 이용하여 추가적은 조건 검사를 수행할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switch (obj) { case int i: Console.WriteLine(\u0026#34;int 형식\u0026#34;); break; case float f when f \u0026gt;= 0: Console.WriteLine(\u0026#34;양의 float 형식\u0026#34;); break; case float f: Console.WriteLine(\u0026#34;음의 float 형식\u0026#34;); break; default: Console.WriteLine(\u0026#34;모르는 형식\u0026#34;); break; } switch 식 switch문을 switch식으로 바꾸는 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int score = 99; int result = (int)(Math.Truncate(score/10.0) * 10); // 1의 자리를 버린다. string grade = \u0026#34;\u0026#34;; switch (result) { case 90: grade = \u0026#34;A\u0026#34;; break; case 80: grade = \u0026#34;B\u0026#34;; break; case 70: grade = \u0026#34;C\u0026#34;; break; default: grade = \u0026#34;F\u0026#34;; break; } 1 2 3 4 5 6 7 8 9 10 int score = 99; int result = (int)(Math.Truncate(score/10.0) * 10); string grade = result switch { 90 =\u0026gt; \u0026#34;A\u0026#34;, 80 =\u0026gt; \u0026#34;B\u0026#34;, 70 =\u0026gt; \u0026#34;C\u0026#34;, _ =\u0026gt; \u0026#34;F\u0026#34; }; switch식에 when절 활용해보기 1 2 3 4 5 6 7 8 9 10 11 12 bool repeated = true; int score = 99; int result = (int)(Math.Truncate(score/10.0) * 10); string grade = result switch { 90 when repeated == true =\u0026gt; \u0026#34;A+\u0026#34;, 90 =\u0026gt; \u0026#34;A\u0026#34;, 80 =\u0026gt; \u0026#34;B\u0026#34;, 70 =\u0026gt; \u0026#34;C\u0026#34;, _ =\u0026gt; \u0026#34;F\u0026#34; }; 반복문 C#이 제공하는 반복문 while문 do while문 for문 foreach문 foreach 배열이나 컬렉션을 순회하면서 각 데이터 요소에 차례대로 접근하도록 해준다. 그리고, 끝에 도달하면 자동으로 반복이 종료된다. 1 2 3 4 int[] arr = new int[]{0, 1, 2, 3, 4}; foreach (int a in arr) Console.WriteLine(a); 점프문 C#이 제공하는 점프문 break continue goto return throw goto goto 레이블;을 통해서 해당 레이블(Label)로 건너뛸 수 있다. 중첩된 반복문을 단번에 뚫고 나올 수 있다는 장점이 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 string input = Console.ReadLine(); int input_number = Convert.ToInt32(input); int exit_number = 0; for (int i = 0; i \u0026lt; 100; i++) { for (int j = 0; j \u0026lt; 200; j++) { for (int k = 0; k \u0026lt; 300; k++) { if (exit_number++ == input_number) goto EXIT_FOR; Console.WriteLine(exit_number); } } } EXIT_FOR: Console.WriteLine(\u0026#34;Exited for\u0026#34;); ","date":"2022-04-15T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-05/","title":"[This is C#] Chapter 5. 코드의 흐름 제어하기"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\nnull 조건부 연산자 해당 객체가 null이면 null을 반환하고, null이 아니면 .뒤에 지정된 멤버를 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 class Foo { public int member; } Foo foo = null; int? bar; bar = foo?.member; // foo가 null이므로 null을 반환한다. foo = new Foo(); bar = foo?.member; // foo가 null이 아니므로 member를 반환한다. null 병합 연산자 왼쪽 피연산자가 null이면 오른쪽 피연산자를 반환하고, null이 아니면 왼쪽 피연산자를 그대로 반환한다. 1 2 3 4 5 int? a = null; int result = a ?? 0; // a가 null이므로 0을 반환한다. a = 1; result = a ?? 0; // a가 null이 아니므로 1을 반환한다. 연산자 우선순위 우선순위 종류 연산자 1 증가/감소 연산자, null 조건부 연산자 a++, a--, ?., ?[] 2 증가/감소 연산자 ++a, --a 3 산술 연산자 *, /, % 4 산술 연산자 +, - 5 시프트 연산자 \u0026lt;\u0026lt;, \u0026gt;\u0026gt; 6 관계 연산자 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, is, as 7 관계 연산자 ==, != 8 비트 논리 연산자 \u0026amp; 9 비트 논리 연산자 ^ 10 비트 논리 연산자 ` 11 논리 연산자 \u0026amp;\u0026amp; 12 논리 연산자 ` 13 null 병합 연산자 ?? 14 조건 연산자 ?: 15 할당 연산자 =, *=, /=, %=, +=, \u0026lt;\u0026lt;=, \u0026gt;\u0026gt;=, \u0026amp;=, ^=, ` ","date":"2022-04-15T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-04/","title":"[This is C#] Chapter 4. 데이터를 가공하는 연산자"},{"content":" 이것이 C#이다 책을 읽고 공부한 노트입니다.\n데이터의 종류 C#에서 데이터는 이렇게 나뉠 수도 있고 기본 데이터 형식(Primitive Type) 복합 데이터 형식(Complex Data Type) 이렇게 나뉠 수도 있다. 값 형식(Value Type) 참조 형식(Reference Type) 즉, 기본 데이터 형식이면서 값 형식일 수도 있고, 참조 형식일 수도 있는 것이다. 이 장에서는 기본 데이터 형식 데이터만 살펴 본다. 값 형식과 참조 형식 값 형식\n스택에 저장된다. 중괄호를 만나면 메모리에서 제거된다. 참조 형식\n힙에 데이터가 저장되고, 스택에 그 주소가 저장된다. 더이상 참조되지 않으면 가비지 컬렉터가 메모리를 수거해 간다. 기본 데이터 형식 기본 데이터 형식은 모두 15가지가 있는데 크게 다음과 같이 나뉜다. 숫자 형식 - 값 형식 논리 형식 - 값 형식 문자열 형식 - 참조 형식 object 형식 - 참조 형식 숫자 형식 (1) 정수 계열 데이터 형식 크기(byte) 값의 범위 sbyte 1 -128 ~ 127 byte 1 0 ~ 255 short 2 -32,768 ~ 32,767 ushort 2 0 ~ 65,535 int 4 -2,147,483,648 ~ 2,147,483,647 uint 4 0 ~ 4,294,967,295 long 8 -922,377,203,685,477,508 ~ 922,377,203,685,477,507 ulong 8 0 ~ 18,446,744,073,709,551,615 char 2 자릿수 구분자(_)를 사용하면 타이핑할 때 편리하다.\nint val = -1000_0000; 2진수, 10진수, 16진수 리터럴\n리터럴(Literal)이란 문자 그대로의 고정값을 나타낸다. 2진수: 0b를 앞에 붙인다. 10진수: 아무것도 붙이지 않는다. 16진수: 0X 또는 0x를 앞에 붙인다. 음수를 표현하는 방식\n부호와 절대값(Sign-and-magnitude) 단순히 맨 왼쪽 비트를 부호를 나타내는 데 사용한다. $+0$과 $-0$이 두 가지로 존재하는 문제가 있다. 그래서 2의 보수법을 사용한다. 2의 보수법(2\u0026rsquo;s Complement) 수 부분 비트를 채운다. 전체 비트를 반전시킨다. 반전된 비트에 $1$을 더한다. 따라서 sbyte의 11111111의 값은 $-1$이 된다. 오버플로우(Overflow)\n최대값보다 큰 데이터를 저장할 때 발생한다. 예를 들면, byte 형식 변수에 $256$을 담으면, $0$이 담기게 된다. 언더플로우(Underflow)\n최저값보다 작은 데이터를 저장할 때 발생한다. 예를 들면, byte 형식 변수에 $-1$을 담으면, $255$가 담기게 된다. (2) 부동 소수 및 소수 계열 부동 소수점 형식(Floating Point Type) 소수점이 움직이면서 수를 표현한다는 뜻이다. decimal은 부동 소수점과는 다른 방식으로 소수를 다루며, 정밀도가 훨씬 높다. 데이터 형식 설명 크기(byte) 접미사 값의 범위 float 7개의 자릿수(단일 정밀도) 4 f -3.402823e38 ~ -3.402823e38 double 15~16개의 자릿수(복수 정밀도) 8 없음 -1.79769313486232e308 ~ -1.79769313486232e308 decimal 29개의 자릿수 16 m 정밀도(Precision) 정보 손실 없이 나타낼 수 있는 유의한 자릿수. C#의 float과 double은 IEEE754라는 표준 알고리즘에 기반한다. 이에 따르면 float형식은 다음과 같이 구성된다. 1비트: 부호(Sign) 비트 8비트: 지수부(Exponent) 23비트: 가수부(Mantissa) 가수부가 23비트이기 때문에 이것으로는 총 7자리의 수를 만들 수 있으며, 즉 유효숫자가 7자리인 셈이다. 따라서 한정된 정밀도를 가진다. 문자 형식과 문자열 형식 char 형식 문자를 다루며 따옴표로 문자를 감싸줘야 한다. string 형식 문자열을 다루며 큰 따옴표로 문자열을 감싸줘야 한다. 논리 형식 bool은 True혹은 False값을 가지며 크기는 $1$바이트이다. object 형식 모든 데이터 형식의 조상이다.\n박싱(Boxing)\n값 형식의 데이터를 참조 형식 데이터로 변경할 때. 언박싱(Unboxing)\n참조 형식의 데이터를 값 형식 데이터로 변경할 때. 1 2 object obj = 20; // 박싱 int val = (int)obj; // 언박싱 상수와 열거 형식 상수(Constants)와 열거 형식(Enumerator)은 변수와 다르게, 안에 담긴 데이터를 절대 바꿀 수 없는 메모리 공간이다. const int a = 3; `enum Result { YES = 10, NO, CANCEL, CONFIRM, OK } Nullable 형식 어떠한 값도 가지지 않는 null이 될 수 있는 변수이다. 데이터 형식 뒤에 ?를 붙여서 선언하면 된다. int? a = null; var var로 변수를 선언하면 컴파일러가 자동으로 해당 변수의 형식을 지정해준다. 반드시 선언과 동시에 초기화를 해야한다. 지역 변수로만 사용할 수 있다. 클래스의 필드를 선언할 때는 사용할 수 없다. var a = 3; // int형식 공용 형식 시스템 공용 형식 시스템(Common Type System) .NET의 형식 체계 표준이다. C#의 데이터 형식 체계는 모두 공용 형식 시스템을 따른다. 따라서 .NET 언어들끼리 호환성을 갖는다. CTS 클래스 이름 C# 형식 C++ 형식 System.Byte byte unsigned char System.SByte sbyte char System.Int16 short short System.Int32 int int 또는 long System.Int64 long __int64 System.UInt16 ushort unsigned short System.UInt32 uint unsigned int 또는 unsigned long System.UInt64 ulong unsigned__int64 System.Single float float System.Double double double System.Boolean bool bool System.Char char wchar_t System.Decimal decimal Decimal System.IntPtr 없음 없음 System.UIntPtr 없음 없음 System.Object object Object* System.String string String* ","date":"2022-04-15T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/this-is-c-sharp-03/","title":"[This is C#] Chapter 3. 데이터 보관하기"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n람다 함수 랜덤한 정수들 중에서 얼마나 많은 수가 3으로, 13으로 나뉘는지 확인하고 싶다. 1. 함수 포인터\n1 2 3 4 5 6 7 8 9 10 11 bool F3(int x) { return (x % 3) == 0; } bool F13(int x) { return (x % 13) == 0; } int main() { vector\u0026lt;int\u0026gt; numbers(1000); generate(numbers.begin(), numbers.end(), rand); int count3 = count_if(numbers.begin(), numbers.end(), F3); int count13 = count_if(numbers.begin(), numbers.end(), F13); } 2. 펑크터\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class FMod { private: int dv; public: FMod(int d = 1) : dv(d) {} bool operator()(int x) { return (x % dv) == 0; } }; int main() { vector\u0026lt;int\u0026gt; numbers(1000); generate(numbers.begin(), numbers.end(), rand); int count3 = count_if(numbers.begin(), numbers.end(), FMod(3)); int count13 = count_if(numbers.begin(), numbers.end(), FMod(13)); } 3. 람다\n함수 이름이 []이 되었다. 반환 타입은 선언되지 않았다. decltype이 반환 값으로부터 추정된 타입이 반환 타입이 된다. 만약, 단일 구문을 반환하는 구조가 아니라서 반환 타입이 자동으로 결정되지 않는다면 반환 값을 추정하는 문법이 필요하다. 1 2 3 4 5 6 7 8 int main() { vector\u0026lt;int\u0026gt; numbers(1000); generate(numbers.begin(), numbers.end(), rand); int count3 = count_if(numbers.begin(), numbers.end(), [](int x){ return (x % 3) == 0; }); int count13 = count_if(numbers.begin(), numbers.end(), [](int x){ return (x % 13) == 0; }); } 1 2 [](int i)-\u0026gt;double { double d = i; return d - i; } // 반환 타입은 double형이다. 왜 람다를 쓰는가? 근접성 사용하는 곳 가까이에 정의하는 것이 유용하다. count_if() 함수 세 번째 매개변수가 호출하는 것이 무엇인지 코드를 스캔하고 싶지 않다. 간결함 람다에 이름을 생성하여 반복해 사용할 수 있다. auto mod3 = [](int x){ return (x % 3) == 0; }; 효율 인라인화가 되어 접근이 빠르다. 능력 범위 내에서 모든 자동화된 변수 이름으로 접근이 가능하다. [변수이름]으로 변수를 값으로 접근한다. [\u0026amp;변수이름]으로 변수를 참조로 접근한다. [\u0026amp;]으로 모든 자동화된 변수를 참조로 접근한다. [=]으로 모든 자동화된 변수를 값으로 접근한다. 혼합하여 사용하는 것도 가능하다. 1 2 int count3 = 0; for_each(numbers.begin(), numbers.end(), [\u0026amp;count3](int x){ count3 += ((x % 3) == 0); }); 1 2 3 int count3 = count13 = 0; for_each(numbers.begin(), numbers.end(), [\u0026amp;](int x){ count3 += ((x % 3) == 0); count13 += ((x % 13) == 0); }); 래퍼(Wrapper) 템플릿의 비효율성 많은 타입이 존재할 수 있는 가능성은 템플릿의 비효율성을 초래할 수 있다. 아래 예제와 같은 경우 F의 시그니처는 double (double)로 동일함에도 불구하고, UseFunction()의 인스턴스가 5개나 생성되었다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 template \u0026lt;typename T, typename F\u0026gt; T UseFunction(T v, F f) { static int count = 0; // static 변수로 얼마나 많은 인스턴스가 생성되는지 체크한다. count++; cout \u0026lt;\u0026lt; \u0026#34;UseFunction count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;, \u0026amp;count = \u0026#34; \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; return f(v); } class Fp { private: double z; public: Fp(double zz = 1.0) : z(zz) {} double operator()(double p) { return z * p; } }; class Fq { private: double z; public: Fq(double zz = 1.0) : z(zz) {} double operator()(double q) { return z + q; } }; double Double(double x) { return 2.0 * x; } double Square(double x) { return x * x; } int main() { double y = 1.21; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Double:\\n\u0026#34;; // double (*) (double) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Double) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Square:\\n\u0026#34;; // double (*) (double)로 같다. cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Square) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fp:\\n\u0026#34;; // Fp의 인스턴스 cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Fp(5.0)) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fq:\\n\u0026#34;; // Fq의 인스턴스 cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, Fq(5.0)) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, [](double u){return u * u; }) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, [](double u){return u + u / 2.0; }) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 함수 포인터 Double: UseFunction count = 1, \u0026amp;count = 001E03D8 2.42 함수 포인터 Square: UseFunction count = 2, \u0026amp;count = 001E03D8 1.4641 펑크터 Fp: UseFunction count = 1, \u0026amp;count = 001E03DC 6.05 펑크터 Fq: UseFunction count = 1, \u0026amp;count = 001E03E0 6.21 람다 표현식 1: UseFunction count = 1, \u0026amp;count = 001E03E4 1.4641 람다 표현식 2: UseFunction count = 1, \u0026amp;count = 001E03E8 1.815 함수 래퍼로 문제 해결 function\u0026lt;\u0026gt;템플릿은 같은 함수 시그내처를 갖는 함수 포인터, 펑크터, 람다 표현식을 포장하는데 사용한다. 아래 코드와 같은 경우, function\u0026lt;double(double)\u0026gt;을 사용하여 여섯 개의 래퍼를 생성한다. 이것은 F를 모두 같은 타입으로 만든다. 따라서 최종적으로 1개의 UseFunction()인스턴스만 만들어진다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 double y = 1.21; // 6개의 래퍼를 생성한다. function\u0026lt;double(double)\u0026gt; ef1 = Double; function\u0026lt;double(double)\u0026gt; ef2 = Square; function\u0026lt;double(double)\u0026gt; ef3 = Fq(5.0); function\u0026lt;double(double)\u0026gt; ef4 = Fp(5.0); function\u0026lt;double(double)\u0026gt; ef5 = [](double u){ return u * u; }; function\u0026lt;double(double)\u0026gt; ef6 = [](double u){ return u + u / 2.0; }; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Double:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef1) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;함수 포인터 Square:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef2) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fp:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef3) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;펑크터 Fq:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef4) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef5) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;람다 표현식 2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, ef6) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 함수 포인터 Double: UseFunction count = 1, \u0026amp;count = 00945660 2.42 함수 포인터 Square: UseFunction count = 2, \u0026amp;count = 00945660 1.4641 펑크터 Fp: UseFunction count = 3, \u0026amp;count = 00945660 6.21 펑크터 Fq: UseFunction count = 4, \u0026amp;count = 00945660 6.05 람다 표현식 1: UseFunction count = 5, \u0026amp;count = 00945660 1.4641 람다 표현식 2: UseFunction count = 6, \u0026amp;count = 00945660 1.815 typedef로 간소화한 표현이 가능하다. 1 2 3 4 5 6 7 double y = 1.21; typedef function\u0026lt;double(double)\u0026gt; fdd; //... cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; UseFunction(y, fdd(Double)) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; 템플릿 자체를 바꾸어 볼 수도 있다. 1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; T UseFunction(T v, function\u0026lt;T(T)\u0026gt; f) { static int count = 0; count++; cout \u0026lt;\u0026lt; \u0026#34;UseFunction count = \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;, \u0026amp;count = \u0026#34; \u0026lt;\u0026lt; \u0026amp;count \u0026lt;\u0026lt; endl; return f(v); } 가변인자 템플릿 임의의 개수의 인자를 받는 함수를 만들 수는 없을까? 템플릿 매개변수 팩(Template parameter packs), 함수 매개변수 팩(Function parameter packs) 1 2 3 4 5 6 7 8 9 10 11 12 13 // ...는 0개 이상의 인자들을 나타낸다. template\u0026lt;typename... Args\u0026gt; // 템플릿 매개변수 팩 void Show(Args... args) // 함수 매개변수 팩 { } int main() { Show(); Show(\u0026#34;hello\u0026#34;); Show(4.5, 1, string(\u0026#34;str\u0026#34;), \u0026#39;c\u0026#39;); } 언패킹 팩(Unpacking a pack) 어떻게 팩의 내용을 언패킹할 수 있을까? 즉, Show()함수 내에서 어떻게 팩의 내용인 4.5, 1, string(\u0026quot;str\u0026quot;), c들을 접근할 수 있을까? 재귀(Recursion) 재귀를 적절하게 사용하면 팩의 아이템들에 접근할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template \u0026lt;typename T\u0026gt; void Show(T arg) // 마지막 매개변수에 대한 처리. { cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; endl; } template \u0026lt;typename T, typename... Args\u0026gt; void Show(T arg, Args... args) { cout \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; Show(args...); // 첫번째 매개변수를 제외한 매개변수로 재귀적으로 호출한다. } int main() { int n = 14; double x = 2.71828; string mr = \u0026#34;Mr. String objects!\u0026#34;; Show(n, x); Show(x * x, \u0026#39;!\u0026#39;, 7, mr); } 1 2 14, 2.71828 7.38905, !, 7, Mr. String objects! ","date":"2022-03-27T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-18-2/","title":"[C++ Primer Plus] Chapter 18. (2) 람다 함수, 래퍼, 가변인자 템플릿"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\nMove Semantics의 필요성 Move Semantics는 객체의 리소스(동적 할당된 메모리 같은 것)를 또 다른 객체로 이동하는 것을 의미한다. 만약 1,000자의 문자 string을 20,000개 가지고 있는 vector가 있다고 하자. 이것을 복사하면? vector 복사 생성자가 new를 이용해서 20,000개의 string 객체를 넣을 메모리를 만들어서 대입하고, string 복사 생성자가 또 new를 이용해서 1,000개의 문자를 넣을 메모리를 만들어서 대입한다. 그러면 총 20,000,000개의 문자가 복사된다. 하지만 굳이 이런 복사를 하지 않아도 되는 경우가 있다. 아래 예시 (2)의 경우가 그렇다. AllCaps()에서 임시 객체 temp를 생성하고 그리고 함수 종료 시 임시 객체를 삭제한다. 20,000,000개의 문자가 새로운 곳(copy2)에 저장되고 이전 저장소(temp)가 삭제되는 대신 문자가 남아 있는 자리에 이름만 copy2로 바꿔주면 어떨까? 이런 접근법을 Move Semantics라고 한다. Move Semantics을 위해서는\u0026hellip; rvalue 참조를 사용하는 이동 생성자를 만들어야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;string\u0026gt; AllCaps(const vector\u0026lt;string\u0026gt;\u0026amp; vs) { vector\u0026lt;string\u0026gt; temp; // 매개변수로 전달된 vs를 모두 대문자로 만들어서 temp에 저장한다. return temp; } int main() { vector\u0026lt;string\u0026gt; strs; // strs가 1,000자의 문자 string을 20,000개 가지고 있다고 가정하자. vector\u0026lt;string\u0026gt; copy1(strs); // (1) vector\u0026lt;string\u0026gt; copy2(AllCaps(strs)); // (2) } 이동 생성자 및 이동 대입 연산자 예시 이동 생성자 Useless::Useless(Useless \u0026amp;\u0026amp; f) 매개변수로 전달된 f의 주소를 가로채고, nullptr로 설정해준다. 이것은 소멸자가 같은 주소에 대해 두 번 delete []하는 것을 막는다. 이것을 pilfering(필퍼링, 좀도둑질)이라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 #include \u0026lt;iostream\u0026gt; using namespace std; class Useless { private: int n; // 매개변수 수 char* pc; // 데이터를 가리키는 포인터 static int ct; // 전체 객체 수 카운트 void ShowObject() const; public: Useless(); explicit Useless(int k); Useless(int k, char ch); Useless(const Useless\u0026amp; f); // 일반적인 복사 생성자 Useless(Useless\u0026amp;\u0026amp; f); // 이동 생성자 ~Useless(); Useless operator+(const Useless\u0026amp; f)const; Useless\u0026amp; operator=(const Useless\u0026amp; f); // 일반적인 복사 대입 연산자 Useless\u0026amp; operator=(Useless\u0026amp;\u0026amp; f); // 이동 대입 연산자 void ShowData() const; }; int Useless::ct = 0; Useless::Useless() { ++ct; n = 0; pc = nullptr; cout \u0026lt;\u0026lt; \u0026#34;기본 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; ShowObject(); } Useless::Useless(int k) : n(k) { ++ct; cout \u0026lt;\u0026lt; \u0026#34;int 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = new char[n]; ShowObject(); } Useless::Useless(int k, char ch) : n(k) { ++ct; cout \u0026lt;\u0026lt; \u0026#34;int, char 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = new char[n]; for (int i = 0; i \u0026lt; n; i++) pc[i] = ch; ShowObject(); } Useless::Useless(const Useless\u0026amp; f) : n(f.n) // 일반적인 복사 생성자 { ++ct; cout \u0026lt;\u0026lt; \u0026#34;복사 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = new char[n]; for (int i = 0; i \u0026lt; n; i++) pc[i] = f.pc[i]; ShowObject(); } Useless::Useless(Useless\u0026amp;\u0026amp; f) : n(f.n) // 이동 생성자 { ++ct; cout \u0026lt;\u0026lt; \u0026#34;이동 생성자 호출됨; 총 객체 수: \u0026#34; \u0026lt;\u0026lt; ct \u0026lt;\u0026lt; endl; pc = f.pc; // 주소 가로채기 f.pc = nullptr; // 이전 객체가 아무것도 반환하지 않도록 함 f.n = 0; ShowObject(); } Useless::~Useless() { cout \u0026lt;\u0026lt; \u0026#34;소멸자 호출됨; 남은 객체 수: \u0026#34; \u0026lt;\u0026lt; --ct \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;삭제된 객체 정보: \u0026#34;; ShowObject(); delete[] pc; } Useless Useless::operator+(const Useless\u0026amp; f)const { cout \u0026lt;\u0026lt; \u0026#34;연산자 +() 진입\\n\u0026#34;; Useless temp = Useless(n + f.n); for (int i = 0; i \u0026lt; n; i++) temp.pc[i] = pc[i]; for (int i = n; i \u0026lt; temp.n; i++) temp.pc[i] = f.pc[i - n]; cout \u0026lt;\u0026lt; \u0026#34;연산자 +() 나옴\\n\u0026#34;; return temp; } Useless\u0026amp; Useless::operator=(const Useless\u0026amp; f) // 일반적인 복사 대입 연산자 { if (this == \u0026amp;f) return *this; delete[] pc; n = f.n; pc = new char[n]; for (int i = 0; i \u0026lt; n; i++) pc[i] = f.pc[i]; return *this; } Useless\u0026amp; Useless::operator=(Useless\u0026amp;\u0026amp; f) // 이동 대입 연산자 { if (this == \u0026amp;f) return *this; delete[] pc; n = f.n; pc = f.pc; // 주소 가로채기 f.pc = nullptr; // 이전 객체가 아무것도 반환하지 않도록 함 f.n = 0; return *this; } void Useless::ShowObject() const { cout \u0026lt;\u0026lt; \u0026#34;매개변수 수: \u0026#34; \u0026lt;\u0026lt; n; cout \u0026lt;\u0026lt; \u0026#34; 데이터 주소: \u0026#34; \u0026lt;\u0026lt; (void*)pc \u0026lt;\u0026lt; endl; } void Useless::ShowData() const { if (n == 0) cout \u0026lt;\u0026lt; \u0026#34;(객체 없음)\u0026#34;; else for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; pc[i]; cout \u0026lt;\u0026lt; endl; } int main() { { Useless one(10, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; endl; Useless two = one; // 복사 생성자 호출 cout \u0026lt;\u0026lt; endl; Useless three(20, \u0026#39;o\u0026#39;); cout \u0026lt;\u0026lt; endl; Useless four(one + three); // +()연산자와 이동 생성자 호출 cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;모든 객체 정보 표시해보기 \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;one: \u0026#34;; one.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;two: \u0026#34;; two.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;three: \u0026#34;; three.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;four: \u0026#34;; four.ShowData(); cout \u0026lt;\u0026lt; endl; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int, char 생성자 호출됨; 총 객체 수: 1 매개변수 수: 10 데이터 주소: 01526730 복사 생성자 호출됨; 총 객체 수: 2 매개변수 수: 10 데이터 주소: 01526180 int, char 생성자 호출됨; 총 객체 수: 3 매개변수 수: 20 데이터 주소: 01529F50 연산자 +() 진입 int 생성자 호출됨; 총 객체 수: 4 매개변수 수: 30 데이터 주소: 01529F90 연산자 +() 나옴 이동 생성자 호출됨; 총 객체 수: 5 매개변수 수: 30 데이터 주소: 01529F90 소멸자 호출됨; 남은 객체 수: 4 삭제된 객체 정보: 매개변수 수: 0 데이터 주소: 00000000 모든 객체 정보 표시해보기 one: xxxxxxxxxx two: xxxxxxxxxx three: oooooooooooooooooooo four: xxxxxxxxxxoooooooooooooooooooo 소멸자 호출됨; 남은 객체 수: 3 삭제된 객체 정보: 매개변수 수: 30 데이터 주소: 01529F90 소멸자 호출됨; 남은 객체 수: 2 삭제된 객체 정보: 매개변수 수: 20 데이터 주소: 01529F50 소멸자 호출됨; 남은 객체 수: 1 삭제된 객체 정보: 매개변수 수: 10 데이터 주소: 01526180 소멸자 호출됨; 남은 객체 수: 0 삭제된 객체 정보: 매개변수 수: 10 데이터 주소: 01526730 강제 이동 이동 생성자와 이동 대입 연산자는 rvalue와 함께 동작한다. 하지만 lvalue와 함께 사용하고 싶을 때가 있다. 1 2 3 4 5 6 7 8 Useless choices[10]; Useless best; int pick; // 한 객체를 선택하고 pick 번째를 색인 하기 위한 설정... best = choices[pick]; // 이렇게 하나를 선택하고 이전 배열을 버린다면... // choices[pick]은 lvalue이지만 rvalue로 사용해서 이동 대입 연산자를 사용할 수 있다면 편리할 것이다. static_cast\u0026lt;\u0026gt;연산자를 이용해서 객체를 Useless\u0026amp;\u0026amp;타입으로 변환하면 가능하다. C++11에서는 이와 비슷한 방법을 제공한다. utility 헤더파일에 선언된 move()함수를 이용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Useless one(10, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; endl; Useless two; cout \u0026lt;\u0026lt; endl; two = one; // 복사 대입 cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;모든 객체 정보 표시해보기 \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;one: \u0026#34;; one.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;two: \u0026#34;; two.ShowData(); cout \u0026lt;\u0026lt; endl; two = move(one); // 강제 이동 대입 cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;모든 객체 정보 표시해보기 \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;one: \u0026#34;; one.ShowData(); cout \u0026lt;\u0026lt; \u0026#34;two: \u0026#34;; two.ShowData(); cout \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //... 복사 대입 연산자 호출 모든 객체 정보 표시해보기 one: xxxxxxxxxx two: xxxxxxxxxx 이동 대입 연산자 호출 모든 객체 정보 표시해보기 one: (객체 없음) two: xxxxxxxxxx //... move()는 이동 대입 연산자를 호출한다. 만약 이동 대입 연산자를 정의하지 않았다면, 복사 대입 연산자를 사용한다. 그것도 정의하지 않았다면, 대입은 절대 허용되지 않는다. 새로운 클래스 형태 복사 생성자, 복사 대입 연산자를 제공한다면,\n컴파일러는 이동 연산자나 이동 대입 연산자를 자동으로 제공하지 않는다. 반대로, 이동 연산자나 이동 대입 연산자를 제공한다면,\n컴파일러는 복사 생성자나 복사 대입 연산자를 제공하지 않는다. 기본 함수, 삭제 함수 default 키워드 컴파일러가 생성하는 기본 함수를 사용하고자하는 경우 delete 키워드 컴파일러가 특정 함수를 사용하는 것을 방지하고자 하는 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Someclass { public: // 컴파일러가 생성한 기본 생성자를 사용한다. Someclass() = default; // 복사 생성자와 복사 대입 연산자를 사용할 수 없다. Someclass(const Someclass\u0026amp;) = delete; Someclass\u0026amp; operator=(const Someclass\u0026amp;) = delete; // 컴파일러가 생성한 이동 생성자와 이동 대입 연산자를 사용한다. Someclass(Someclass\u0026amp;\u0026amp;) = default; Someclass\u0026amp; operator=(Someclass\u0026amp;\u0026amp;) = default; Someclass\u0026amp; operator+(const Someclass\u0026amp;) const; }; int main() { Someclass one; Someclass two; Someclass three(one); // (X) lvalue는 허용하지 않는다. Someclass four(one + two); // (O) rvalue는 허용한다. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Someclass { public: // delete키워드로 특정 변환을 막을 수 있다. void DoSomething(int) = delete; void DoSomething(double); }; int main() { Someclass one; one.DoSomething(1); // (X) 컴파일 에러 one.DoSomething(1.1); // (O) } 위임 생성자 다른 생성자의 정의의 일부를 생성자로 사용할 수 있도록 한 것이다. 한 생성자가 임시로 다른 생성자가 생성한 객체에 책임을 전가하기 때문에 위임(delegation)이라고 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Notes { private: int i; double d; string st; public: Notes(); Notes(int); Notes(int, double); Notes(int, double, string); }; Notes::Notes(int ii, double dd, string stt) : i(ii), d(dd), st(stt) { } Notes::Notes() : Notes(0, 0.0, \u0026#34;\u0026#34;) { } Notes::Notes(int ii) : Notes(ii, 0.0, \u0026#34;\u0026#34;) { } Notes::Notes(int ii, double dd) : Notes(ii, dd, \u0026#34;\u0026#34;) { } 상속 생성자 파생 클래스에서 기본 클래스의 모든 생성자를 사용할 수 있다. 상속된 기본 클래스 생성자는 오직 기본 클래스 멤버만을 초기화한다는 것을 명심하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Base { private: int i; double d; public: Base() : i(0), d(0.0) {} Base(int ii) : i(ii), d(0.0) {} Base(double dd) : i(0), d(dd) {} Base(int ii, double dd) : i(ii), d(dd) {} }; class Derived : public Base { private: short s; public: using Base::Base; // Base 클래스의 생성자를 사용할 수 있다. Derived() : s(0) {} Derived(double dd) : Base(dd), s(0) {} Derived(int ii) : Base(ii), s(0) {} }; int main() { Derived derived(10, 1.8); // Derived에 (int, double) 생성자가 없으므로 // Base(int, double)을 사용한다. // 당연히 Derived의 멤버는 초기화되지 않는다. } 가상 함수 관리 가상 지정자 override를 사용함으로써 가상 함수를 오버라이드 하겠다는 것을 명시할 수 있다. 선언이 기본 함수와 일치하지 않았을 때, override를 사용하지 않으면 단순히 기본 함수를 숨기기만 한다. 하지만 override를 사용하면 컴파일 에러가 난다. 지정자 final은 파생 클래스에서 재정의할 수 없는 가상 함수를 지정한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Base { public: virtual void Function(int ch) const // int형 매개변수 { cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: virtual void Function(int* ch) const // int*형 매개변수 (다르다) { cout \u0026lt;\u0026lt; \u0026#34;Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { int num = 1; Derived d; d.Function(\u0026amp;num); // (O) Derived의 Function이 Base의 Function를 숨긴다. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Base { public: virtual void Function(int ch) const // int형 매개변수 { cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: // (X) override 지정자를 사용했다. 매개변수가 기본 함수와 달라서 컴파일 에러가 난다. virtual void Function(int* ch) const override { cout \u0026lt;\u0026lt; \u0026#34;Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base { public: virtual void Function(int ch) const final // final 지정자 { cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: virtual void Function(int ch) const // (X) final인 함수를 오버라이드할 수 없다. { cout \u0026lt;\u0026lt; \u0026#34;Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; ","date":"2022-03-27T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-18-1/","title":"[C++ Primer Plus] Chapter 18. (1) Move Semantics와 rvalue참조, 새로운 클래스 형태"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n알고리즘(algorithm) 알고리즘 컨테이너와 함께 사용할 수 있는 멤버가 아닌 함수들이다. 알고리즘 함수를 설계하는 주요 두 가지 일반화 성분들이 있다. 일반형을 제공하기 위해 템플릿을 사용한다. 컨테이너에 들어 있는 데이터에 접근하기 위한 일반화 표현을 제공하기 위해 이터레이터를 사용한다. STL은 알고리즘 라이브러리를 네 그룹으로 나눈다. 처음 세 그룹은 algorithm 헤더 파일, 네 번째 그룹은 numeric 헤더 파일에 정의되어 있다. (1) 변경 불가 시퀀스 연산 어떤 범위에 들어 있는 각 원소에 작용한다. 이 연산은 컨테이너를 변경하지 않는다. find(), for_each() (2) 변경 가능 시퀀스 연산 어떤 범위에 들어 있는 각 원소에 작용한다. 이 연산은 컨테이너를 변경한다. transform(), random_shuffle(), copy() (3) 정렬 및 그와 관련된 연산 sort() (4) 일반화한 수치 연산 어떤 범위에 있는 내용들을 더하고, 두 컨테이너의 내적, 부분합, 인접차를 계산하는 등의 함수들이 있다. 일반적으로 이 연산들은 배열의 특성을 가지므로 vector 컨테이너가 가장 잘 어울린다. 이터레이터와 이터레이터 범위를 사용한다. 템플릿 매개변수와 이름을 통해 그 매개변수가 모델링하는 개념을 나타낸다. 따라서 아래 선언에 따르면, 범위 매개변수들이 입력 이터레이터 또는 그 이상이 되어야 하며, 결과를 넣을 위치를 나타내는 이터레이터가 출력 이터레이터 그 이상이 되어야 한다는 사실을 알 수 있다. 1 2 template\u0026lt;class InputIterator, class OutputIterator\u0026gt; OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result); 알고리즘을 분류하는 또 다른 방법은, 알고리즘의 결과가 제자리에 놓이는지, 아니면 새로운 곳에 놓이는지에 따라 분류하는 것이다. (1) 제자리 알고리즘(in-place algorithm) (2) 복사 알고리즘(copying algorithm) 예를 들어, sort()함수는 결과가 오리지널 데이터가 있던 곳에 그대로 위치하기 때문에 제자리 알고리즘(in-place algorithm)이다. 그러나 copy()함수는 결과가 다른 위치에 저장되므로, 복사 알고리즘(copying algorithm)이다. transform()함수는 둘 다 가능하다. 어떤 함수는 두 가지 버전을 갖고 있다. 복사 버전은 이름에 _copy를 붙이는 것이 관행이다. 예를 들어, replace()함수가 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;class ForwardIterator, class T\u0026gt; void replace(ForwardIterator first, ForwardIterator last, const T\u0026amp; old_value, const T\u0026amp; new_value); // 제자리 알고리즘. // old_value의 각 인스턴스를 new_value로 바꾼다. template\u0026lt;class InputIterator, class OutputIterator, class T\u0026gt; OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T\u0026amp; old_value, const T\u0026amp; new_value); // 복사 알고리즘. // 복사 알고리즘의 관행은, // 마지막으로 복사된 값 바로 다음 위치를 지시하는 이터레이터를 리턴하는 것이다. 일부 함수들은 조건부에 따라 동작을 수행하는 버전을 가진다. 함수 이름에 if를 붙이는 것이 관행이다. 1 2 3 4 5 template\u0026lt;class ForwardIterator, class Predicate, class T\u0026gt; void replace(ForwardIterator first, ForwardIterator last, Predicate pred, const T\u0026amp; new_value); // 조건(predicate)은 bool값을 리턴하는 단항 함수이다. STL과 string 클래스 string 클래스는 STL을 염두해 두고 설계되어 있다. 그래서 STL 인터페이스를 사용할 수 있다. 예를 들어, next_permutation() 함수를 사용해서 글자들이 형성하는 순열을 만들 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 string letters; cout \u0026lt;\u0026lt; \u0026#34;글자를 입력하세요. (quit to quit): \u0026#34;; while (cin \u0026gt;\u0026gt; letters \u0026amp;\u0026amp; letters != \u0026#34;quit\u0026#34;) { cout \u0026lt;\u0026lt; letters \u0026lt;\u0026lt; \u0026#34;의 모든 치환들: \u0026#34; \u0026lt;\u0026lt; endl; sort(letters.begin(), letters.end()); cout \u0026lt;\u0026lt; letters \u0026lt;\u0026lt; endl; // next_permutation은 더 큰 순열로 재배열을 할 수 있으면 반복하여 구해내는 구조이므로 // 앞에 이미 큰 원소들이 배치되어 있으면 반복하지 않게 된다. // 따라서 오름차순으로 정렬을 해준다. while (next_permutation(letters.begin(), letters.end())) cout \u0026lt;\u0026lt; letters \u0026lt;\u0026lt; endl; // next_permutation은 범위에 있는 내용의 고유한 그 다음 순열을 제공한다. cout \u0026lt;\u0026lt; \u0026#34;다음 글자를 입력하세요. (quit to quit): \u0026#34;; } STL 메서드와 STL 함수 중에서 어느 것을 사용해야 할까? 일반적으로 메서드가 더 낫다. 그 이유는\u0026hellip; 특별한 컨테이너를 위해 최적화되어있기 때문이다. 멤버 함수이기 때문에 템플릿 클래스의 메모리 관리 기능을 이용할 수 있고, 필요한 경우 컨테이너 크기를 조절할 수 있다. 예를 들어, remove() 메서드와 함수를 비교해 볼 수 있겠다. remove 함수는 멤버가 아니라서 크기를 조절할 수 없다. 대신에 남아 있는 원소들을 리스트의 앞쪽에다 놓는다. 그리고 남아 있는 원소들의 새로운 past-the-end을 지시하는 이터레이터를 리턴한다. 이 이터레이터를 사용해서 리스트의 크기를 조절할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // remove 메서드 사용 list\u0026lt;int\u0026gt; li = {1, 4, 1, 4, 4, 4}; li.remove(4); cout \u0026lt;\u0026lt; li.size() \u0026lt;\u0026lt; endl; // 크기가 자동으로 줄어들어서 2 // remove 함수 사용 list\u0026lt;int\u0026gt; li2 = {1, 4, 1, 4, 4, 4}; list\u0026lt;int\u0026gt;::iterator last; last = remove(li2.begin(), li2.end(), 4); cout \u0026lt;\u0026lt; li2.size() \u0026lt;\u0026lt; endl; // 크기가 그대로 6 li2.erase(last, li2.end()); // 뒤를 지운다. cout \u0026lt;\u0026lt; li2.size() \u0026lt;\u0026lt; endl; // 크기가 2 STL 사용하기 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 char toLower(char ch) { return tolower(ch); } string\u0026amp; ToLower(string\u0026amp; st) { transform(st.begin(), st.end(), st.begin(), toLower); return st; } void display(const string\u0026amp; s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { // vector 컨테이너: 입력을 저장한다. vector\u0026lt;string\u0026gt; words; cout \u0026lt;\u0026lt; \u0026#34;단어 입력 (enter quit to quit) :\\n\u0026#34;; string input; while (cin \u0026gt;\u0026gt; input \u0026amp;\u0026amp; input != \u0026#34;quit\u0026#34;) words.push_back(input); cout \u0026lt;\u0026lt; \u0026#34;다음과 같은 단어들을 입력하셨습니다. :\\n\u0026#34;; for_each(words.begin(), words.end(), display); cout \u0026lt;\u0026lt; endl; // set 컨테이너: 유일하며, 순서대로 저장되는 단어들. set\u0026lt;string\u0026gt; wordset; transform(words.begin(), words.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(wordset, wordset.begin()), ToLower); cout \u0026lt;\u0026lt; \u0026#34;\\n단어들의 알파벳순 리스트 :\\n\u0026#34;; for_each(wordset.begin(), wordset.end(), display); cout \u0026lt;\u0026lt; endl; // map 컨테이너: 키를 단어로 하고, 값을 단어의 빈도로 한다. map\u0026lt;string, int\u0026gt; wordmap; set\u0026lt;string\u0026gt;::iterator si; for (si = wordset.begin(); si != wordset.end(); si++) wordmap[*si] = count(words.begin(), words.end(), *si); cout \u0026lt;\u0026lt; \u0026#34;\\n단어별 빈도 :\\n\u0026#34;; for (si = wordset.begin(); si != wordset.end(); si++) cout \u0026lt;\u0026lt; *si \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; wordmap[*si] \u0026lt;\u0026lt; endl; } 기타 라이브러리 vector와 valarray 그리고 array valarray STL의 일부가 아니다. 자동 크기 조절이 안 된다. 그리고 삽입, 정렬, 검색 등과 같은 것들을 하기 위한 메서드가 없다. 하지만 수학 연산에 대한 명쾌한 표기상의 이점을 가지고 있다. array 기존 배열형을 대체하기 위해 설계되었다. 다양한 STL 메서드들을 지원한다. 따라서 알고리즘을 쉽게 적용할 수 있다. vector 컨테이너 클래스와 알고리즘으로 구성되었다. 정렬, 삽입, 재배치, 검색, 다른 컨테이너로의 데이터 전송 등과같은 컨테이너 지향적인 액티비티를 지원한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 vector\u0026lt;int\u0026gt; vec = { 1, 2, 5, 4, 3 }; int temp; int size = vec.size(); valarray\u0026lt;int\u0026gt; valArr(size); for (int i = 0; i \u0026lt; size; i++) // vector의 내용을 valarray로 옮긴다. valArr[i] = vec[i]; // vector는 정렬 알고리즘 sort()를 사용할 수 있다. sort(vec.begin(), vec.end()); // C++11에서는 이렇게 valarray에 sort()를 사용할 수 있다. sort(begin(valArr), end(valArr)); // valarray는 간단하게 한 문장으로 배열을 연산할 수 있다. valarray\u0026lt;int\u0026gt; sq_rts(size); sq_rts = sqrt(valArr); valarray\u0026lt;int\u0026gt; results(size); results = valArr + 2 * sq_rts; // vector는 이런 방식으로 해야된다. vector\u0026lt;int\u0026gt; result(size); transform(vec.begin(), vec.end(), result.begin(), bind1st(plus\u0026lt;int\u0026gt;(), 2)); slice() 객체는 배열 인덱스로 사용할 수 있다. 일반적으로 하나의 값이 아니라, 값들로 이루어진 부분 집합을 나타낸다. 세 개의 정수 start, number, stride 값으로 초기화된다. 첫 인덱스인 start부터 시작해서 stride 값을 더하면서 총 number 개의 원소를 뽑아낸다. 이것은 1차원 valarray 객체를 사용해서 2차원 데이터를 나타내는 것을 허용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // valarray를 출력한다. // cols는 열의 개수이다. 이 개수에 따라 띄어쓴다. void show(const valarray\u0026lt;int\u0026gt;\u0026amp; v, int cols) { int lim = v.size(); for (int i = 0; i \u0026lt; lim; ++i) { cout.width(3); cout \u0026lt;\u0026lt; v[i]; if (i % cols == cols - 1) cout \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } if (lim % cols != 0) cout \u0026lt;\u0026lt; endl; } int main() { valarray\u0026lt;int\u0026gt; valint = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; // 4행 3열로 생각한다. cout \u0026lt;\u0026lt; \u0026#34;원래의 배열 :\\n\u0026#34;; show(valint, 3); // 3열로 출력한다. valarray\u0026lt;int\u0026gt; vcol(valint[slice(1, 4, 3)]); // 1, 4, 7, 10이며 이것은 두 번째 열이다. cout \u0026lt;\u0026lt; \u0026#34;2열을 출력한다. :\\n\u0026#34;; show(vcol, 1); // 1열로 출력한다. valarray\u0026lt;int\u0026gt; vrow(valint[slice(3, 3, 1)]); // 3, 4, 5이며 이것은 두 번째 행이다. cout \u0026lt;\u0026lt; \u0026#34;2행을 출력한다. :\\n\u0026#34;; show(vrow, 3); valint[slice(2, 4, 3)] = 10; // 2, 5, 8, 11이며 이것은 세 번째 열이다. cout \u0026lt;\u0026lt; \u0026#34;3열을 10으로 설정한다. :\\n\u0026#34;; show(valint, 3); cout \u0026lt;\u0026lt; \u0026#34;1열의 2열과 3열의 합으로 만든다. :\\n\u0026#34;; valint[slice(0, 4, 3)] // 0, 3, 6, 9 즉 1열을 2열과 3열의 합으로 만든다. = valarray\u0026lt;int\u0026gt;(valint[slice(1, 4, 3)]) + valarray\u0026lt;int\u0026gt;(valint[slice(2, 4, 3)]); show(valint, 3); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 원래의 배열 : 0 1 2 3 4 5 6 7 8 9 10 11 2열을 출력한다. : 1 4 7 10 2행을 출력한다. : 3 4 5 3열을 10으로 설정한다. : 0 1 10 3 4 10 6 7 10 9 10 10 1열의 2열과 3열의 합으로 만든다. : 11 1 10 14 4 10 17 7 10 20 10 10 initializer_list 템플릿 (C++11) 컨테이너 클래스가 initializer_list\u0026lt;T\u0026gt; 매개변수를 취하는 생성자를 지녔기 때문에 다음과 같은 초기화가 가능해진다. 만약 클래스가 다양한 크기의 리스트를 처리하지 못할 경우에는 initializer_list 생성자를 제공하는 것은 부적합하다. 1 2 3 4 5 6 7 8 9 10 vector\u0026lt;double\u0026gt; vec1 {1.2, 3.2, 4.4}; // (O) // 위의 코드는 다음과 같이 동작하는 것이다. vector\u0026lt;double\u0026gt; vec1 ({1.2, 3.2, 4.4}); vector\u0026lt;int\u0026gt; vec2(10) // 원소 10개를 가진 벡터를 생성한다. vector\u0026lt;int\u0026gt; vec3{10} // 10이라는 원소 1개를 가진 벡터를 생성한다. vector\u0026lt;int\u0026gt; vec4{ 1.2 }; // (X) narrowing. 컴파일링 시간 에러 발생. vector\u0026lt;double\u0026gt; vec5{ 1 }; // (O) 1은 double인 1.0으로 전환된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Position { private: int x, y, z; public: Position(int nx, int ny, int nz) : x(nx), y(ny), z(nz) {} // 고정된 크기이므로 initializer_list 생성자가 없다. }; int main() { Position p{ 1, 2, 3 }; // (O) Position(int, int, int) 생성자를 호출한다. } initializer_list 사용 예제 begin(), end(), size()를 갖고 있다. 이터레이터형은 상수형이므로 목록 안의 값을 바꿀 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 double Sum(initializer_list\u0026lt;double\u0026gt; il) { double tot = 0; for (auto p = il.begin(); p != il.end(); p++) tot += *p; return tot; } double Average(const initializer_list\u0026lt;double\u0026gt;\u0026amp; ril) { double tot = 0; int n = ril.size(); double ave = 0.0; if (n \u0026gt; 0) { for (auto p = ril.begin(); p != ril.end(); p++) tot += *p; ave = tot / n; } return ave; } int main() { cout \u0026lt;\u0026lt; \u0026#34;목록 1: Sum = \u0026#34; \u0026lt;\u0026lt; Sum({ 2,3,4 }) \u0026lt;\u0026lt; \u0026#34;, Ave = \u0026#34; \u0026lt;\u0026lt; Average({ 2,3,4 }) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; initializer_list\u0026lt;double\u0026gt; dl = { 1.1, 2.2, 3.3, 4.4, 5.5 }; cout \u0026lt;\u0026lt; \u0026#34;목록 2: Sum = \u0026#34; \u0026lt;\u0026lt; Sum(dl) \u0026lt;\u0026lt; \u0026#34;, Ave = \u0026#34; \u0026lt;\u0026lt; Average(dl) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; dl = { 16.0, 25.0, 36.0, 40.0, 64.0 }; // 대입 가능 cout \u0026lt;\u0026lt; \u0026#34;목록 3: Sum = \u0026#34; \u0026lt;\u0026lt; Sum(dl) \u0026lt;\u0026lt; \u0026#34;, Ave = \u0026#34; \u0026lt;\u0026lt; Average(dl) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2022-03-25T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-16-5/","title":"[C++ Primer Plus] Chapter 16. (5) STL - 알고리즘, 기타 라이브러리"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n함수 객체(functor) 펑크터 함수처럼 ()와 함께 사용할 수 있는 객체이다. 일반 함수, 함수를 지시하는 포인터, ()가 오버로딩된 클래스 객체가 모두 펑크터가 될 수 있다. 펑크터 개념 제너레이터(generator) 매개변수 없이 호출하는 함수 단항 함수(unary function) 하나의 매개변수로 호출하는 함수 이항 함수(binary function) 두 개의 매개변수로 호출하는 함수 펑크터 개념의 개량 조건(predicate) bool값을 리턴하는 단항 함수 이항 조건(binary predicate) bool값을 리턴하는 이항 함수 list는 하나의 조건을 매개변수로 받아들이는 remove_if() 멤버를 가진다. 이것은 각 멤버에 조건을 적용해서 조건이 true를 리턴하는 모든 원소들을 삭제한다. 기준과, 원소의 값 두 가지 매개변수를 전달하지 못한다. 하지만 클래스 펑크터를 사용하면 기준이 되는 매개변수를 생성자로 미리 전달할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 template\u0026lt;class T\u0026gt; // 펑크터 클래스가 operator()()를 정의한다. class TooBig { private: T cutoff; public: TooBig(const T\u0026amp; t) : cutoff(t) {} bool operator()(const T\u0026amp; v) { return cutoff \u0026lt; v; // cutoff보다 크면 true } }; void OutInt(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { TooBig\u0026lt;int\u0026gt; f100(100); // 100초과의 것들은 true list\u0026lt;int\u0026gt; yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; list\u0026lt;int\u0026gt; etcetera = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201}; cout \u0026lt;\u0026lt; \u0026#34;원래의 리스트:\\n\u0026#34;; for_each(yadayada.begin(), yadayada.end(), OutInt); cout \u0026lt;\u0026lt; endl; for_each(etcetera.begin(), etcetera.end(), OutInt); cout \u0026lt;\u0026lt; endl; yadayada.remove_if(f100); // 선언된 함수 객체 etcetera.remove_if(TooBig\u0026lt;int\u0026gt;(200)); // 익명의 함수 객체 // 200초과의 것들은 true. 다 지운다. cout \u0026lt;\u0026lt; \u0026#34;정비된 리스트:\\n\u0026#34;; for_each(yadayada.begin(), yadayada.end(), OutInt); cout \u0026lt;\u0026lt; endl; for_each(etcetera.begin(), etcetera.end(), OutInt); cout \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 원래의 리스트: 50 100 90 180 60 210 415 88 188 201 50 100 90 180 60 210 415 88 188 201 정비된 리스트: 50 100 90 60 88 50 100 90 180 60 88 188 두 개의 매개변수를 사용하는 템플릿 함수를 이미 가지고 있다면, 클래스를 사용해서 이것을 하나의 매개변수를 사용하는 함수 객체로 변환할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;class T\u0026gt; bool tooBig(const T\u0026amp; val, const T\u0026amp; lim) { return val \u0026gt; lim; } template\u0026lt;class T\u0026gt; class TooBig2 // 함수 어댑터이다. tooBig함수를 다른 인터페이스에 맞게 개조시킨다. { private: T cutoff; public: TooBig2(const T\u0026amp; t) : cutoff(t) {} bool operator()(const T\u0026amp; v) { return tooBig\u0026lt;T\u0026gt;(v, cutoff); // tooBig 함수를 사용한다. } }; 미리 정의된 펑크터 STL은 몇 가지 기본적인 펑크터들을 정의한다. 그것들은 함수를 매개변수로 취하는 STL 함수들을 지원하기 위해 제공된다. 예를 들어, transform()함수를 생각해 보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;functional\u0026gt; //... plus\u0026lt;int\u0026gt; add; // plus\u0026lt;int\u0026gt; 객체를 생성한다. int result = add(1, 4); // plus\u0026lt;int\u0026gt;::operator()()를 사용한다. vector\u0026lt;double\u0026gt; vec = { 36, 39, 42, 45, 48 }; vector\u0026lt;double\u0026gt; vec2 = { 1, 2, 3, 4, 5 }; ostream_iterator\u0026lt;double, char\u0026gt; out(cout, \u0026#34; \u0026#34;); transform(vec.begin(), vec.end(), vec2.begin(), out, plus\u0026lt;double\u0026gt;()); // 익명의 plus\u0026lt;double\u0026gt; 함수 객체를 만들어서 사용했다. // vec의 0~4와 vec2의 0~4의 원소를 각각 더해서 화면에 출력한다. 내장 연산자들과 동등한 펑크터들 이것은 모두 순응성(adaptable)이다. 연산자 동등한 펑크터 + plus - minus * multiplies / divides % modulus - negate == equal_to != not_equal_to \u0026gt; grater \u0026lt; less \u0026gt;= grater_equal \u0026lt;= less_equal \u0026amp;\u0026amp; logical_and || logical_or ! logical_not 순응성(adaptable) 매개변수형과 리턴형을 식별하는 typedef멤버를 가지는 것이다. 그 멤버들은 result_type, first_argument_type, second_argument_type 등이 있다. 예를 들어, plus\u0026lt;int\u0026gt; 객체의 리턴형은 plus\u0026lt;int\u0026gt;::result_type이다. 펑크터가 순응성이면, 함수 어댑터 객체가 펑크터를 사용할 수 있다. 예를 들어, multiplies는 이항 함수이다. 따라서 하나의 매개변수만 제공하는 아래와 같은 코드는 동작하지 않는다. 그래서 두 개의 매개변수를 사용하는 펑크터를 하나의 매개변수를 사용하는 펑크터로 변환하는, 함수 어댑터가 필요하다. STL은 순응성 이항 함수를 순응성 단항 함수로 변환하는 binder1st와 binder2nd 클래스를 제공한다. 그리고 이것을 간소화한 bind1st, bind2nd 함수를 제공한다. bind1st는 제 1 매개변수를 제공한다. bind2nd는 제 2 매개변수를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vector\u0026lt;double\u0026gt; vec = { 36, 39, 42, 45, 48 }; ostream_iterator\u0026lt;double, char\u0026gt; out(cout, \u0026#34; \u0026#34;); transform(vec.begin(), vec.end(), out, multiplies\u0026lt;double\u0026gt;()); // (X) // vec만 가지고는 곱셈을 할 수 없다. binder1st\u0026lt;multiplies\u0026lt;double\u0026gt;\u0026gt; b1 = binder1st\u0026lt;multiplies\u0026lt;double\u0026gt;\u0026gt;(multiplies\u0026lt;double\u0026gt;(), 2.5); transform(vec.begin(), vec.end(), vec.begin(), b1); // (O) // binder1st 함수 어댑터 객체를 만들어서 // 이항 함수 multiplies를 단항 함수로 만들었다. transform(vec.begin(), vec.end(), out, bind1st(multiplies\u0026lt;double\u0026gt;(), 2.5)); // (O) // bind1st 함수는 좀 더 간편하게 사용할 수 있다. // vec은 제 2 매개변수이다. // bind1st( 2항 함수, 제 1 매개변수 ) // vec의 원소들과 bind1st에 제공된 제 1 매개변수를 곱한값을 출력한다. ","date":"2022-03-25T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-16-4/","title":"[C++ Primer Plus] Chapter 16. (4) STL - 함수 객체"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n컨테이너(container) 컨테이너 개념\n모든 STL 컨테이너 클래스들이 충족시켜야 하는 요구 사항의 집합 기본 컨테이너의 특성\nX vector\u0026lt;int\u0026gt; T int a, b vector\u0026lt;int\u0026gt;의 값 r vector\u0026lt;int\u0026gt;\u0026amp;의 값 u vector\u0026lt;int\u0026gt;의 객체 vec 비례 시간 원소 수에 비례한다는 것을 의미한다. 표현 리턴형 설명 복잡성 X::iterator T를 지시하는 이러레이터형 출력 이터레이터를 제외한 모든 이터레이터들 컴파일 시간 X::value_type T T에 해당하는 데이터형 컴파일 시간 X u; 크기가 0인 u라는 컨테이너 생성 고정 시간 X(); 크기가 0인 익명의 컨테이너 생성 고정 시간 X u(a); 복사 생성자 수행이 후 u == a 비례 시간 X u = a; X u(a);와 같다 비례 시간 r = a; X\u0026amp; 복사 대입 수행 이후, r == a 비례 시간 (\u0026amp;a)-\u0026gt;~X(); void 컨테이너의 모든 원소에 파괴자를 적용한다. 비례 시간 a.begin() 이터레이터 컨테이너의 첫 번째 원소를 지시하는 이터레이터를 리턴한다. 고정 시간 a.end() 이터레이터 past-the-end값인 이터레이터를 리턴한다. 고정 시간 a.size() unsigned 정수형 a.end() - a.begin()과 같은 원소 수 고정 시간 a.swap(b) a와 b의 내용을 맞바꾼다. 고정 시간 a == b bool로 변환할 수 있는\n데이터형 a와 b의 크기가 같고, a에 있는 각 원소가 b에 있는 대응하는 원소와 등가이면\n(==가 true이면) true 비례 시간 a != b bool로 변환할 수 있는\n데이터형 !(a -- b)와 같다. 비례 시간 C++11에서 추가 요구 사항 rv 상수가 아닌 vector\u0026lt;int\u0026gt;\u0026amp;의 값 표현 리턴형 설명 복잡성 X u(rv); 생성자 포스트 조건을 이동시킨다. u는 생성전에 rv가 지녔던 값을 지닌다. 선형 X u = rv; X u(rv)와 동일한 효과 선형 a = rv; X\u0026amp; 대입 포스트 조건을 이동시킨다. a는 대입 이전에 rv가 지녔던 값을 지닌다. 선형 a.cbegin() const_iterator 컨테이너의 첫 번째 요소를 지칭하는 const 이터레이터를 리턴한다. 상수 a.cend() const_iterator 최종값인 const이터레이터를 리턴한다. 상수 컨테이너의 종류 1. 시퀀스 컨테이너 데이터를 선형으로 저장한다. 2. 결합 컨테이너 데이터를 키와 값으로 저장한다. 3. 컨테이너 어댑터 앞의 두 컨테이너를 변형하여 인터페이스를 제한한다. 이터레이션을 허용하지 않는다. 시퀀스 컨테이너(sequence container) STL의 컨테이너 형 중에서 다음은 컨테이너들은 시퀀스이다. vector, deque, list, forward_list (C++11), queue, priority_queue, stack 시퀀스는 최소한의 이터레이터가 늘 전방 이터레이터이다. 따라서 이터레이션이 이루어질 때마다 변하지 않는 명확한 순서로 원소들이 배치되는 것을 보장한다. 또한, 원소들이 직선 순서로 배치된다. 시퀀스 요구 사항 t T형의 값. int의 값. n 정수 p, q, i, j 이터레이터 표현 리턴형 설명 X a(n, t) n개의 값 t로 이루어진 시퀀스 a를 선언한다. X(n, t) n개의 값 t로 이루어진 익명 시퀀스를 선언한다. X a(i, j) [i, j) 범위의 내용으로 초기화된 시퀀스 a를 선언한다. X(i, j) [i, j) 범위의 내용으로 초기화된 익명 시퀀스를 선언한다. a.insert(p, t) 이터레이터 p앞에 t의 복사본을 삽입한다. a.insert(p, n, t) void p앞에 t의 복사본을 n개 삽입한다. a.insert(p, i, j) void p앞에 [i, j) 범위에 있는 원소들의 복사본을 삽입한다. a.erase(p) 이터레이터 p가 지시하는 원소를 삭제한다. a.erase(p, q) 이터레이터 [p, q) 범위에 있는 원소들을 삭제한다. a.clear() void erase(begin(), end())와 같다. 선택적 시퀀스 요구 사항 모두 고정 시간 복잡도를 가진다. 표현 리턴형 의미 컨테이너 a.front() T\u0026amp; *a.begin() vector, list, deque a.back() T\u0026amp; *--a.end() vector, list, deque a.push_front(t) void a.insert(a.begin(), t) list, deque a.push_back(t) void a.insert(a.end(), t) vector, list, deque a.pop_front(t) void a.erase(a.begin()) list, deque a.pop_back(t) void a.erase(--a.end()) vector, list, deque a[n] T\u0026amp; *(a.begin() + n) vector, deque a.at(n) T\u0026amp; *(a.begin() + n) (n이 경계를 벗어나면, out_of_range예외 발생) vector, deque vector 컨테이너 이것은 시퀀스이기도 하지만 가역성 컨테이너(reversible container)이기도 하다. 따라서 rbegin(), rend() 두 개의 메서드가 더 추가된다. 말미에서는 고정 시간 연산으로 삽입과 삭제가 가능하지만, 다른 위치에서는 비례 시간 연산으로 가능하다. 임의 접근을 통한 빠른 접근을 강조한다. deque 컨테이너 double-ended queue의 줄임말이며, 양쪽에 끝이 있는 큐이다. 덱이라고 발음한다. 양쪽 끝에서 고정 시간 연산으로 삽입과 삭제를 할 수 있도록 한다. list 컨테이너 이중 링크드 리스트이다. 어느 위치든지 고정 시간 연산으로 삽입과 삭제가 가능하다. 따라서 신속한 삽입과 삭제를 강조한다. 이 또한 가역성 컨테이너(reversible container)이다. 하지만 vector와는 다르게 배열 표기와 임의 접근을 지원하지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 list\u0026lt;int\u0026gt; fives(3, 5); // {5, 5, 5} int stuff[7] = {1, 2, 3, 4, 5, 5, 3}; list\u0026lt;int\u0026gt; result; result.insert(result.begin(), stuff, stuff + 7); // stuff의 0~6를 result에 삽입 for_each(result.begin(), result.end(), output); cout \u0026lt;\u0026lt; endl; result.remove(5); // {1, 2, 3, 4, 3} 모든 5를 없앤다. result.splice(result.begin(), fives); // {5, 5, 5, 1, 2, 3, 4, 3} // fives의 모든 내용이 result.begin() 앞에 삽입된다. // 결과로, fives는 비게 된다. result.unique(); // {5, 1, 2, 3, 4, 3} 연속된 중복을 제거한다. result.sort(); // {1, 2, 3, 3, 4 5} 정렬한다. sort(result.begin(), result.end()); // (X) // 멤버가 아닌 sort()도 있다. // 하지만 이것은 임의 접근 이터레이터를 요구한다. 따라서 리스트와 사용할 수 없다. list\u0026lt;int\u0026gt; fours(3, 4); // {4, 4, 4} result.merge(fours); // {1, 2, 3, 4, 4, 4, 4, 5} 정렬되어 있는 두 리스트를 합친다. forward_list 컨테이너 (C++11) 단순 링크드 리스트이다. 전방 이터레이터만 필요하다. 양방향은 필요하지 않다. queue 컨테이너 어댑터 클래스. 임의 접근이 안 되며, 큐를 훑는 이터레이션을 허용하지 않는다. priority_queue 컨테이너 어댑터 클래스. 큐와 같지만, 가장 큰 항목이 큐의 선두로 나간다. 내부적으로 다른 점은, 기초가 되는 디폴트 클레스가 vector이라는 점이다. 선택적 매개변수를 제공한다. 이것으로 어떤 것을 선두로 내보낼지 결정할 수 있다. 1 2 priority_queue\u0026lt;int\u0026gt; pq1; priority_queue\u0026lt;int\u0026gt; pq2(greater\u0026lt;int\u0026gt;); // greater\u0026lt;int\u0026gt;를 우선 배치한다. stack 컨테이너 어댑터 클래스. 기초가 되는 디폴트 클래스가 vector이다. 임의 접근이 안 되며, 스택을 훑는 이터레이션을 허용하지 않는다. array 템플릿 클래스 고정된 크기를 지니기 때문에 STL 컨테이너는 될 수 없다. copy(), for_each()와 같은 표준 STL 알고리즘을 사용할 수 있다. 결합 컨테이너(associative container) set, multiset, map, multimap 컨테이너 개념의 또 다른 개량이다. 값에 키(key)를 결합하고, 그 키를 사용해서 값을 찾는다. X::key_type 키로 사용되는 데이터형 특정 위치에 삽입할 수 없다. 왜냐하면, 정보를 신속하게 검색할 수 있도록 데이터의 배치를 결정하는 특별한 알고리즘을 사용하기 때문이다. 전형적으로 트리 구조를 이용하여 구현된다. 따라서 list와 비교했을 때, 검색이 월등히 빠르다. set 컨테이너 키와 값의 데이터형이 같다. 키당 하나의 값만 가지므로 키는 고유하다. 즉, 키가 곧 값이다. 가역성이며 정렬된다. 키를 배치하는 데 사용되는 비교함수나 객체를 추가적인 매개변수로 제공할 수 있다. 디폴트는 less\u0026lt;\u0026gt; 템플릿이 사용된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 void output(const string\u0026amp; s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } //... set\u0026lt;string\u0026gt; s1; et\u0026lt;string, less\u0026lt;string\u0026gt;\u0026gt; s2; string stra[5] = {\u0026#34;B\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;C\u0026#34; }; set\u0026lt;string\u0026gt; a(stra, stra + 5); // strs 0~4범위로 a를 초기화한다. // 정렬된다. 그리고 키와 값은 고유하다. // 따라서 결과는 {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;} 이다. string strb[5] = {\u0026#34;E\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;F\u0026#34; }; set\u0026lt;string\u0026gt; b(strb, strb + 5); set\u0026lt;string\u0026gt; uni; set_union(a.begin(), a.end(), b.begin(), b.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(uni, uni.begin())); // a와 b의 합집함을 uni에 저장한다. // insert_iterator가 이것을 가능하게 한다. // c.begin()만 넣으면, 안된다. // 이유1. 키는 상수이다. 따라서 c.begin()은 상수 이터레이터이다. // 그래서 출력 이터레이터로 사용할 수 없다. (쓸 수 없다.) // 이유2. c는 비어 있다. 데이터를 넣을 충분한 공간이 없다. // {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34; }; set\u0026lt;string\u0026gt; inter; set_intersection(a.begin(), a.end(),b.begin(), b.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(inter, inter.begin())); // a와 b의 교집합 // {\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;} set\u0026lt;string\u0026gt; dif; set_difference(a.begin(), a.end(),b.begin(), b.end(), insert_iterator\u0026lt;set\u0026lt;string\u0026gt;\u0026gt;(dif, dif.begin())); // a와 b의 차집합 // {\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;} string stuff = \u0026#34;Apple\u0026#34;; a.insert(stuff); // {\u0026#34;A\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;} 원소를 삽입한다. for_each(a.lower_bound(\u0026#34;Apple\u0026#34;), a.upper_bound(\u0026#34;C\u0026#34;), output); // {\u0026#34;Apple\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;} 출력 // lower_bound는 매개변수 이상의 것 중 가장 작은 멤버를 지시하는 이터레이터를 리턴한다. // upper_bound는 매개변수 초과의 것 중 가장 큰 멤버를 지시하는 이터레이터를 리턴한다. multiset 컨테이너 set과 비슷하다. 다른 점은, 하나의 키가 다양한 값과 결합될 수 있다. map 컨테이너 키와 값의 데이터형이 다르다. 키당 하나의 값만 가지므로 키는 고유하다. multimap 컨테이너 map과 비슷하다. 다른 점은, 하나의 키가 다양한 값과 결합될 수 있다. 가역성이며 정렬된다. 키를 배치하는 데 사용되는 비교함수나 객체를 추가적인 매개변수로 제공할 수 있다. 디폴트는 less\u0026lt;\u0026gt; 템플릿이 사용된다. 키와 값을 하나의 쌍으로 결합하기 위해서 pair\u0026lt;class T, class U\u0026gt; 템플릿 클래스를 사용한다. `pair\u0026lt;class keytype, class datatype\u0026gt;이 되겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 multimap\u0026lt;int, string\u0026gt; codes; codes.insert({415, \u0026#34;샌프란시스코\u0026#34;}); codes.insert({510, \u0026#34;오클랜드\u0026#34;}); codes.insert({718, \u0026#34;브루클린\u0026#34;}); codes.insert({718, \u0026#34;스태튼 섬\u0026#34;}); cout \u0026lt;\u0026lt; codes.count(718) \u0026lt;\u0026lt; endl; // count는 키가 718인 값의 개수를 출력한다: 2 multimap\u0026lt;int, string\u0026gt;::iterator it; for (it = codes.begin(); it != codes.end(); ++it) cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; // first, second로 키, 값에 접근할 수 있다. typedef multimap\u0026lt;int, string\u0026gt;::iterator mapIter; pair\u0026lt;mapIter, mapIter\u0026gt; range = codes.equal_range(718); // equal_range은 키가 718인 범위를 나타내는 이터레이터 쌍을 리턴한다. for (it = range.first; it != range.second; ++it) cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; // range에 있는 데이터를 출력한다. 순서가 부여되지 않은 결합 컨테이너(unordered associative container) (C++11) 결합 컨테이너처럼 키와 값을 결합하고 키를 사용해 값을 찾는다. 다른 점은, 결합 컨테이너는 트리 구조에 기반을 두지만, 이것은 hash table에 기반을 둔다. unordered_set, unordered_multiset, unordered_map, unordered_multimap ","date":"2022-03-24T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-16-3/","title":"[C++ Primer Plus] Chapter 16. (3) STL - 컨테이너"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n표준 템플릿 라이브러리 표준 템플릿 라이브러리(STL; Standard Template Library) 객체 지향이 아니다. 일반화 프로그래밍(generic programming)이라는 패러다임을 나타낸다. 1. 컨테이너(container) 배열 같이, 여러 개의 값을 저장할 수 있는 구성 단위. 2. 알고리즘(algorithm) 배열을 정렬하거나, 리스트에서 특정 값을 검색하는 것과 같이, 특별한 작업들을 수행하기 위한 방법. 3. 이터레이터(iterator) 배열 안에서 포인터를 사용해서 위치를 옮기듯이, 컨테이너 안에서 위치를 옮길 수 있도록 도와주는 객체. 즉, 포인터의 일반화이다. 4. 함수 객체(function object) 함수와 비슷한 역할을 하는 객체. 클래스 일수도 있고, 함수 포인터일 수도 있다. vector 컨테이너 클래스 vector 컨테이너 클래스 vector 헤더파일에 정의되어 있다. 1 2 3 4 5 6 7 // 메모리 관리에 사용할 allocator 객체를 선택적으로 지정할 수 있다. // allocator 클래스는 new와 delete를 표준방식으로 사용한다. template\u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector { //... }; 생성\n동적 메모리 대입을 사용한다. 원소 개수를 지정하기 위해 초기화 매개변수를 사용할 수 있다. 접근\n[] 연산자로 개별 원소에 접근할 수 있다. 할 수 있는 것\nsize() 원소 개수 리턴 swap() 두 컨테이너 내용을 교환 begin() 컨테이너에 있는 첫 번째 원소를 참조하는 이터레이터를 리턴 end() 컨테이너에 있는 마지막 원소 바로 다음(past-the-end)을 참조하는 이터레이터를 리턴 push_back() 벡터의 끝에 원소를 하나 추가 erase() 매개변수로 2개의 이터레이터를 받는다. 첫 번째 이터레이터가 가리키는 곳부터 두 번째 이터레이터 전까지를 삭제한다. (두 번째 이터레이터 포함 안 함) insert() 매개변수로 3개의 이터레이터를 받는다. 첫 번째 이터레이터 앞에 원소들이 삽입된다. 두 번째 이터레이터가 가리키는 곳부터 세 번째 이터레이터 전까지 추가된다. (세 번째 이터레이터 포함 안 함) 이터레이터 단순 포인터를 가지고는 동작시킬 수 없는 클래스를 포함하여, 다양한 컨테이너 클래스들에 일관된 인터페이스를 제공할 수 있다. 각 컨테이너 클래스는 하나의 적절한 이터레이터를 정의한다. 데이터형 이름은 iterator이며, 클래스 사용범위를 가지는 typedef이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; scores {0, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt;::iterator vi; // vector\u0026lt;int\u0026gt;를 위한 이터레이터 vi = scores.begin(); // 이터레이터가 첫번째 원소를 가리키게 한다. auto va = scores.begin(); // C++11의 자동 타입 추론을 사용할 수도 있다. *vi = 1; // 이터레이터 내용을 참조하여 값을 변경한다. ++vi; // 이터레이터가 다음 원소를 가리키게 한다. // end()에 도달하면 그만두는 방식으로 모두 출력할 수 있다. for (vi = scores.begin(); vi != scores.end(); vi++) cout \u0026lt;\u0026lt; *vi \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 할 수 있는 그 밖의 것 검색하고, 정렬하고, 순서를 무작위화하는 등의 작업을 vector 템플릿 클래스에서 메서드로 가지고 있을까? 아니다. STL은 좀 더 넓은 시각으로, 이러한 연산들을 멤버가 아닌 함수로 정의한다. 예를 들면, 모든 컨테이너 클래스에서 사용할 수 있는 멤버가 아닌 하나의 find()함수를 정의하는 것이다. 대표적인 STL 함수인 세 가지를 살펴보자. for_each() random_shuffle() sort() for_each() 함수 3개의 매개변수를 받는다. 첫 번째와 두 번째 매개변수는 범위를 정한다. 세 번째 매개변수는 함수 객체이다. 지시된 함수를 그 범위 안에 있는 각 컨테이너 원소에 적용한다. 지시된 함수는 컨테이너 원소들의 값을 변경하면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct Review { string title; int rating; }; void ShowReview(const Review\u0026amp; r) { cout \u0026lt;\u0026lt; r.title \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r.rating \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;Review\u0026gt; books = { {\u0026#34;Harry Potter\u0026#34;, 10}, {\u0026#34;Hole\u0026#34;, 9}, }; // for문을 사용한다. for (auto pr = books.begin(); pr != books.end(); pr++) ShowReview(*pr); // for_each를 사용해서 이렇게 바꿀 수 있다. for_each(books.begin(), books.end(), ShowReview); // 함수는 값을 변경하지 않는다. } random_shuffle() 2개의 이터레이터 매개변수를 받는다. 그 이터레이터 범위 안에 있는 원소들을 무작위 순서로 재배치한다. 1 random_shuffle(books.begin(), books.end()); sort() 두 가지 버전이 있다. (1) 2개의 이터레이터 매개변수를 받는다. 컨테이너의 데이터형에 맞게 정의된 \u0026lt;연산자를 사용하여 그 범위를 정렬한다. 만약 데이터형이 사용자 정의 객체라면 operator\u0026lt;()함수가 있어야한다. (2) 3번째 매개변수를 받는다. 값을 비교하기 위한 operator\u0026lt;() 대신에 사용할 함수 객체이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool operator\u0026lt;(const Review\u0026amp; r1, const Review\u0026amp; r2) { return r1.rating \u0026lt; r2.rating; // 오름차순 } bool WorseThan(const Review\u0026amp; r1, const Review\u0026amp; r2) { return r1.rating \u0026gt; r2.rating; // 내림차순 } int main() { vector\u0026lt;int\u0026gt; coolstuff; sort(coolstuff.begin(), coolstuff.end()); // 내장된 \u0026lt; 연산자 사용 sort(books.begin(), books.end()); // 데이터형에 맞게 정의된 operator\u0026lt;() 사용 (1) sort(books.begin(), books.end(), WorseThan); // WorseThan함수 사용 (2) } Range에 기초한 루프 (C+11) 1 2 3 4 for_each(books.begin(), books.end(), ShowReview); // ShowReivew는 값변경 안 된다. for (auto r : books) ShowReview(r); // 값 변경 할 수 있다. 이터레이터(iterator) 템플릿이 알고리즘을 저장할 데이터형과 무관하게 만드는 것처럼, 이터레이터는 알고리즘을 사용할 컨테이너형과 무관하게 만든다. double 배열과 링크드 리스트에서 원하는 값을 찾는 Find()함수를 만들면서 이터레이터에 대해 알아보자. 특정한 구조에 매여 있지 않으면 좋겠다. 따라서 다음과 같이 만들어보았다. 여기서 두 Find()함수의 유일한 다른점은 검색을 멈추는 마지막 지점이다. past-the-end원소를 링크드 리스트도 갖게 한다면, 두 Find()함수는 똑같아진다. 따라서 각 클래스를 위한 적절한 이터레이터를 정의하고 클래스들을 일관된 방식으로 설계하면, STL을 사용하여서 동일한 코드를 작성할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 // 배열의 경우 // 포인터로 정의한다. typedef double* iterator; iterator FindAr(iterator begin, iterator end, const double\u0026amp; target) { // 배열의 끝 바로 다음 포인터인 end가 아닐 때까지 진행한다. for (iterator it = begin; it != end; it++) if (*it = target) return it; return end; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 링크드 리스트의 경우 struct Node { double item; Node* next; }; // 객체로 정의한다. class iterator { Node* pt; public: iterator() : pt(nullptr) {} iterator(Node* pn) : pt(pn) {} double operator*() { return pt-\u0026gt;item; } // ++iterator iterator\u0026amp; operator++() { pt = pt-\u0026gt;next; return *this; } // iterator++ (매개변수 int는 사용되지 않기때문에 이름을 부여할 필요가 없다) iterator operator++(int) { iterator temp = *this; pt = pt-\u0026gt;next; return temp; } // ... }; iterator FindLl(iterator begin, const double\u0026amp; target) { // 마지막인 널 포인터가 아닐 때까지 진행한다. for (iterator it = begin; it != 0; it++) if (*it = target) return it; return 0; } 이터레이터의 종류 1. 입력 이터레이터(input iterator) 2. 출력 이터레이터(output iterator) 3. 전방 이터레이터(forward iterator) 4. 전후방 이터레이터(bidirectional iterator) 5. 임의 접근 이터레이터(random access iterator) 알고리즘이 다르면 이터레이터의 종류가 다르다. 예를 들어, 검색의 경우 쓰기는 금지하고 읽기 접근만 허용해야 하며, 원소 교환의 경우 임의 접근을 허용해야 한다. 요구 사항이 가장 적은 이터레이터를 사용하여 알고리즘을 작성함으로써, 가장 넒은 범위의 컨터에너들에 사용할 수 있도록 하기 위해 여러 가지 종류의 이터레이터가 존재한다. 따라서 find()의 경우, 읽을 수 있는 값이 들어 있는 어떠한 컨테이너들에도 사용할 수 있겠다. vector\u0026lt;int\u0026gt;클래스는 임의 접근 이터레이터를 사용하며, list\u0026lt;int\u0026gt;클래스는 전후방 이터레이터를 사용한다. 1 2 3 4 5 6 7 // 입력 이터레이터를 요구하는 함수 find() template\u0026lt;class InputIerator, class T\u0026gt; InputIerator find(InputIerator first, InputIerator last, const T\u0026amp; value); // 임의 접근 이터레이터를 요구하는 함수 sort() template\u0026lt;class RandomAccessIterator\u0026gt; void sort(RandomAccessIterator first, RandomAccessIterator last); 1. 입력 이터레이터\n컨테이너로부터 값을 읽는 것을 허용한다. 하지만 변경하는 것은 허용하지 않는다. 입력 이터레이터가 이미 증가된 후에, 증가되지 전 값을 내용 참조할 수 있다는 보장이 없다. 이렇게 입력 이터레이터에 기초를 둔 알고리즘은 일회성이며, 일방향적이다. 즉, 증가시킬 수는 있지만 되돌릴 수는 없다. 2. 출력 이터레이터\n값을 변경하는 것을 허용하지만, 읽는 것은 허용하지 않는다. 이것은 cout을 생각해보면 된다. cout은 디스플레이로 보내지는 문자들의 스트림을 변경할 수 있지만, 화면에 표시된 것을 읽지는 못한다. 쓰기 전용 일회성 알고리즘에 사용할 수 있다. 3. 전방 이터레이터\n입/출력 이터레이터와 마찬가지로 전방 이터레이터도 컨테이너 속을 훑고 지나가기 위해 ++연산자만 사용한다. 다른 점 전방 이터레이터는 사용할 때마다 연속된 값들을 반드시 같은 순서로 훑고 지나간다. 증가된 후에도 (저장해 두었다면) 그 이전 이터레이터 값을 내용 참조하여 항상 같은 값을 얻을 수 있다. 따라서 다중 패스 알고리즘이 가능해진다. 4. 전후방 이터레이터\n전방 이터레이터가 가지고 있는 모든 기능에 감소 연산자(전방, 후방)에 대한 기능을 추가한다. 예를 들어, 뒤집기(reverse) 함수는 첫 번째 원소와 마지막 원소를 맞바꾸고, 첫 번째 원소를 지시하는 포인터는 증가시키고, 마지막 원소를 지시하는 포인터는 감소시킨다. 5. 임의 접근 이터레이터\n전후방 이터레이터가 가지고 있는 모든 기능에 임의 접근을 지원하는(포인터 덧셈 등) 연산과, 원소들의 순서를 매기는 데 사용할 관계 연산자들을 추가한다.\n예를 들어, 이진 탐색(binary search)의 경우 임의 원소로 직접 점프가 가능해야 한다.\n임의 접근 이터레이터 연산\na, b는 이터레이터이다. n은 정수이며 r는 임의 접근 이터레이터 변수/참조이다. a + n과 같은 식은 a와 a + n이 둘 다 컨테이너의 범위 안에 있을 때만 유효하다. 식 설명 a + n, n + a a가 지시하는 원소로부터 n번째 뒤의 원소를 지시한다. a - n a가 지시하는 원소로부터 n번째 앞의 원소를 지시한다. r += n r = r + n과 같다. r -= n r = r - n과 같다. a[n] *(a + n)과 같다. b - a b = a + n과 같은 경우에 n의 값 a \u0026lt; b b - a \u0026gt; 0이면 true a \u0026gt; b b \u0026lt; a이면 true a \u0026gt;= b !(a \u0026lt; b)이면 true a \u0026lt;= b !(a \u0026gt; b)이면 true 이터레이터 계층 이터레이터 기능 입력 출력 전방 전후방 임의 접근 내용 참조하여 읽기 O X O O O 내용 참조하여 쓰기 X O O O O 고정 반복 가능한 순서 X X O O O ++i, i++ O O O O O --i, i-- X X X O O i[n] X X X X O i + n X X X X O i - n X X X X O i += n X X X X O i -= n X X X X O 개념(concept) 요구 사항의 집합 개량(refinement) 개념적인 상속 예를 들어, 전후방 이터레이터는 전방 이터레이터의 기능을 상속한다. 하지만 C++의 일반적인 상속과는 다르다. 이것들은 내장 데이터형이기 때문에 클래스로부터 파생시킬 수가 없다. 따라서 이런 것을 개념적인 상속인 개량이라고 부른다. 모델(model) 어떤 개념의 특별한 한 구현 예를 들어, int를 지시하는 단순 포인터는 임의 접근 이터레이터 개념의 한 모델이다. 또한 전방 이터레이터 개념의 모델이기도 하다. 이터레이터 자격의 포인터 이터레이터는 포인터를 일반화한 것이다. 따라서 STL알고리즘은 포인터에 기초를 두고 있는 STL이 아닌 컨테이너들에 적용할 수 있다. 1 2 3 4 const int SIZE = 10; double arr[SIZE]; sort(arr, arr + SIZE); // (O) copy() 하나의 컨테이너에서 다른 컨테이너로 데이터를 복사하는 알고리즘. 첫 번째와 두 번째 매개변수로 범위를 지정하고, 세 번째 매개변수로 복사할 위치를 지정한다. 이것은 목적지의 크기를 자동으로 조절하지 않는다. (뒤에 볼 insert_iterator 등을 사용하면 가능하다. ) 1 2 3 4 int arr[5] = {1, 2, 3, 4, 5}; vector\u0026lt;int\u0026gt; vec[5]; // 빈 벡터에는 복사할 수 없다. copy(arr, arr + 5, vec.begin()); // arr의 인덱스 0~4를 vec의 인덱스 0지점에 복사한다. 디스플레이에 복사하려면? 출력 스트림을 나타내는 이터레이터가 있으면 가능하겠다. STL은 ostream_iterator을 제공한다. 이것은 출력 이터레이터 개념의 모델이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iterator\u0026gt; ostream_iterator\u0026lt;int, char\u0026gt; outIterator(cout, \u0026#34; \u0026#34;); // int는 출력 스트림으로 보내는 데이터형이다. // char는 출력 스트림이 사용하는 데이터형이다. // cout은 cout이 관리하는 출력 스트림을 사용한다는 뜻이다. // \u0026#34; \u0026#34;은 출력 스트림에 보내진 각 항목 뒤에 표시되는 분리자이다. *outIterator++ = 15; // cout \u0026lt;\u0026lt; 15 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 와 같다. copy(vec.begin(), vec.end(), outIterator); // 벡터를 출력 스트림에 복사한다. // 혹은 익명 이터레이터를 만들 수도 있다. copy(vec.begin(), vec.end(), ostream_iterator\u0026lt;int, char\u0026gt;(cout, \u0026#34; \u0026#34;)); istream_iterator 같은 논리로, 입력을 위한 istream_iterator가 입력 이터레이터 개념의 모델이다. 1 2 3 4 5 6 7 copy(istream_iterator\u0026lt;int, char\u0026gt;(cin), istream_iterator\u0026lt;int, char\u0026gt;(), vec.begin()) // 입력 // int는 읽을 데이터형이다. // char는 입력 스트림이 사용하는 데이터형이다. // cin은 cin이 관리하는 입력 스트림을 사용한다는 뜻이다. // 매개변수를 생략하는 것은 입력 실패를 나타낸다. // 따라서 파일 끝, 데이터형 불일치 등의 입력 실패가 일어날 때까지 데이터를 읽는다는 뜻이다. reverse_iterator 이것을 증가시키면, 실제 내용은 감소한다. rbegin()은 past-the-end를 지시하며, rend()는 첫 번째 원소를 지시한다. 특이한 점은 역방향 포인터들은 먼저 감소시킨 후에 내용 참조를 한다는 점이다. 따라서 다음 코드와 같이 하면, 벡터를 뒤에서 부터 거꾸로 출력한다. 1 2 3 4 5 6 7 // 암시적 사용 copy(vec.rbegin(), vec.rend(), outIterator); // 마지막 원소 ~ 처음 원소 출력 // 명시적 사용 vector\u0026lt;int\u0026gt;::reverse_iterator ri; for (ri = vec.rbegin(); ri != vec.rend(); ++ri) cout \u0026lt;\u0026lt; *ri \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 추가적인 출력 이터레이터 개념의 모델들\u0026hellip;\nfront_insert_iterator\n컨테이너 선두에 원소들을 삽입한다. 선두에 삽입하는데 고정 시간이 걸리는 컨테이너형에만 사용할 수 있다. end_insert_iterator\n컨테이너 말미에 원소들을 삽입한다. 멀미에 삽입하는데 고정 시간이 걸리는 컨테이너형에만 사용할 수 있다. insert_iterator\n매개변수로 지정된 위치 앞에 원소들을 삽입한다. 시간 제한은 없다. 대신 다른 것들에 비해 좀 느리다. 이와 같은 모델들은 생성자 매개변수로 실제 컨테이너 식별자를 사용한다. copy()는 컨테이너 크기를 조절하는 권한이 없다. 하지만 이 모델들은 아래와 같이 컨테이너형을 선언하여서 vector\u0026lt;int\u0026gt;::push_back()에 접근이 가능하며, 따라서 컨테이너 크기를 조절할 수 있다. 1 2 3 4 back_insert_iterator\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; backIterator(vec); insert_iterator\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; insertIterator(vec, vec.begin()); // vec.begin()은 삽입될 위치이다. 1 2 3 4 5 6 string strs[5] = { \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34; }; vector\u0026lt;string\u0026gt; words = { \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34; }; copy(strs, strs + 2, back_insert_iterator\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(words)); // str의 0 ~ 1인덱스에 있는 \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;를 words벡터 뒤에 삽입한다. // a b c d e A B 1 2 3 copy(strs, strs + 2, insert_iterator\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(words, words.begin() + 2)); // str의 0 ~ 1인덱스에 있는 \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;를 words의 인덱스 2 위치 부터 삽입한다. // a b A B c d e ","date":"2022-03-23T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-16-2/","title":"[C++ Primer Plus] Chapter 16. (2) STL - 이터레이터"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\nstring 클래스 string 헤더파일을 통해 지원된다. C 스타일은 string.h와 cstring이다. string은 실제로는 템플릿 특수화 basic_string\u0026lt;char\u0026gt;에 대한 typedef이다. 1 2 3 4 5 6 7 8 9 10 11 12 // string 클래스는 템플릿 클래스에 기초한다. template\u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt;, class Allocator = allocator\u0026lt;charT\u0026gt;\u0026gt; class basic_string { // char 뿐만 아니라 다른형에 기초하는 문자열도 사용할 수 있게 허용한다. typedef basic_string\u0026lt;char\u0026gt; string; typedef basic_string\u0026lt;wchar_t\u0026gt; wstring; typedef basic_string\u0026lt;char16_t\u0026gt; u16string; // C++11 typedef basic_string\u0026lt;char32_t\u0026gt; u32string; // C++11 // ... }; string 생성자들\n메모리와 관련된 선택적 매개변수를 생략했다. (1) string(const char* s)\nstring객체를 s가 지시하는 NBTS로 초기화한다. (2) string(size_type n, char c)\n문자 c로 모두 초기화된 원소 n개의 string객체를 생성한다. (3) string(const string\u0026amp; str)\nstring객체를 string객체 str(복사 생성자)로 초기화한다. (4) string()\n크기가 0인 디폴트 string객체를 생성한다 (디폴트 생성자) (5) string(const char* s, size_type n)\nstring객체를 s가 자시하는 NBTS로 초기화하되, NBTS의 크기를 초과하더라도 n개의 문자까지 진행한다. (6) template\u0026lt;class Iter\u0026gt; string(Iter begin, Iter end)\nstring객체를 begin과 end - 1 범위에 있는 [begin, end) 값들로 초기화한다. begin과 end는 포인터와 비슷한 역할을 하여 위치를 지정한다. 그 범위는 begin을 포함하고 end는 포함하지 않는 end 바로 앞까지를 의미한다. (7) string(const string\u0026amp; std, size_type pos, size_type n = npos)\nstring 객체를 string객체 str로 초기화한다. str에 있는 pos위치에서 시작해서 str의 끝까지 가거나 n문자를 사용하되, str의 끝을 넘어갈 수 없다. (8) string(string\u0026amp;\u0026amp; str) noexcept\n(C++11) string객체를 string객체 str로 초기화한다. str은 const가 아니므로 바뀔 수 있다. (move 생성자) 컴파일러는 경우에 따라 성과를 최적화하기 위해서 복사 생성자 대신 이동 생성자를 사용한다. (9) string(initilaizer_list\u0026lt;char\u0026gt; il)\n(C++11) string 객체를 초기자 목록 il에 있는 문자로 초기화한다. 따라서 리스트 초기화를 가능하게 한다.\nNBTS\nnull byte terminated string; 널 바이트 종료 문자열 type_size\nstring헤더파일에 정의되어 있는, 시스템마다 다른 정수형이다. string::npos를 문자열의 최대길이로 정의한다. 일반적으로 unsigned char의 최대값과 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string one(\u0026#34;Lottery Winner!\u0026#34;); cout \u0026lt;\u0026lt; one \u0026lt;\u0026lt; endl; string two(20, \u0026#39;$\u0026#39;); cout \u0026lt;\u0026lt; two \u0026lt;\u0026lt; endl; string three(one); cout \u0026lt;\u0026lt; three \u0026lt;\u0026lt; endl; one += \u0026#34; Oops!\u0026#34;; // 오버로딩 += cout \u0026lt;\u0026lt; one \u0026lt;\u0026lt; endl; two = \u0026#34;Sorry! That was \u0026#34;; // 오버로딩 = three[0] = \u0026#39;P\u0026#39;; // 오버로딩 [] string four; four = two + three; // 오버로딩 =, + cout \u0026lt;\u0026lt; four \u0026lt;\u0026lt; endl; char alls[] = \u0026#34;All\u0026#39;s well that ends well\u0026#34;; string five(alls, 20); cout \u0026lt;\u0026lt; five \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; // 배열의 이름은 주소이다. // 따라서 alls + 6은 char*형이다. 따라서 Iter가 char*형이 된다. string six(alls + 6, alls + 10); // 인덱스 6부터 9까지 cout \u0026lt;\u0026lt; six \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; // \u0026amp;five[6] 또한 char*형이다. string six2(\u0026amp;five[6], \u0026amp;five[10]); cout \u0026lt;\u0026lt; six2 \u0026lt;\u0026lt; \u0026#34;...\\n\u0026#34;; string seven(four, 7, 16); // 인덱스 7부터 16개 문자 cout \u0026lt;\u0026lt; seven \u0026lt;\u0026lt; \u0026#34; in motion!\u0026#34; \u0026lt;\u0026lt; endl; string nine = { \u0026#39;L\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39; }; } 입력 1 2 3 4 5 6 7 8 9 10 // C 스타일 문자열 char info[100]; cin \u0026gt;\u0026gt; info; // 한 단어를 읽는다. cin.getline(info, 100); // 한 행을 읽되, \\n은 내버린다. cin.get(info, 100); // 한 행을 읽되, \\n은 큐에 남겨 둔다. // string 객체 string stuff; cin \u0026gt;\u0026gt; stuff; // 한 단어를 읽는다. getline(cin, stuff); // 한 행을 읽되, \\n은 내버린다. getline()은 입력을 구분하기 위한 선택적 매개변수를 허용한다. 차이점은 string의 경우에는 객체의 크기를 자동으로 조절한다는 것이다. 1 2 3 4 5 // C 스타일 문자열 cin.getline(info, 100, \u0026#39;:\u0026#39;); // :까지 읽고, :는 내버린다. // string 객체 getline(cin, stuff, \u0026#39;:\u0026#39;); // :까지 읽고, :는 내버린다. getline()은 다음 중 하나가 일어나면 종료된다. (1) 파일의 끝을 만났을 때. 입력 스트림의 eofbit가 설정된다. (2) 구분문자(디폴트는 \\n이다. 만약 구분문자가 다른 것이되면 \\n은 그냥 일반 문자가 된다)에 도달했을 때. 구분문자는 저장되지 않는다. (3) 가능한 최대 문자 수(string::npos와 대입에 사용할 수 있는 메모리 바이트 수 중 더 적은 것)를 읽었을 때. 입력 스트림의 failbit가 설정된다. string 문자열의 크기 length() 오래된 버전부터 사용해온 것 size() STL 호환성을 위해 추가된 것 find() 메서드의 네 가지 변형 (1) size_type find(const string\u0026amp; str, size_type pos = 0) const\npos위치에서 시작해서 처음 나오는 str문자열을 찾는다. (2) size_type find(const char* s, size_type pos = 0) const\npos위치에서 시작해서 처음 나오는 s문자열을 찾는다. (3) size_type find(const char* s, size_type pos = 0, size_type n) const\npos위치에서 시작해서 s문자열의 처음 n개에 해당하는 부분 문자열을 찾는다. (4) size_type find(char ch, size_type pos = 0) const\npos위치에서 시작해서 처음 나오는 문자 ch를 찾는다. 찾으면, 첫 문자의 인덱스를 반환한다.\n찾지 못하면, string::npos를 리턴한다.\nfind() 관련 메서드 rfind() 가장 마지막으로 발생하는 부분 문자열이나 문자를 찾는다. find_first_of() 매개변수 문자열에서 처음 나오는 문자를 찾는다. find_last_of() 매개변수 문자열에서 마지막으로 나오는 문자를 찾는다. 1 2 3 4 string findHere(\u0026#34;ACAB\u0026#34;); int where = findHere.find_first_of(\u0026#34;BC\u0026#34;); // 가장 처음 나오는 \u0026#39;C\u0026#39; 인덱스 1 where = findHere.find_last_of(\u0026#34;BC\u0026#34;); // 가장 마지막으로 나오는 \u0026#39;B\u0026#39; 인덱스 3 자동 크기 조절 매번 크기가 늘어날 때마다 새로운 블록을 대입하고 복사하는 것은 비효율적이다. 따라서 애초에 실제 문자열보다 훨씬 큰 메모리 블록을 대입한다. 그리고, 그 크기를 넘으면 그것의 두 배가 되는 블록을 새로 대입한다. capacity() 현재 블록의 크기를 리턴한다. reserve(size_t n) 블록의 최소한의 크기를 설정한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 string empty; string small = \u0026#34;bit\u0026#34;; string larger = \u0026#34;Elephants are a girl\u0026#39;s best friend\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Sizes:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\tempty: \u0026#34; \u0026lt;\u0026lt; empty.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tsmall: \u0026#34; \u0026lt;\u0026lt; small.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tlarger: \u0026#34; \u0026lt;\u0026lt; larger.size() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Capacities:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\tempty: \u0026#34; \u0026lt;\u0026lt; empty.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tsmall: \u0026#34; \u0026lt;\u0026lt; small.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tlarger: \u0026#34; \u0026lt;\u0026lt; larger.capacity() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; empty.reserve(50); cout \u0026lt;\u0026lt; \u0026#34;Capacity after empty.reserve(50): \u0026#34; \u0026lt;\u0026lt; empty.capacity() \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 11 Sizes: empty: 0 small: 3 larger: 34 Capacities: empty: 15 // 이 시스템은 15문자의 최소용량을 사용한다. small: 15 larger: 47 Capacity after empty.reserve(50): 63 c_str() C 스타일로 바꾸기 1 2 3 4 5 6 7 8 // string에 들어있는 파일명이 필요할 경우. // open()은 C 스타일 매개변수를 요구한다. string filename; cin \u0026gt;\u0026gt; filename; ofstream fout; fout.open(filename.c_str()); 스마트 포인터 템플릿 클래스 스마트 포인터가 필요한 이유 동적 메모리 할당 후 해제하는 것을 잊어서 메모리 누수가 발생할 수 있다. 아래 예제와 같은 상황에서는 해제하는 코드를 작성하려면 try catch문을 또 작성해야할 것이다. 이러한 문제를 해결할 수 있는 더 멋진 해결책이 없을까? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Remodel(string\u0026amp; str) { string* ps = new string(str); //... if (weirdThing()) throw exception(); // 지역 변수인 ps가 차지하는 메모리는 블록을 나가면서 해제되지만 // delete ps 하지 않았기 때문에 ps가 가리키는 메모리는 해제되지 않는다! str = *ps; delete ps; return; } 스마트 포인터 (smart pointer) 포인터처럼 행동하는 클래스 객체이다. new를 통해 얻어지는 주소를 대입할 포인터를 정의한다. 그리고 이 객체의 수명이 다 하면, 파괴자는 delete를 사용해서 메모리를 자동으로 해제한다. (p.1230 그림 16.2 참고) auto_ptr, unique_ptr, shared_ptr, weak_ptr memory 헤더파일에 정의되어있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // auto_ptr는 클래스 템플릿을 사용해서 포인터의 종류를 구체화한다. template\u0026lt;class X\u0026gt; class auto_ptr { public: explicit auto_ptr(X* p = 0) throw(); // 생성자 }; int main() { auto_ptr\u0026lt;int\u0026gt; ptr(new int); // int형을 가리키는 auto_ptr이다. auto_ptr\u0026lt;string\u0026gt; ptr(new string); // string형을 가리키는 auto_ptr이다. } auto_ptr로 이전 예제의 문제점을 수정해보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;memory\u0026gt; void Remodel(string\u0026amp; str) { //string* ps = new string(str); auto_ptr\u0026lt;string\u0026gt; ps(new string(str)); // auto_ptr을 사용한다. //... if (weirdThing()) throw exception(); // auto_ptr이 동적 메모리도 알아서 해제해준다. str = *ps; //delete ps; 이것은 이제 필요없다. return; } 스마트 포인터 생성자에 explicit이 있으므로 명시적 변환만 허용된다. 1 2 3 4 5 shared_ptr\u0026lt;double\u0026gt; ds; double* d = new double; ds = d; // (X) 암시적 변환은 안 된다. ds = shared_ptr\u0026lt;double\u0026gt;(d); // (O) 명시적 변환은 된다. 스마트 포인터를 사용하면 안 되는 경우 delete하려는 메모리가 힙에 없는 경우 1 2 string str(\u0026#34;I want to study.\u0026#34;); shared_ptr\u0026lt;string\u0026gt; pstr(\u0026amp;str); // (X) 문제 상황 아래 예제는 한 번 해제한 메모리를 두 번 해제하게 된다. 각각의 스마트 포인터는 이 상황을 어떻게 해결할까? 1 2 3 4 5 6 7 auto_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); auto_ptr\u0026lt;string\u0026gt; pps; pps = ps; // 이렇게 하면 ps와 pps 모두 하나의 똑같은 메모리를 가리키게 된다. // 일반 포인터면 괜찮겠지만, 스마트 포인터는 delete 자동으로 호출하니까, // 그럼 delete도 두 번 될텐데.. 각각의 스마트 포인터는 이 상황을 어떻게 해결했을까? 해결 방안 (1) 깊은 복사를 하는 대입연산자를 정의한다. (2) 소유권 개념을 도입한다. auto_ptr과 shared_ptr의 전략이다. 스마트 포인터가 그 객체를 소유하는 경우에만 파괴자가 그 객체를 삭제한다. 그러고 나서, 대입을 통해 소유권을 이전시킨다. (3) 참조 카운팅(reference counting) shared_ptr의 전략이다. 특정 객체를 참조하는 스마트 포인터들이 몇 개인지 추적한다. 대입할 때마다 참조 카운팅이 1씩 증가한다. 스마트 포인터의 수명이 다하면 1씩 감소한다. 그리고 마지막으로 스마트 포인터의 수명이 다했을 때 delete가 호출된다. 해결 방안 비교 1 2 3 4 5 6 7 8 // auto_ptr auto_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); auto_ptr\u0026lt;string\u0026gt; pps; pps = ps; // ps의 소유권이 pss에게 넘어가서 ps는 더 이상 그 문자열을 참조하지 않는다. cout \u0026lt;\u0026lt; *ps \u0026lt;\u0026lt; endl; // (X) 실행 후 프로그램 크래시가 발생한다. 1 2 3 4 5 6 7 8 9 10 // shared_ptr shared_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); shared_ptr\u0026lt;string\u0026gt; pps; pps = ps; // 참조가 2번이 된다. cout \u0026lt;\u0026lt; *ps \u0026lt;\u0026lt; endl; // (O) // 참조카운트를 2에서 1로(pps), 1에서 0으로 줄이고(ps), 0이 되었을 때 힌 번 메모리를 해제한다. 1 2 3 4 5 6 7 8 // unique_ptr unique_ptr\u0026lt;string\u0026gt; ps(new string(\u0026#34;I\u0026#39;m happy.\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; pps; pps = ps; // (X) 애초에 컴파일이 되지 않아서 실행도 안 된다. cout \u0026lt;\u0026lt; *ps \u0026lt;\u0026lt; endl; unique_ptr이 auto_ptr보다 좋은 점 프로그램 크래시 보다 컴파일 에러가 더 안정적이다. 대입 시 원본 객체가 임시 rvalue라면 그것을 허용한다. 배열을 가리킬 수 있다. auto_ptr은 new와 delete는 사용할 수 있지만 new [], delete []은 안 된다. 반면, unique_ptr은 둘 다 가능하다. 1 2 3 4 5 6 7 unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;Uniquely special\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; p2; p2 = p1; // (X) 컴파일 에러 p2 = unique_ptr\u0026lt;string\u0026gt;(new string(\u0026#34;Uniquely special\u0026#34;)); // (O) 임시 rvalue이므로, 임시 객체는 삭제된다. 따라서 p2가 유일하기 때문에 이것은 허용 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // unique_ptr을 위한 대입 방법을 이렇게 제안한다. unique_ptr\u0026lt;string\u0026gt; Demo(const char* s) { unique_ptr\u0026lt;string\u0026gt; temp(new string(s)); return temp; } int main() { unique_ptr\u0026lt;string\u0026gt; ps; ps = Demo(\u0026#34;Uniquely Special\u0026#34;); // (O) } 1 2 3 4 string strs[3]{ \u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;}; auto_ptr\u0026lt;string[]\u0026gt; psa(strs); // (X) unique_ptr\u0026lt;string[]\u0026gt; psu(strs); // (O) 배열을 가리킬 수 있다. unique_ptr의 대입을 가능하게 해주는 move() 표준 라이브러리 함수 1 2 3 unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;One\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; p2 = move(p1); p1 = unique_ptr\u0026lt;string\u0026gt;(new string(\u0026#34;And more\u0026#34;)); 스마트 포인터를 선택하는 방법 하나의 객체를 여러개의 포인터가 가리켜야 한다 shared_ptr 다중 포인터가 필요 없다. unique_ptr new로 대입된 메모리를 리턴하는 함수의 리턴 타입? unique_ptr 만약 하나의 unique_ptr에서 다른 unique_ptr로 대입이 가능한 경우라면 shared_ptr에 unique_ptr을 대입할 수 있다. 1 2 3 shared_ptr\u0026lt;string\u0026gt; ps; ps = unique_ptr\u0026lt;string\u0026gt;(new string(\u0026#34;Uniquely special\u0026#34;)); // (O) ps = Demo(\u0026#34;Uniquely Special\u0026#34;); // (O) ","date":"2022-03-23T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-16-1/","title":"[C++ Primer Plus] Chapter 16. (1) string 클래스, 스마트 포인터 템플릿 클래스"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\nRTTI (runtime type identification) 실행 시간 데이터형 정보 실행 도중에 객체의 데이터형을 결정하는 표준 방법을 제공하는 것이 목적이다. RTTI의 동작 방식 C++은 RTTI를 지원하는 세 가지 요소를 가지고 있다. (1) dynamic_cast 연산자 (2) type_id 연산자 (3) type_info 클래스 RTTI는 가상함수들을 가지고 있는 클래스들에 대해서만 사용할 수 있다. 그 이유는, 그들이 파생 객체들의 주소를 기초 클래스 포인터들에 대입하는 유일한 클래스 계층이기 때문이다. RTTI는 가상함수들을 가지고 있는 클래스들에 대해서만 사용할 수 있다.\ndynamic_cast 연산자 기초 클래스형을 지시하는 포인터로부터 파생 클래스형을 지시하는 포인터를 생성한다. 포인터가 지시하는 객체형이 무엇인지 알려주지 않는다. 대신에, 그 객체의 주소를 특정형의 포인터에 안전하게 대입할 수 있는지 알려준다. 가능하지 않다면, 널 포인터인 0을 리턴한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A {}; class B : public A {}; class C : public B {}; int main() { A* a = new A; A* b = new B; A* c = new C; C* cc = (C*)c; // 안전하다 B* bc = (B*)c; // 안전하다 C* ca = (C*)a; // 안전하지 않다. 런타임에 이러한 데이터형 변환이 안전한지 물어볼 수는 없을까? } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; class Grand { private: int hold; public: Grand(int h = 0) : hold(h) {} // Say() 함수가 없다. virtual void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Grand 클래스입니다. \\n\u0026#34;; } virtual int Value() const { return hold; } }; class Superb : public Grand { public: Superb(int h = 0) : Grand(h) {} void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Superb 클래스입니다.\\n\u0026#34;; } virtual void Say() const { cout \u0026lt;\u0026lt; \u0026#34;내가 가지고 있는 값은 \u0026#34; \u0026lt;\u0026lt; Value() \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; } }; class Magnificent : public Superb { private: char ch; public: Magnificent(int h = 0, char c = \u0026#39;A\u0026#39;) : Superb(h), ch(c) {} void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Magnificent 클래스입니다.\\n\u0026#34;; } void Say() const { cout \u0026lt;\u0026lt; \u0026#34;내가 가지고 있는 문자는 \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34;이고, 정수는 \u0026#34; \u0026lt;\u0026lt; Value() \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; } }; Grand* GetOne() // 세 종류의 객체 중에 하나를 임의로 생성한다. { Grand* p = new Grand(); switch (rand() % 3) { case 0: p = new Grand(rand() % 100); break; case 1: p = new Superb(rand() % 100); break; case 2: p = new Magnificent(rand() % 100, \u0026#39;A\u0026#39; + rand() % 26); break; } return p; } int main() { srand(time(0)); Grand* pg; Superb* ps; for (int i = 0; i \u0026lt; 5; i++) { pg = GetOne(); pg-\u0026gt;Speak(); // Grand 클래스에는 Say()가 없다. // 하지만 dynamic_cast연산자를 사용해서 Superb* 형으로 변환시킬 수 있는지 알아볼 수 있다. // 그러면 Superb형이나 Magnificent형 둘 중 하나일 때 참이 된다. if (ps = dynamic_cast\u0026lt;Superb*\u0026gt;(pg)) ps-\u0026gt;Say(); } } dynamic_cast를 참조와 함께 사용할 수도 있다. 널 포인터형에 해당하는 참조값은 존재하지 않는다. 따라서 실패를 나타내기 위해 bad_cast형의 예외를 발생시킨다. 이것은 exception클래스로부터 파생된 것이다. typeinfo 헤더파일에 정의되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;typeinfo\u0026gt; //... try { Superb\u0026amp; rs = dynamic_cast\u0026lt;Superb\u0026amp;\u0026gt;(rg); } catch (bad_cast\u0026amp;) { //... } typeid 연산자와 type_info 클래스 typeid연산자를 사용하여 두 객체의 데이터형이 같은지 결정할 수 있다. 어떤 객체의 정확한 데이터형을 식별하는 하나의 값을 리턴한다. 매개변수 종류 (1) 클래스의 이름 (2) 객체로 평가되는 식 만약에 매개변수로 주어진 것이 nullptr이면, bad_typeid 예외를 발생시킨다. type_info 객체에 대한 참조를 리턴한다. 어떤 특별한 데이터형에 대한 정보를 저장한다. 이 클래스는 ==과 !=연산자를 오버로딩한다. 안에는 name()멤버가 포함되어 있어서, 가리키는 객체의 클래스 이름을 출력한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { srand(time(0)); Grand* pg; Superb* ps; for (int i = 0; i \u0026lt; 5; i++) { pg = GetOne(); // typeid 클래스에는 가리키는 객체의 클래스의 이름을 리턴하는 name()멤버가 있다. cout \u0026lt;\u0026lt; \u0026#34;지금 처리중인 데이터형: \u0026#34; \u0026lt;\u0026lt; typeid(*pg).name() \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; pg-\u0026gt;Speak(); if (ps = dynamic_cast\u0026lt;Superb*\u0026gt;(pg)) ps-\u0026gt;Say(); // typeid연산자는 매개변수로 클래스 이름이나 객체로 평가되는 식을 받아들인다. // 만약에 pg가 널 포인터이면 bad_typeid 예외를 발생시킨다. if (typeid(Magnificent) == typeid(*pg)) cout \u0026lt;\u0026lt; \u0026#34;그래, 너는 Magnificent형이구나! \\n\u0026#34;; } } 데이터형 변환 연산자 C의 데이터형 변환 연산자는 너무 느슨하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct Data { double data[200]; }; struct Junk { int junk[100]; }; int main() { Data d = { 2.5, 3.5, 20.2 }; // 그 어떤 것도 이치에 맞지 않는다. // 하지만 허용된다. char* pc = (char*)\u0026amp;d; char ch = (char)\u0026amp;d; Junk* pj = (Junk*)\u0026amp;d; } 그래서 데이터형 변환을 더욱 엄격하게 규정하는 4개의 데이터형 변환 연산자를 추가하였다. dynamic_cast 앞서 보았듯, 어떤 클래스 계층 내에서(is-a 관계시) 업캐스트를 허용하고, 다른 데이터형 변화는 허용하지 않는 것이다. const_cast static_cast reinterpret_cast const_cast 어떤 값을 const나 volatile로 또는 그 반대로 변경하려는 데이터형 변환을 위한 것이다. 비교하는 두 데이터형은 const나 volatile가 있느냐 없느냐가 다른 것 빼고는, 데이터형이 동일해야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 class High {}; class Low {}; int main() { High h; const High* phc = \u0026amp;h; High* ph = const_cast\u0026lt;High*\u0026gt;(phc); // const High* 를 High*로 (O) const Low* pl = const_cast\u0026lt;const Low*\u0026gt;(phc); // const High* 를 const Low*로 (X) } 포인터의 접근을 변경할 수 있지만, const로 선언된 양을 변경하려는 시도를 그 결과가 정의되지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void change(const int* pt, int n) { int* pc; pc = const_cast\u0026lt;int*\u0026gt;(pt); // const int*형을 int*형으로 변경한다. *pc += n; // 하지만 원래 형이 const 인경우 값을 증가시키지 않는다. } int main() { int pop1 = 20; const int pop2 = 20; cout \u0026lt;\u0026lt; \u0026#34;pop1, pop2: \u0026#34; \u0026lt;\u0026lt; pop1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; pop2 \u0026lt;\u0026lt; endl; // 20, 20 change(\u0026amp;pop1, -5); change(\u0026amp;pop2, -5); // 원래 const 이므로 제대로 동작하지 않는다. cout \u0026lt;\u0026lt; \u0026#34;pop1, pop2: \u0026#34; \u0026lt;\u0026lt; pop1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; pop2 \u0026lt;\u0026lt; endl; // 15, 20 } static_cast 암시적으로 데이터형 변환이 된다면 유효하다. 예를 들어, 열거값은 암시적으로 정수값으로 변환할 수 있기 때문에 static_cast를 사용해서 열거값을 정수값으로 변환할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Base {}; class Derived : public Base {}; class Other {}; int main() { Base base; Derived derived; // 유효한 업캐스트. 명시적으로 이루어질 수 있으므로 유효하다. Base* pb = static_cast\u0026lt;Base*\u0026gt; (\u0026amp;derived); // 유효한 다운캐스트. 반대 방향의 변환이 암시적으로 이루어질 수 있으므로 유효하다. Derived* pd = static_cast\u0026lt;Derived*\u0026gt; (\u0026amp;base); // 유효하지 않다. Other* po = static_cast\u0026lt;Other*\u0026gt; (\u0026amp;derived); } reinterpret_cast 이것은 본래부터 위험한 데이터형 변환을 위한 것이다. 일반적으로 시스템 의존적인 저수준 프로그래밍에서 사용한다. 그러나 이식성이 없다. 예를 들면, 멀티바이트 값을 서로 다른 바이트 순서를 사용하여 저장하는 두 개의 다른 시스템이 있을 수 있다. 모든 것을 허용하지는 않는다. 예를 들면, 포인터형을 포인터형을 충분히 저장할 수 있는 큰 정수형으로 캐스트할 수는 있지만, 포인터형보다 작은 정수형 또는 부동소수점형으로 캐스트할 수는 없다. 또한 함수 포인터를 데이터 포인터로 또는 그 반대로 캐스트할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Dat { // 2바이트 short a; short b; }; int main() { // lval의 처음 2바이트를 출력한다. long lval = 0xA224B118; Dat* pd = reinterpret_cast\u0026lt;Dat*\u0026gt; (\u0026amp;lval); cout \u0026lt;\u0026lt; pd-\u0026gt;a; } ","date":"2022-03-22T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-15-3/","title":"[C++ Primer Plus] Chapter 15. (3) RTTI"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n예외 두 수의 조화 평균(harmonic mean)을 계산하는 함수를 만들어보자. 주어진 수들의 역수의 산술 평균을 구한다. 그리고 그것의 역수를 취한다. 구하는 수식은 아래와 같다. 여기서 x가 y의 부정이면 이 공식은 0으로 나누는, 정의할 수 없는 연산이 된다. $$ {2.0 \\times x \\times y \\over ( x + y )} $$\n해결하는 방법 중 하나는, 정의할 수 없는 연산일 때 abort()를 호출하는 것이다. abort()는 cstdlib 헤더 파일에 들어 있다. abort()가 호출되면 표준 에러 스트림(cerr가 사용하는 스트림)에 \u0026ldquo;abnormal program temination\u0026rdquo; (비정상적인 프로그램 종료)과 같은 메시지를 보내고 프로그램이 종료된다. 부모 프로세스나 운영체제의 컴파일러에 종속적인 어떤 값을 리턴한다. 이 때, 파일 버퍼를 비우는지 여부는 C++ 컴파일러 마다 다르다. 원한다면, exit()을 사용해서 메시지를 출력하지 않고, 파일 버퍼를 비울 수 있다. 호출하면, main()으로 다시 돌아가는 일 없이, 그 프로그램을 직접 종료한다. 1 2 3 4 5 6 7 8 9 double HMean(double x, double y) { if (x == -y) // x가 y의 부정이면 0으로 나누게 되므로, abort()를 호출한다. { cout \u0026lt;\u0026lt; \u0026#34;매개변수들을 HMean()에 전달할 수 없습니다. \u0026#34; \u0026lt;\u0026lt; endl; abort(); } return 2.0 * x * y / (x + y); } 비정상 종료보다 더 융통성 있는 방법은, 함수의 리턴값을 사용해서 문제가 무엇인지 알리는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 bool HMean(double x, double y, double* ans) { if (x == -y) { *ans = DBL_MAX; return false; // false를 리턴한다. } else { *ans = 2.0 * x * y / (x + y); return true; } } 이제, 예외 매커니즘을 사용해서 문제를 풀어보자. 예시로 보는 게 빠르겠다. 만약, 데이터형이 일치하는 예외 핸들러(catch 구문)가 없다면 프로그램은 기본적으로 abort()를 호출한다. 이 행동을 사용자가 수정할 수도 있다. (잘못된 예외 파트) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 double HMean(double x, double y) { // 2. throw 키워드로 예외를 발생 시킨다. if (x == -y) throw \u0026#34;x = -y 는 허용되지 않습니다.\u0026#34;; return 2.0 * x * y / (x + y); } int main() { double x, y, z; cout \u0026lt;\u0026lt; \u0026#34;두 수를 입력하세요: \u0026#34;; while (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { // 1. try 블록에서 예외가 있는지 체크해본다. try { z = HMean(x, y); } // 3. catch 블록에서 예외를 처리한다. catch (const char* s) // 이 핸들러는 문자열로 발생된 예외를 처리한다. { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;두 수를 새로 입력하세요: \u0026#34;; continue; } // 예외가 발생하지 않았다면 이곳으로 바로 넘어온다. cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 조화평균은 \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;다른 두 수를 입력하세요(끝내려면 q): \u0026#34;; } } 객체를 예외로 사용하기 기하 평균(geometric mean) 두 수의 곱의 제곱근이다. 수가 음수이면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 예외를 클래스로 만든다. class BadHMean { private: double v1; double v2; public: BadHMean(double a = 0, double b = 0) : v1(a), v2(b) {} void Mesg() { // 문자열을 출력한다. cout \u0026lt;\u0026lt; \u0026#34;HMean()에 x = -y 는 허용되지 않습니다. \\n\u0026#34;; } }; class BadGMean { public: // 데이터가 public 이다. double v1; double v2; BadGMean(double a = 0, double b = 0) : v1(a), v2(b) {} const char* Mesg() { // 문자열을 리턴한다. return \u0026#34;GMean()에 음수는 허용되지 않습니다. \\n\u0026#34;; } }; double HMean(double x, double y) { if (x == -y) throw BadHMean(x, y); return 2.0 * x * y / (x + y); } double GMean(double x, double y) { if (x \u0026lt; 0 || y \u0026lt; 0) throw BadGMean(x, y); return sqrt(x * y); } int main() { double x, y, z; cout \u0026lt;\u0026lt; \u0026#34;두 수를 입력하세요: \u0026#34;; while (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { try { z = HMean(x, y); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 조화평균은 \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 기하평균은 \u0026#34; \u0026lt;\u0026lt; GMean(x, y) \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;다른 두 수를 입력하세요(끝내려면 q): \u0026#34;; } catch (BadHMean\u0026amp; bg) { bg.Mesg(); cout \u0026lt;\u0026lt; \u0026#34;두 수를 새로 입력하세요: \u0026#34;; continue; // 계속할 수 있다. } catch (BadGMean\u0026amp; hg) { cout \u0026lt;\u0026lt; hg.Mesg(); // public 멤버에 접근한다. cout \u0026lt;\u0026lt; \u0026#34;사용된 값: \u0026#34; \u0026lt;\u0026lt; hg.v1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hg.v2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;죄송합니다. 더 이상 진행할 수 없습니다. 프로그램을 종료합니다.\u0026#34; \u0026lt;\u0026lt; endl; break; // 종료한다. } } } 스택 풀기(unwinding the stack)\n예외가 발생하면, 호출한 함수를 타고 계속 되돌아가서 try와 catch가 있는 곳으로 되돌아간다. 마치 함수 리턴과 마찬가지다. 가장 중요한건, 스택에 올라와 있는 모든 자동 클래스 객체들에 대해 파괴자가 호출된다는 것이다.\nreturn구문은 해당 함수가 스택에 올려 놓은 객체들만 처리한다. 하지만 throw구문은 try구문과 throw구문 사이에 개입된 모든 함수들이 스택에 올려 놓은 객체를 모두 처리한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // 생략 class BadHMean {}; class BadGMean {}; double HMean(double x, double y) {} double GMean(double x, double y) {} // 객체의 파괴를 보기 위한 클래스 class Demo { private: string word; public: Demo(const string\u0026amp; str) { word = str; cout \u0026lt;\u0026lt; \u0026#34;Demo가 생성되었다 : \u0026#34; \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; } ~Demo() { cout \u0026lt;\u0026lt; \u0026#34;Demo가 파괴되었다 : \u0026#34; \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; } void Show() const { cout \u0026lt;\u0026lt; \u0026#34;Demo가 생존하고 있다 : \u0026#34; \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; } }; double Means(double a, double b) { double am, hm, gm; Demo d2(\u0026#34;Means()\u0026#34;); // Demo 2 am = (a + b) / 2.0; // 산술 평균 try { hm = HMean(a, b); gm = GMean(a, b); } catch (BadHMean\u0026amp; bg) // HMean만 catch한다. { cout \u0026lt;\u0026lt; \u0026#34;Means()에서 잡힘\u0026#34; \u0026lt;\u0026lt; endl; bg.Mesg(); throw; // main()에 예외를 보낸다. } d2.Show(); return (am + hm + gm) / 3.0; } int main() { double x, y, z; { Demo d1(\u0026#34;main()\u0026#34;); // Demo 1 cout \u0026lt;\u0026lt; \u0026#34;두 수를 입력하세요: \u0026#34;; while (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { try { z = Means(x, y); // Means() 호출 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;의 조화평균은 \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;입니다. \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;다른 두 수를 입력하세요(끝내려면 q): \u0026#34;; } catch (BadHMean\u0026amp; bg) { bg.Mesg(); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;두 수를 새로 입력하세요: \u0026#34;; continue; } catch (BadGMean\u0026amp; hg) // GMean은 여기서 catch한다. { cout \u0026lt;\u0026lt; hg.Mesg(); cout \u0026lt;\u0026lt; \u0026#34;사용된 값: \u0026#34; \u0026lt;\u0026lt; hg.v1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; hg.v2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;죄송합니다. 더 이상 진행할 수 없습니다. 프로그램을 종료합니다.\u0026#34; \u0026lt;\u0026lt; endl; break; } } d1.Show(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Demo가 생성되었다 : main() 두 수를 입력하세요: 6 12 Demo가 생성되었다 : Means() Demo가 생존하고 있다 : Means() Demo가 파괴되었다 : Means() // Means()함수 종료로 파괴되었다. 6, 12의 조화평균은 8.49509입니다. 다른 두 수를 입력하세요(끝내려면 q): 6 -6 Demo가 생성되었다 : Means() Means()에서 잡힘 HMean()에 x = -y 는 허용되지 않습니다. Demo가 파괴되었다 : Means() // throw 구문으로 Means()함수가 종료되었다. 파괴자도 호출된다. HMean()에 x = -y 는 허용되지 않습니다. 두 수를 새로 입력하세요: 6 -8 Demo가 생성되었다 : Means() Demo가 파괴되었다 : Means() // throw 구문으로 Means()함수가 종료되었다. 파괴자도 호출된다. GMean()에 음수는 허용되지 않습니다. 사용된 값: 6, -8 죄송합니다. 더 이상 진행할 수 없습니다. 프로그램을 종료합니다. Demo가 생존하고 있다 : main() Demo가 파괴되었다 : main() // 프로그램 종료로 파괴되었다. catch 블록이 참조를 지정할지라도 컴파일러는 언제나 예외가 발생하면 임시 복사본을 만든다. 왜냐하면, 예외가 발생한 함수 블록이 끝나면 객체는 존재하지 않기 때문이다. 추가적으로, 기초 클래스 참조로 파생 클래스를 참조할 수 있기 때문이겠다. 파생 순서의 역순으로 catch블록들을 배치해야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A {}; class B : public A {}; class C : public B {}; void Test() { //... if (aa) throw A(); if (bb) throw B(); if (cc) throw C(); } int main() { //... try { Test(); } catch(C\u0026amp; c) { } // C가 먼저 와야 한다. catch(B\u0026amp; b) { } catch(A\u0026amp; a) { } // A가 먼저오면 모든 예외를 A가 catch한다. } 어떤 예외라도 포착하는 방법 1 catch(...) {} exception 클래스 예외 클래스의 기초 클래스로 exception 클래스를 사용할 수 있다. exception 헤더파일에 포함되어 있다. what()이라는 하나의 가상 멤버 함수가 주어진다. 이것을 재정의할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;exception\u0026gt; class BadHMean : public exception { public: // what() 가상함수를 재정의한다. virtual const char * what() { return \u0026#34;HMean()에 x = -y 는 허용되지 않습니다. \\n\u0026#34;; } }; int main() { //... try { } catch (exception\u0026amp; e) // exception 형식으로 포착한다. { cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } } logic_error 클래스와 runtime_error 클래스 stdexcept 헤더파일에 포함되어 있다. exception으로 부터 public으로 파생된다. 다음과 같이, string 매개변수를 받는 생성자를 가지고 있다. 이것은 what()함수의 리턴값으로 사용한다. 1 2 3 4 5 class logic_error : public exception { public: explicit logic_error(const string\u0026amp; what_arg); }; logic_error 클래스 일반적인 논리 에러들을 서술한다. domain_error 예를들어, 아크사인의 정의역은 -1에서 +1까지이다. 이것을 벗어날 때 이 예외를 발생시킬 수 있다. 정의역 (Domain): f: X → Y에서 X를 함수 f의 정의역이라고 한다. 치역 (Range): f(x)가 치역이다. invalid_argument 기대하지 않는 값이 함수에 전달되었을 때. length_error 원하는 액션을 취할 만큼 충분한 공간을 사용할 수 없을 때. out_of_range 인덱싱 에러. runtime_error 클래스 실행하는 동안에 나타날 수 있는 에러를 서술한다. range_error 언더플로나 오버플로 없이 계산 결과가 함수의 절절한 치역을 벗어날 때. overflow_error 정수형이나, 부동소수점형 계산에서 나타낼 수 있는 최대 크기보다 더 큰 값을 산출하는 계산을 할 때. underflow_error 예를 들어, 부동소수점 계산에서 나타낼 수 있는 최소 크기보다 더 작은 값을 산출하는 계산을 할 때. C++이 new를 사용할 때 일어나는 메모리 대입 문제를 해결하는 두 가지 방법 (1) new가 널 포인터를 리턴한다. (2) new가 bad_alloc 예외를 발생시킨다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct Big { double stuff[20000]; }; int main() { Big* pb; try { cout \u0026lt;\u0026lt; \u0026#34;큰 메모리 블록 대입을 요청합니다. \u0026#34; \u0026lt;\u0026lt; endl; pb = new Big[10900]; // 큰 메모리를 대입한다. cout \u0026lt;\u0026lt; \u0026#34;요청을 통과하였습니다. \u0026#34; \u0026lt;\u0026lt; endl; } catch (bad_alloc\u0026amp; ba) // new가 bad_alloc 예외를 발생시킨다. (2) { cout \u0026lt;\u0026lt; \u0026#34;예외가 감지되었습니다!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ba.what() \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } cout \u0026lt;\u0026lt; \u0026#34;메모리 블록이 성공적으로 대입되었습니다. \u0026#34; \u0026lt;\u0026lt; endl; pb[0].stuff[0] = 4; cout \u0026lt;\u0026lt; pb[0].stuff[0] \u0026lt;\u0026lt; endl; delete[] pb; } 1 2 3 큰 메모리 블록 대입을 요청합니다. 예외가 감지되었습니다! bad allocation // ba.what()를 출력한 결과 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { Big* pb; cout \u0026lt;\u0026lt; \u0026#34;큰 메모리 블록 대입을 요청합니다. \u0026#34; \u0026lt;\u0026lt; endl; pb = new (nothrow) Big[10900]; // new가 널 포인터를 리턴한다. (1) if (pb == nullptr) { cout \u0026lt;\u0026lt; \u0026#34;메모리 블록 대입에 실패하였습니다. \u0026#34; \u0026lt;\u0026lt; endl; exit(EXIT_FAILURE); } cout \u0026lt;\u0026lt; \u0026#34;메모리 블록이 성공적으로 대입되었습니다. \u0026#34; \u0026lt;\u0026lt; endl; pb[0].stuff[0] = 4; cout \u0026lt;\u0026lt; pb[0].stuff[0] \u0026lt;\u0026lt; endl; delete[] pb; } 1 2 큰 메모리 블록 대입을 요청합니다. 메모리 블록 대입에 실패하였습니다. 예외, 클래스, 상속 예외, 클래스, 상속은 서로 상호작용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // Sales.h #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Sales { public: enum { MONTHS = 12 }; // 클래스 정의 안에 내포된 예외 클래스. class bad_index : public logic_error { private: int bi; public: explicit bad_index(int ix, const string\u0026amp; s = \u0026#34;Sales 객체에서 인덱스 에러 발생! \\n\u0026#34;); int bi_val() const { return bi; } virtual ~bad_index() throw() {} }; explicit Sales(int yy = 0); Sales(int yy, const double* gr, int n); virtual ~Sales() { } int Year() const { return year; } virtual double operator[](int i) const; virtual double\u0026amp; operator[](int i); private: double gross[MONTHS]; int year; }; class LabeledSales : public Sales { public: class nbad_index : public Sales::bad_index // 예외 클래스를 파생시킨다. { private: string lbl; public: nbad_index(const string\u0026amp; lb, int ix, const string\u0026amp; s = \u0026#34;LabeledSales 객체에서 인덱스 에러 발생! \\n\u0026#34;); const string\u0026amp; label_val() const { return lbl; } virtual ~nbad_index() throw() {} }; explicit LabeledSales(const string\u0026amp; lb = \u0026#34;none\u0026#34;, int yy = 0); LabeledSales(const string\u0026amp; lb, int yy, const double* gr, int n); virtual ~LabeledSales() { } const string\u0026amp; Label() const { return label; } virtual double operator[](int i) const; virtual double\u0026amp; operator[](int i); private: string label; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Sales.cpp // ... // 배열에서 벗어나는 인덱스에 접근하면 예외가 발생한다. double Sales::operator[](int i) const { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw bad_index(i); return gross[i]; } double\u0026amp; Sales::operator[](int i) { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw bad_index(i); return gross[i]; } double LabeledSales::operator[](int i) const { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw nbad_index(Label(), i); return Sales::operator[](i); } double\u0026amp; LabeledSales::operator[](int i) { if (i \u0026lt; 0 || i \u0026gt;= MONTHS) throw nbad_index(Label(), i); return Sales::operator[](i); } // ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 int main() { double vals1[12] = { 1220, 1100, 1122, 2212, 1232, 2334, 2884, 2393, 3302, 2922, 3002, 3544 }; double vals2[12] = { 12, 11, 22, 21, 32, 34, 28, 29, 33, 29, 32, 35 }; Sales sales1(2011, vals1, 12); LabeledSales sales2(\u0026#34;Blogstar\u0026#34;, 2012, vals2, 12); cout \u0026lt;\u0026lt; \u0026#34;첫번째 try 블록\\n\u0026#34;; try { cout \u0026lt;\u0026lt; sales2[12] \u0026lt;\u0026lt; endl; // 배열을 넘어가는 인덱스에 접근한다. (LabeledSales) } catch (LabeledSales::nbad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;Company: \u0026#34; \u0026lt;\u0026lt; bad.label_val() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } catch (Sales::bad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;\\n두번째 try 블록\\n\u0026#34;; try { sales1[20] = 23345; // 배열을 넘어가는 인덱스에 접근한다. (Sales) } catch (LabeledSales::nbad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;Company: \u0026#34; \u0026lt;\u0026lt; bad.label_val() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } catch (Sales::bad_index\u0026amp; bad) { cout \u0026lt;\u0026lt; bad.what(); cout \u0026lt;\u0026lt; \u0026#34;bad index: \u0026#34; \u0026lt;\u0026lt; bad.bi_val() \u0026lt;\u0026lt; endl; } } 잘못된 예외 예외가 발생한 후에도 문제를 일으킬 수 있는 두 가지 가능성이 있다.\n1. 기대하지 않는 예외(unexpected exception) 발생한 예외는 예외 지정자 리스트에 있는 데이터형들 중의 어느 하나와 일치해야한다. 만약 일치하지 않으면, 기본적으로 프로그램이 중지된다. 2. 포착되지 않는 예외(uncaught exception) 예외는 반드시 포착되어야 한다. 만약 포착되지 않으면, (try나 catch 구문이 없을 때) 기본적으로 프로그램이 중지된다. 이 두 가지 예외가 발생했을 때, 프로그램이 중지가 아닌 다른 응답을 하도록 사용자가 바꿀 수 있다.\n2. 포착되지 않는 예외\n이 예외가 발생하면 terminate()함수가 호출되고, 이 함수가 abort()를 호출한다. terminate()함수가 abort()말고 다른 함수를 호출하도록 바꿀 수 있겠다. terminate()함수의 행동을 바꾸는 set_terminate()함수를 사용하면 된다. terminate()함수와 set_terminate()함수는 exception 헤더 파일에 선언되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;exception\u0026gt; using namespace std; // 포착되지 않는 예외 발생 시 이렇게 행동하라. void myQuit() // 형식은 매개변수와 리턴형이 void여야한다. { cout \u0026lt;\u0026lt; \u0026#34;포착되지 않는 예외가 발생하여 프로그램을 중지시킵니다. \u0026#34; \u0026lt;\u0026lt; endl; exit(5); // 종료 상태값 5를 가지고 exit() 함수를 호출한다. } int main() { set_terminate(myQuit); // 함수를 설정한다. throw; // 포착되지 않는 예외. } 1. 기대하지 않는 예외\n이 예외가 발생하면 unexpected()함수가 호출되고, 이 함수가 terminate()를 호출한다. 그리고 terminate()가 abort()를 호출한다.\nunexpected()함수의 행동을 바꾸는 set_unexpected()함수를 사용하면 된다.\n이 함수들도 exception 헤더 파일에 선언되어 있다.\nset_unexpected()함수의 선택지\n(1) terminate() 또는 abort() 또는 exit()을 사용해서 프로그램을 종료시킬 수 있다. (2) 새로운 예외를 발생시킬 수 있다. 예외가 이전과 일치하면, 새로 발생된 예외와 일치하면 catch 블록을 찾는다. 예외가 이전과 불일치하고, 이전 예외 지정에 bad_exception형이 없으면 terminate()를 호출한다. 예외가 이전과 불일치하고, 이전 예외 지정에 bad_exception형이 있으면 bad_exception형의 예외로 대체된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // **** 예상대로 작동하지 않아서 확인이 필요합니다. *** void myUnexpected() { throw; // 새로운 예외를 발생시킨다. } double Argh(double, double) throw(out_of_range, bad_exception) // out_of_range, bad_exception의 예외를 발생시킨다. { throw length_error(\u0026#34;length_error\u0026#34;); } int main() { set_unexpected(myUnexpected); try { int x = Argh(1.0, 2.0); } catch (out_of_range\u0026amp; ex) { cout \u0026lt;\u0026lt; \u0026#34;out_of_range\u0026#34; \u0026lt;\u0026lt; endl; } catch (bad_exception\u0026amp; ex) { cout \u0026lt;\u0026lt; \u0026#34;bad_exception\u0026#34; \u0026lt;\u0026lt; endl; // 예외 지정에 bad_exception이 있으므로 이것이 실행된다. } } 예외 주의사항 예외를 사용하면 프로그램의 크기가 커지고, 실행 속도가 떨어진다. 예외 지정들은 템플릿과는 잘 어울리지 않는다. 왜냐하면, 템플릿은 특수화에 따라 서로 다른 종류의 예외를 발생시킬 수 있기 때문이다. 예외와 동적 메모리 대입도 항상 잘 어울리는 것은 아니다. 1 2 3 4 5 6 7 8 9 void Test() { int* ar = new int[10]; throw; // 예외 발생! delete[] ar; // 실행되지 않는다! return; } 위와 같은 코드에서 메모리 누수를 다음 코드와 같이 해결할 수 있다. 하지만, 실수로 무언가를 빠트리거나 다른 에러를 저지를 가능성을 높인다. 또 다른 해결책은 auto_ptr을 사용하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void Test() { int* ar = new int[10]; try { throw exception(); } catch (exception\u0026amp; ex) { delete[] ar; // 메모리를 해제하고 throw; // 한번 더 예외를 발생시킨다. } delete[] ar; return; } 예외 지정(expection specification) 함수에서 발생 가능한 예외의 종류를 명확하게 지정할 수 있다. 하지만 예외지정이 의도대로 지정되지 않는 문제가 있어서 C++11표준은 예외 지정을 사용하지 말 것을 권고한다. 그러나 예외를 발생하지 않는 함수에 대해서 명시할 필요가 있다고 판단하였고, noexcept키워드를 추가하였다. 1 2 void Function1() throw(bad_dog) // bad_dog 타입 예외를 발생시킨다. void Function2() throw() // 예외를 발생시키지 않는다. 1 void Function3() noexcept // 예외를 발생시키지 않는다. ","date":"2022-03-22T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-15-2/","title":"[C++ Primer Plus] Chapter 15. (2) 예외"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n클래스 프렌드 지금까지는 프렌드 함수를 살펴봤는데, 클래스도 프렌드가 될 수 있다.\nTV 클래스와 리모콘 클래스를 생각해보자.\n둘은 is-a 관계도 아니며 has-a 관계도 아니다. 하지만 리모콘은 TV의 상태를 변경할 수 있다. 이것은 리모콘 클래스를 TV 클래스의 프렌드로 만들어야 한다는 것을 암시한다. 프렌드 선언은 private, protected, public 부분 어디에 두던 상관 없다.\n컴파일러가 Remote 클래스를 처리하기 전에 Tv 클래스에 대해 알아야 한다.\n방법 (1) Tv 클래스를 먼저 정의한다. (아래 예제) (2) 사전 선언(forward declaration) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Tv // Tv를 먼저 선언해서 Remote가 Tv를 알도록 한다. (1) { private: int state; // on 또는 off int volume; // 디지털 볼륨이라고 가정한다 int maxchannel; // 최대 채널 수 int channel; // 현재 설정된 채널 int mode; // 지상파 방송 또는 케이블 방송 int input; // TV 입력 또는 DVD 입력 public: // friend 선언은 어디에 있어도 상관 없다. friend class Remote; // Tv의 private 부분에 Remote의 모든 메서드들이 접근할 수 있다. enum { Off, On }; enum { MinVal, MaxVal = 20 }; enum { Antenna, Cable }; enum { TV, DVD }; Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {} void OnOff() { state = (state == On) ? Off : On; } // state = state ^ 1; 혹은 state ^= 1; 와 같다. (XOR) bool IsOn() const { return state == On; } bool VolUp(); bool VolDown(); void ChanUp(); void ChanDown(); void SetMode() { mode = (mode == Antenna) ? Cable : Antenna; } void SetInput() { input = (input == TV) ? DVD : TV; } void Settings() const; }; class Remote { private: int mode; // TV 컨트롤 또는 or DVD 컨트롤 public: Remote(int m = Tv::TV) : mode(m) {} void OnOff(Tv\u0026amp; t) { t.OnOff(); } bool VolUp(Tv\u0026amp; t) { return t.VolUp(); } bool VolDown(Tv\u0026amp; t) { return t.VolDown(); } void ChanUp(Tv\u0026amp; t) { t.ChanUp(); } void ChanDown(Tv\u0026amp; t) { t.ChanDown(); } void SetChan(Tv\u0026amp; t, int c) { t.channel = c; } // Tv의 private 멤버인 channel에 접근할 수 있다. void SetMode(Tv\u0026amp; t) { t.SetMode(); } void SetInput(Tv\u0026amp; t) { t.SetInput(); } }; 만약에 프렌드가 아니었다면? Tv 클래스의 private 부분을 public으로 만들어야 한다. 혹은 Tv와 Remote가 함께 들어간 클래스를 만들어야 한다. 이렇게 하면 하나의 Remote로 여러대의 Tv를 제어하는 것을 반영하지 못할 것이다. 프렌드 멤버 함수 위의 예시에서 유일하게 프렌드 자격이 필요한 부분은 Remote::SetChan() 뿐이다.\n클래스 전체를 프렌드로 하지 않고 필요한 메서드들만 프렌드로 만들면 어떨까?\nTv 클래스 안에 프렌드 자격을 부여할 Remote::SetChan()를 선언할 수 있다.\n하지만, 이렇게 하려면 컴파일러가 Remote 클래스 선언을 먼저 알아서, 그 안에 SetChan() 메서드가 있다는 걸 알아야 한다. 그렇다고 Remote 정의를 Tv 정의 앞에 두기에는, Remote::SetChan()이 Tv를 사용하기 때문에 Remote도 Tv를 먼저 알아야 한다. 1 2 3 4 5 class Tv { // Remote 클래스 선언을 먼저 알아야 한다. friend void Remote::SetChan(Tv\u0026amp; t, int c); // Tv의 private 부분에 Remote의 특정 메서드만 접근할 수 있다. }; 이러한 순환 종속을 피하는 방법은, 사전 선언을 사용하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 class Tv; // Remote가 Tv를 알도록 한다. (2) class Remote { void Remote::SetChan(Tv\u0026amp; t, int c); // 사전 선언을 했으므로, Remote는 Tv를 알고 있다. }; class Tv { friend void Remote::SetChan(Tv\u0026amp; t, int c); // Tv는 Remote의 선언을 알고 있다. }; 순서를 반대로 하는 것은 안 된다. 왜냐하면, Tv는 Remote 안에 SetChan() 메서드가 있는 걸 먼저 알아야하기 때문이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // (X) class Remote; class Tv { friend void Remote::SetChan(Tv\u0026amp; t, int c); // Tv는 Remote 안에 SetChan() 메서드가 있는 걸 알아야한다. } class Remote { void Remote::SetChan(Tv\u0026amp; t, int c); } 또 다른 문제가 있다. Remote::OnOff()에서 Tv::OnOff()를 호출한다. 이것은 Remote가 Tv의 클래스 선언을 미리 알아야 하며, 그래서 Tv가 어떤 메서드들을 가지고 있는지 알아야 한다는 것을 의미한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Tv; class Remote { void OnOff(Tv\u0026amp; t) { t.OnOff(); // Tv의 클래스 선언을 먼저 알아서 그 안에 OnOff() 메서드가 있다는 걸 알아야 한다. } }; class Tv { void OnOff(); }; 해결책 인라인 함수로 만들고 싶다면, -Remote 클래스 선언 안에는 메서드를 선언만 하고, 정의는 Tv 클래스 뒤에 둔다. 혹은 인라인 함수로 만들지 않고, 정의를 .cpp 파일에 넣는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Tv; class Remote { void OnOff(Tv\u0026amp; t); // 선언만 한다. }; class Tv { void OnOff(); }; // Tv 뒤에 (Tv 클래스 선언을 알고 나서) 정의를 한다. (인라인) inline void Remote::OnOff(Tv\u0026amp; t) { t.OnOff(); } 상호 프렌드와 공유 프렌드 상호 프렌드(mutual friend) 각 클래스가 서로에 대해 프렌드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Tv { friend class Remote; // Remote의 모든 메서드는 Tv의 private 부분에 접근 가능하다. public: void Buzz(Remote\u0026amp; r); // Remote의 메서드를 사용하려면 Remote 클래스 선언 뒤에 나와야 하므로 일단 선언만한다. void VolUp() { } }; class Remote { friend class Tv; // Tv의 모든 메서드는 Remote의 private 부분에 접근 가능하다. public: void VolUp(Tv \u0026amp; t) { t.VolUp(); } }; // Remote 뒤에 정의를 둔다. inline void Tv::Buzz(Remote \u0026amp; r) { // ... } 공유 프렌드 하나의 함수가 서로 다른 두 클래스의 private 데이터 모두에 접근해야 할 때 사용한다. 한 클래스의 멤버로 그 함수를 두고, 다른 클래스에서 friend로 선언할수도 있겠다. 하지만 때로는, 두 클래스 모두에 대해 프렌드로 만드는 것이 합리적인 경우가 있다. 예를 들어, 측정하는 장치인 Probe 클래스와 분석하는 장치인 Analyzer 클래스가 있다고 하자. 각 클래스는 내부에 시계를 하나씩 가지고 있는데, 그 두 시계를 서로 일치시키고 싶다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Analyzer; class Probe { // Sync 함수들은 Probe의 private 부분에 접근 가능하다. friend void Sync(Analyzer\u0026amp; a, const Probe\u0026amp; p); // a를 p에 맞춘다. friend void Sync(Probe\u0026amp; p, const Analyzer\u0026amp; a); // p를 a에 맞춘다. }; class Analyzer { // Sync 함수들은 Analyzer private 부분에 접근 가능하다. friend void Sync(Analyzer\u0026amp; a, const Probe\u0026amp; p); friend void Sync(Probe\u0026amp; p, const Analyzer\u0026amp; a); }; // 프렌드 함수들을 정의한다. inline void Sync(Analyzer\u0026amp; a, const Probe\u0026amp; p) {} inline void Sync(Probe\u0026amp; p, const Analyzer\u0026amp; a) {} 내포 클래스 다른 클래스 안에 선언된 클래스를 내포 클래스라 한다. 한 클래스 안에서만 지역적으로 알려진다. 일반적으로, 다른 클래스 구현을 지원하거나, 이름 충돌을 막기 위해 사용된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Queue { private: class Node // Queue 클래스 안에 Node 클래스가 내포되었다. { public: int item; Node * next; Node(const Item\u0026amp; i) : item(i), next(nullptr) {} }; public: void Enqueue(const Item \u0026amp; item) { // ... Node * add = new Node(item); // 좀 더 간단해졌다. //... } }; 1 2 3 // 만약에 Node 클래스의 생성자를 .cpp 파일에 넣고 싶다면 이렇게 하면 된다. // 사용 범위 결정 연산자를 두 번 쓴다. Queue::Node::Node(const Item\u0026amp; i) : item(i), next(nullptr) {} 내포 클래스, 내포 구조체, 내포 열거체의 사용 범위 특성 내포하는 클래스에 선언된 장소 내포하는 클래스에서 사용 여부 내포하는 클래스에서 파생된 클래스에서 사용 여부 바깥 세계에서 사용 여부 private 부분 O X X protected 부분 O O X public 부분 O O O (클래스 제한자 사용) 1 2 3 4 5 6 7 8 9 10 class Team { public: // public 부분에 선언됨 class Coach {}; }; int main() { Team::Coach c; // 바깥에서 클래스 제한자 사용해서 접근 가능 } 접근 제어 어떤 특정 클래스가 사용 범위 안에 들어오면, 일반적인 접근 제어 규칙(public, protected, private)이 접근 가능 여부를 결정한다. Queue 예제에서 Node의 모든 데이터가 public으로 선언되었다. 이것은 일반적인 관행에 위배된다. 하지만 Queue 클래스의 private 부분에 Node가 선언되었으므로, 바깥 세계에서는 보이지 않는다. 템플릿에 내포된 클래스 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // QueueTP.h template \u0026lt;class Item\u0026gt; class QueueTP { private: enum { Q_SIZE = 10 }; class Node // 내포된 클래스 Node { public: Item item; // 포괄적 데이터형 Item을 사용한다. Node* next; Node(const Item\u0026amp; i) :item(i), next(0) { } }; Node* front; Node* rear; int items; const int qsize; QueueTP(const QueueTP\u0026amp; q) : qsize(0) {} QueueTP\u0026amp; operator=(const QueueTP\u0026amp; q) { return *this; } public: QueueTP(int qs = Q_SIZE); ~QueueTP(); bool IsEmpty() const { return items == 0; } bool IsFull() const { return items == qsize; } int QueueCount() const { return items; } bool Enqueue(const Item\u0026amp; item); bool Dequeue(Item\u0026amp; item); }; template \u0026lt;class Item\u0026gt; QueueTP\u0026lt;Item\u0026gt;::QueueTP(int qs) : qsize(qs) { front = rear = 0; items = 0; } template \u0026lt;class Item\u0026gt; QueueTP\u0026lt;Item\u0026gt;::~QueueTP() { Node* temp; while (front != 0) { temp = front; front = front-\u0026gt;next; delete temp; } } template \u0026lt;class Item\u0026gt; bool QueueTP\u0026lt;Item\u0026gt;::Enqueue(const Item\u0026amp; item) { if (IsFull()) return false; Node* add = new Node(item); items++; if (front == 0) front = add; else rear-\u0026gt;next = add; rear = add; return true; } template \u0026lt;class Item\u0026gt; bool QueueTP\u0026lt;Item\u0026gt;::Dequeue(Item\u0026amp; item) { if (front == 0) return false; item = front-\u0026gt;item; items--; Node* temp = front; front = front-\u0026gt;next; delete temp; if (items == 0) rear = 0; return true; } ","date":"2022-03-22T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-15-1/","title":"[C++ Primer Plus] Chapter 15. (1) 클래스 프렌드와 프렌드 멤버 함수, 내포 클래스"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n코드의 재활용성을 높이는 방법 public 상속 컨테인먼트(containment) = 컴포지션(composition) = 레이어링(layering) private 상속 protected 상속 클래스 템플릿 (이것에 대해 알아보겠다.) 클래스 템플릿 Stack과 Queue를 구현한 클래스를 떠올려보자. 저장되는 객체형이 double일 수도 있고, string일 수도 있다. 그렇다면 바뀔 때마다 코드를 새로 작성할 것인가? 포괄적인(데이터형과 무관한) 방식으로 정의하면 좋지 않을까? 클래스 템플릿의 정의 템플릿들은 함수가 아니다. 그래서 개별적으로 컴파일할 수 없다. 따라서 모든 템플릿 관련 정보를 헤더 파일에 집어 넣는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // Stack.h template \u0026lt;class Type\u0026gt; // 템플릿 클래스이다. class Stack { private: enum { MAX = 10 }; Type items[MAX]; int top; public: Stack(); bool IsEmpty(); bool IsFull(); bool Push(const Type\u0026amp; item); bool Pop(Type\u0026amp; item); }; template \u0026lt;class Type\u0026gt; // 템플릿 멤버 함수이다. Stack\u0026lt;Type\u0026gt;::Stack() // 클래스 제한자가 Stack\u0026lt;Type\u0026gt; 이다. 인라인이면 생략가능하다. { top = 0; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::IsEmpty() { return top == 0; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::IsFull() { return top == MAX; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Push(const Type\u0026amp; item) { if (top \u0026lt; MAX) { items[top++] = item; return true; } return false; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Pop(Type\u0026amp; item) { if (top \u0026gt; 0) { item = items[--top]; return true; } return false; } 템플릿 클래스의 사용 구체화를 요청해야 템플릿 클래스가 생성된다. 아래 예제에서는 두 개의 서로 다른 클래스 선언과 메서드들의 집합이 생성될 것이다. 1 2 Stack\u0026lt;int\u0026gt; iStack; // int 값들의 스택을 생성한다. Stack\u0026lt;double\u0026gt; dStack; // double 값들의 스택을 생성한다. 일반적인 함수 템플릿과 다르게, 사용하려는 데이터형을 명시적으로 제공해야 한다. Type과 같은 포괄적인 데이터형 식별자를 데이터형 매개변수라고 한다. 1 2 3 4 5 6 7 // 일반적인 함수 템플릿 template \u0026lt;class T\u0026gt; void Simple(T t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } Simple(2); // 컴파일러가 데이터형을 판단해서 결정한다. Simple(\u0026#34;two\u0026#34;); 포인터들의 Stack을 만드면 어떨까?\nstring 데이터형을 사용하는 원본 코드\n1 2 3 4 Stack\u0026lt;string\u0026gt; ss; string po; cin \u0026gt;\u0026gt; po; [시도 1] po를 char * 로 바꿔본다. 입력이 안 된다. 1 2 3 4 Stack\u0026lt;char *\u0026gt; sc; char* po; cin \u0026gt;\u0026gt; po; // (X) 저장 공간도 없는 곳에 저장할 수 없다. [시도 2] po를 char 배열형으로 바꿔본다. 입력이 된다. 하지만 Pop()에서 불화를 일으킨다. 1 2 3 4 5 6 7 8 Stack\u0026lt;char *\u0026gt; sc; char po[40]; cin \u0026gt;\u0026gt; po; // (O) //... sc.Pop(po); 1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Pop(Type\u0026amp; item) // 배열이름을 참조한다. { if (top \u0026gt; 0) { item = items[--top]; // 배열이름에 대입할 수는 없다. return true; } return false; } [시도 3] po를 char * 로 바꾸고 저장 공간을 대입한다. 입력이 되고, 괜찮지만, 근본적인 문제가 발생한다. po가 늘 같은 메모리 위치를 지시하므로, 푸시를 여러번 해도 동일한 주소를 스택에 넣는다. 1 2 3 4 5 6 7 8 9 10 Stack\u0026lt;char *\u0026gt; sc; char* po = new char[40]; cin \u0026gt;\u0026gt; po; // (O) sc.Push(po); cin \u0026gt;\u0026gt; po; sc.Push(po); // 매번 같은 주소가 들어간다. sc.Pop(po); // 매번 같은 주소가 나온다. 포인터들의 스택을 바르게 만드는 방법 char* po 대신 포인터들의 배열을 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 template \u0026lt;class Type\u0026gt; class Stack { private: enum { SIZE = 10 }; int stacksize; Type* items; // 스택 항목들을 저장한다. int top; public: explicit Stack(int ss = SIZE); Stack(const Stack\u0026amp; st); // 복사 생성자를 제공한다. ~Stack() { delete[] items; } // 파괴자를 제공한다. bool IsEmpty() { return top == 0; } bool IsFull() { return top == stacksize; } bool Push(const Type\u0026amp; item); bool Pop(Type\u0026amp; item); // 클래스 사용 범위 안에서는 Stack\u0026lt;Type\u0026gt;을 Stack으로 표현할 수 있다. Stack\u0026amp; operator=(const Stack\u0026amp; st); // 대입 연산자를 제공한다. }; template \u0026lt;class Type\u0026gt; Stack\u0026lt;Type\u0026gt;::Stack(int ss) : stacksize(ss), top(0) { items = new Type[stacksize]; } template \u0026lt;class Type\u0026gt; Stack\u0026lt;Type\u0026gt;::Stack(const Stack\u0026amp; st) { stacksize = st.stacksize; top = st.top; items = new Type[stacksize]; for (int i = 0; i \u0026lt; top; i++) items[i] = st.items[i]; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Push(const Type\u0026amp; item) { if (top \u0026lt; stacksize) { items[top++] = item; return true; } return false; } template \u0026lt;class Type\u0026gt; bool Stack\u0026lt;Type\u0026gt;::Pop(Type\u0026amp; item) { if (top \u0026gt; 0) { item = items[--top]; return true; } return false; } template \u0026lt;class Type\u0026gt; Stack\u0026lt;Type\u0026gt;\u0026amp; Stack\u0026lt;Type\u0026gt;::operator=(const Stack\u0026lt;Type\u0026gt;\u0026amp; st) { if (this == \u0026amp;st) return *this; delete[] items; stacksize = st.stacksize; top = st.top; items = new Type[stacksize]; for (int i = 0; i \u0026lt; top; i++) items[i] = st.items[i]; return *this; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { Stack\u0026lt;const char*\u0026gt; st(5); const char* inputs[10] = { \u0026#34;Bob\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Amy\u0026#34;, \u0026#34;Amanda\u0026#34;, \u0026#34;Kal\u0026#34;, \u0026#34;Lily\u0026#34;, \u0026#34;Andy\u0026#34;, \u0026#34;Harry\u0026#34;, \u0026#34;Kim\u0026#34;, \u0026#34;Ron\u0026#34;}; const char* outputs[10]; st.Push(inputs[0]); st.Push(inputs[1]); st.Push(inputs[2]); st.Push(inputs[3]); st.Pop(outputs[0]); cout \u0026lt;\u0026lt; outputs[0] \u0026lt;\u0026lt; endl; // inputs[3] \u0026#34;Amanda\u0026#34; st.Push(inputs[4]); st.Pop(outputs[1]); cout \u0026lt;\u0026lt; outputs[1] \u0026lt;\u0026lt; endl; // inputs[4] \u0026#34;Kal\u0026#34; // ... } 데이터형이 아닌, 수식 매개변수(expression argument) 조건 (1) 정수형 (2) 열거형 (3) 참조 (4) 포인터 수식 매개변수의 값을 변경하거나 그것의 주소를 얻을 수 없다. 장점 생성자 접근 방식은 new와 delete에 의해 관리되는 힙 메모리를 사용하지만, 수식 매개변수 접근 방식은 스택 메모리를 사용한다. 따라서 더 빠르다. 단점 수식 매개변수가 다르면 자신만의 템플릿을 각각 생성한다. 생성자 접근 방식은 stacksize를 멤버로 가지고 있기 때문에 좀 더 융통성이 있다. 예를 들면, 이것으로 다른 크기의 배열에 대입하거나, 크기를 조절할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template \u0026lt;class T, int n\u0026gt; // int n은 수식 매개변수이다. class ArrayTP { private: T ar[n]; // 스택을 사용한다. public: ArrayTP() {}; explicit ArrayTP(const T\u0026amp; v); virtual T\u0026amp; operator[](int i); virtual T operator[](int i) const; }; template \u0026lt;class T, int n\u0026gt; ArrayTP\u0026lt;T, n\u0026gt;::ArrayTP(const T\u0026amp; v) { for (int i = 0; i \u0026lt; n; i++) ar[i] = v; } template \u0026lt;class T, int n\u0026gt; T\u0026amp; ArrayTP\u0026lt;T, n\u0026gt;::operator[](int i) { if (i \u0026lt; 0 || i \u0026gt;= n) { std::cerr \u0026lt;\u0026lt; \u0026#34;배열의 경계를 벗어나는 에러: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026gt; 잘못된 인덱스입니다. \\n\u0026#34;; std::exit(EXIT_FAILURE); } return ar[i]; } template \u0026lt;class T, int n\u0026gt; T ArrayTP\u0026lt;T, n\u0026gt;::operator[](int i) const { if (i \u0026lt; 0 || i \u0026gt;= n) { std::cerr \u0026lt;\u0026lt; \u0026#34;배열의 경계를 벗어나는 에러: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026gt; 잘못된 인덱스입니다. \\n\u0026#34;; std::exit(EXIT_FAILURE); } return ar[i]; } 1 2 3 4 5 6 7 // 12, 13. 수식 매개변수가 다르므로 서로 다른 두개의 클래스 선언을 생성한다. ArrayTP\u0026lt;double, 12\u0026gt; a1; ArrayTP\u0026lt;double, 13\u0026gt; a2; // 하나의 클래스 선언을 생성한다. Stack\u0026lt;double\u0026gt; s1(12); Stack\u0026lt;double\u0026gt; s2(13); 템플릿 클래스의 융통성 (1) 기초 클래스의 역할을 할 수 있다. (2) 성분 클래스가 될 수도 있다. (3) 데이터형 매개변수가 될 수도 있다. (4) 템플릿을 재귀적으로 사용할 수 있다. (5) 하나 이상의 데이터형 매개변수를 사용할 수 있다. (6) 데이터형 매개변수에 디폴트 값을 제공할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;class T\u0026gt; class A { }; template \u0026lt;class T\u0026gt; class B : public A\u0026lt;T\u0026gt; // 1. 템플릿 클래스 A를 상속한다. { }; template \u0026lt;class T\u0026gt; class Other { A\u0026lt;T\u0026gt; a; // 2. 성분으로 사용될 수 있다. }; int main() { A\u0026lt;Other\u0026lt;int\u0026gt;\u0026gt; a1; // 3. 데이터형 매개변수가 될 수 있다. } 1 2 3 ArrayTP\u0026lt;ArrayTP\u0026lt;int, 5\u0026gt;, 10\u0026gt; ar; // 4. 템플릿을 재귀적으로 사용할 수 있다. // int ar[10][5]; 와 동일하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T1, class T2\u0026gt; // 5. 하나 이상의 데이터형 매개변수를 사용할 수 있다. class Pair { private: T1 a; T2 b; public: Pair(T1 aVal, T2 bVal) : a(aVal), b(bVal) {} }; int main() { Pair\u0026lt;string, int\u0026gt; p(\u0026#34;이동갈비\u0026#34;, 5); Pair\u0026lt;string, int\u0026gt; p(\u0026#34;태릉갈비\u0026#34;, 5); } 1 2 template\u0026lt;class T1 = string, class T2 = int\u0026gt; // 6. 데이터형 매개변수에 디폴트 값을 제공할 수 있다. class Pair {}; 클래스 템플릿 매개변수와는 다르게, 함수 템플릿 매개변수에는 디폴트 값을 제공할 수 없다. 하지만, 둘 다 데이터형이 아닌(수식) 매개변수에 대해서는 디폴트 값을 제공할 수 있다.\n템플릿 클래스의 특수화 (1) 암시적 구체화 지금까지 살펴 본 예제들과 같이, 객체를 선언하면 컴파일러가 하나의 특수화된 클래스 정의를 생성하는 것이다. 컴파일러는 객체가 요구될 때까지 그 클래스의 암시적 구체화를 생성하지 않는다. 1 2 3 4 ArrayTP\u0026lt;int, 10\u0026gt; ar; // 암시적 구체화 ArrayTP\u0026lt;int, 10\u0026gt; * pt; // 포인터, 아직 객체가 필요없다. pt = new ArrayTP\u0026lt;int, 10\u0026gt; // 이제 객체가 요구된다. (2) 명시적 구체화 template 키워드를 사용하여 클래스를 선언하고, 사용하려는 데이터형을 나타냈을 때 컴파일러는 명시적 구체화를 생성한다. 그 선언은 템플릿 정의와 동일한 이름 공간 안에 있어야 한다. 1 template class ArrayTP\u0026lt;int, 10\u0026gt;; // ArrayTP\u0026lt;int, 10\u0026gt; 클래스를 생성한다. (3) 명시적 특수화 포괄적인 데이터형 대신에 구체적인 하나의 데이터형에 맞게 정의된 템플릿 형식을 취한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;class T\u0026gt; class SortedArray { //... }; // char *형을 위한 특수화된 템플릿을 제공한다. template \u0026lt;\u0026gt; class SortedArray\u0026lt;char *\u0026gt; { //... }; int main() { SortedArray\u0026lt;int\u0026gt; i; // 포괄적인 정의를 사용한다. SortedArray\u0026lt;char *\u0026gt; c; // 특수화된 정의를 사용한다. } 함수 vs 클래스 특징 함수 클래스 암시적 구체화 Swap(2, 3); ArrayTP\u0026lt;int, 10\u0026gt; a; 명시적 구체화 template void Swap\u0026lt;int\u0026gt;(int, int) template class ArrayTP\u0026lt;int 10\u0026gt; 명시적 특수화 template \u0026lt;\u0026gt; void Swap\u0026lt;int\u0026gt;(int, int) template \u0026lt;\u0026gt; class SortedArray\u0026lt;char *\u0026gt; 부분적인 특수화 템플릿의 포괄성을 일부 제한한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // 포괄적인 템플릿 template \u0026lt;class T1, class T2\u0026gt; class Pair { //... }; // T2를 int로 설정한, 부분적인 특수화 template \u0026lt;class T1\u0026gt; class Pair\u0026lt;T1, int\u0026gt; { //... } 컴파일러는 가장 특수화된 템플릿을 사용한다.\n멤버, 매개변수로써의 템플릿 클래스 템플릿은 구조체, 클래스, 템플릿 클래스의 멤버가 될 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 template \u0026lt;typename T\u0026gt; class Beta { private: template \u0026lt;typename V\u0026gt; // 내포된 템플릿 클래스 멤버 class hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } V Value() const { return val; } }; hold\u0026lt;T\u0026gt; q; // 템플릿 객체 hold\u0026lt;int\u0026gt; n; public: Beta(T t, int i) : q(t), n(i) {} template\u0026lt;typename U\u0026gt; // 템플릿 메서드 U Blab(U u, T t) { return (n.Value() + q.Value()) * u / t; } void Show() const { q.show(); n.show(); } }; int main() { // T가 3.5이므로 double로 설정된다. Beta\u0026lt;double\u0026gt; guy(3.5, 3); guy.Show(); // U가 10이므로 int가 된다. 그래서 리턴형도 int이다. cout \u0026lt;\u0026lt; guy.Blab(10, 2.3) \u0026lt;\u0026lt; endl; // U가 10.0이므로 double이 된다. 그래서 리턴형도 double이다. cout \u0026lt;\u0026lt; guy.Blab(10.0, 2.3) \u0026lt;\u0026lt; endl; } 매개변수 템플릿 데이터형, 수식말고도 템플릿 자체가 템플릿 매개변수로 들어갈 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // template \u0026lt;typename T\u0026gt; class 데이터형인 Thing이 매개변수가 된다. // 이전에 보았던 Stack이 그렇다. template \u0026lt;template \u0026lt;typename T\u0026gt; class Thing\u0026gt; class Crab { private: Thing\u0026lt;int\u0026gt; s1; // Stack\u0026lt;int\u0026gt; s1; Thing\u0026lt;double\u0026gt; s2; // Stack\u0026lt;double\u0026gt; s1; public: Crab() {}; bool push(int a, double x) { return s1.push(a) \u0026amp;\u0026amp; s2.push(x); } bool pop(int\u0026amp; a, double\u0026amp; x) { return s1.pop(a) \u0026amp;\u0026amp; s2.pop(x); } }; int main() { Crab\u0026lt;Stack\u0026gt; nebula; int ni; double nb; cout \u0026lt;\u0026lt; \u0026#34;int, double 쌍을 입력하세요.\u0026#34; \u0026lt;\u0026lt; endl; while (cin \u0026gt;\u0026gt; ni \u0026gt;\u0026gt; nb \u0026amp;\u0026amp; ni \u0026gt; 0 \u0026amp;\u0026amp; nb \u0026gt; 0) { if (!nebula.push(ni, nb)) break; } while (nebula.pop(ni, nb)) cout \u0026lt;\u0026lt; ni \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; nb \u0026lt;\u0026lt; endl; } 템플릿 클래스와 프렌드 함수 템플릿이 아닌 프렌드 함수 바운드 템플릿 프렌드 함수 언바운드 템플릿 프렌드 함수 1. 보통의 프렌드 함수를 템플릿 클래스 안에 넣기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 template \u0026lt;typename T\u0026gt; class HasFriend { private: T item; static int ct; // T에 따라서 각각의 특별한 특수화가 자신만의 static 멤버를 가질 것이다. public: HasFriend(const T\u0026amp; i) : item(i) { ct++; } ~HasFriend() { ct--; } // friend 함수들 friend void Counts(); friend void Reports(HasFriend \u0026amp;); // (X) HasFriend 객체 같은 건 없다. // HasFriend\u0026lt;int\u0026gt;와 같은 특수화만이 존재할 뿐이다. friend void Reports(HasFriend\u0026lt;T\u0026gt;\u0026amp;); // Report 자체는 템플릿 함수가 아니다. // 따라서 명시적 특수화를 정의해 주어야 한다. }; // staic 멤버를 초기화해준다. template \u0026lt;typename T\u0026gt; int HasFriend\u0026lt;T\u0026gt;::ct = 0; // friend 함수들 void Counts() { cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; HasFriend\u0026lt;int\u0026gt;::ct \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; HasFriend\u0026lt;double\u0026gt;::ct \u0026lt;\u0026lt; endl; } void Reports(HasFriend\u0026lt;int\u0026gt;\u0026amp; hf) { cout \u0026lt;\u0026lt; \u0026#34;HasFriend\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; hf.item \u0026lt;\u0026lt; endl; } void Reports(HasFriend\u0026lt;double\u0026gt;\u0026amp; hf) { cout \u0026lt;\u0026lt; \u0026#34;HasFriend\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; hf.item \u0026lt;\u0026lt; endl; } int main() { Counts(); // int: 0, double: 0 HasFriend\u0026lt;int\u0026gt; hfi1(10); Counts(); // int: 1, double: 0 HasFriend\u0026lt;int\u0026gt; hfi2(20); Counts(); // int: 2, double: 0 HasFriend\u0026lt;double\u0026gt; hfdb(10.5); Counts(); // int: 2, double: 1 Reports(hfi1); // 10 Reports(hfi2); // 20 Reports(hfdb); // 10.5 } 2. 클래스의 바깥에서 선언된 템플릿의 템플릿 특수화\n바운드 템플릿 프렌드 함수\n클래스가 구체화될 때 클래스의 데이터형에 의해 프렌드의 데이터형이 결정된다.\n예를 들어, int 클래스 특수화는, int 함수 특수화를 얻는 것이다.\n구현 방법\n(1) 클래스 정의 앞에 템플릿 함수를 선언한다. (2) 클래스의 템플릿 매개변수의 데이터형에 기초한 프렌드를 선언한다. (3) 프렌드의 정의를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 1. 클래스 정의 앞에 템플릿 함수를 선언한다. template \u0026lt;typename T\u0026gt; void Counts(); template \u0026lt;typename T\u0026gt; void Reports(T \u0026amp;); template \u0026lt;typename TT\u0026gt; class HasFriend { private: TT item; static int ct; public: HasFriend(const TT\u0026amp; i) : item(i) { ct++; } ~HasFriend() { ct--; } // 2. 클래스의 템플릿 매개변수의 데이터형에 기초한 프렌드를 선언한다. friend void Counts\u0026lt;TT\u0026gt;(); friend void Reports\u0026lt;\u0026gt;(HasFriend\u0026lt;TT\u0026gt; \u0026amp;); }; template \u0026lt;typename T\u0026gt; int HasFriend\u0026lt;T\u0026gt;::ct = 0; // 3. 정의를 제공한다. template \u0026lt;typename T\u0026gt; void Counts() { cout \u0026lt;\u0026lt; \u0026#34;카운트: \u0026#34; \u0026lt;\u0026lt; HasFriend\u0026lt;T\u0026gt;::ct \u0026lt;\u0026lt; endl; } template \u0026lt;typename T\u0026gt; void Reports(T\u0026amp; hf) { cout \u0026lt;\u0026lt; hf.item \u0026lt;\u0026lt; endl; } int main() { Counts\u0026lt;int\u0026gt;(); // int: 0, double: 0 Counts\u0026lt;double\u0026gt;(); HasFriend\u0026lt;int\u0026gt; hfi1(10); Counts\u0026lt;int\u0026gt;(); // int: 1, double: 0 Counts\u0026lt;double\u0026gt;(); HasFriend\u0026lt;int\u0026gt; hfi2(20); Counts\u0026lt;int\u0026gt;(); // int: 2, double: 0 Counts\u0026lt;double\u0026gt;(); HasFriend\u0026lt;double\u0026gt; hfdb(10.5); Counts\u0026lt;int\u0026gt;(); // int: 2, double: 1 Counts\u0026lt;double\u0026gt;(); Reports(hfi1); // 10 Reports(hfi2); // 20 Reports(hfdb); // 10.5 } 3. 클래스의 안에서 선언된 템플릿의 템플릿 특수화\n언바운드 템플릿 프렌드 함수 바운드 템플릿 프렌드 함수와 다르게, 클래스의 데이터형과 다른 프렌드 템플릿 데이터형 매개변수를 갖는다. 모든 함수 특수화는 모든 클래스 특수화에 대해 프렌드이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;typename T\u0026gt; class ManyFriend { private: T item; public: ManyFriend(const T\u0026amp; i) : item(i) {} // 클래스의 데이터형 매개변수 T와 다른 C, D가 쓰였다. template \u0026lt;typename C, typename D\u0026gt; friend void ShowTwo(C\u0026amp;, D\u0026amp;); }; // Myfriend의 모든 특수화들에 대해 프렌드이기 때문에 이 함수는 모든 특수화들이 item멤버에 접근할 수 있다. // 그러나 Myfriend\u0026lt;C\u0026gt;와 MyFriend\u0026lt;D\u0026gt; 객체들에 대한 접근만을 사용한다. template \u0026lt;typename C, typename D\u0026gt; void ShowTwo(C\u0026amp; c, D\u0026amp; d) { cout \u0026lt;\u0026lt; c.item \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; d.item \u0026lt;\u0026lt; endl; } int main() { ManyFriend\u0026lt;int\u0026gt; hfi1(10); ManyFriend\u0026lt;int\u0026gt; hfi2(20); ManyFriend\u0026lt;double\u0026gt; hfdb(10.5); ShowTwo(hfi1, hfi2); // 10, 20 ShowTwo(hfdb, hfi2); // 10.5, 20 } 템플릿 별칭 using = typedef를 사용해서 별칭을 생성할 수 있다. 하지만 이것은 특정 템플릿 부분에는 사용할 수 없다. 따라서 using을 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class T1, class T2\u0026gt; class Test { }; typedef Test\u0026lt;int, int\u0026gt; tii; // (O) template\u0026lt;class T\u0026gt; typedef Test\u0026lt;T, int\u0026gt; tti; // (X) typedef는 템플릿에 사용 불가능하다. template\u0026lt;class T\u0026gt; using tti = Test\u0026lt;T, int\u0026gt;; // (O) using은 가능하다. int main() { tti\u0026lt;double\u0026gt; test; // Test\u0026lt;double, int\u0026gt; 이다. } ","date":"2022-03-21T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-14-2/","title":"[C++ Primer Plus] Chapter 14. C++ 코드의 재활용 (2) 템플릿"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n코드의 재활용성을 높이는 방법 public 상속 (이전 chapter에서 본 것) 컨테인먼트(containment) = 컴포지션(composition) = 레이어링(layering) private 상속 protected 상속 클래스 템플릿 컨테인먼트 - 객체 멤버를 가지는 클래스 valarray 클래스 수치 값들을 다루는 것이 목표인 클래스이다. 배열에 들어 있는 합, 최대값, 최소값을 구하는 것과 같은 동작들을 지원한다. 1 2 3 4 5 6 7 8 9 10 11 valarray\u0026lt;int\u0026gt; v1; // int형의 배열 valarray\u0026lt;int\u0026gt; v2(10); // 10개짜리 배열 valarray\u0026lt;int\u0026gt; v3(3, 10); // 3이 10개인 배열 int arr[15] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }; valarray\u0026lt;int\u0026gt; v4(arr, 10); // arr의 첫 10개의 원소로 초기화된 배열 cout \u0026lt;\u0026lt; v4.sum() \u0026lt;\u0026lt; endl; // 55 cout \u0026lt;\u0026lt; v4.min() \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; v4.max() \u0026lt;\u0026lt; endl; // 10 학생 클래스 만들기 이름과 성적표를 가지고 있는 클래스이다. 이것은 has-a 관계이다. has-a 관계를 모델링하는 일반적인 방법은 컨테인먼트를 사용하는 것이다. 즉, 다른 클래스의 객체들을 멤버로 가지는 클래스를 만드는 것이다. is-a 관계\npublic 상속에서 처럼, 인터페이스와 구현 모두 상속한다. has-a 관계\n인터페이스 없이 구현을 획득한다. Student 객체는 string과 valarray객체를 가지고 있다. (has-a 관계) string과 valarray객체의 구현을 획득해서 사용할 수는 있지만, 인터페이스는 상속하지 않는다. 예를 들어, string operator==()함수를 사용하는 인터페이스는 갖지 않는다. 1 2 3 4 5 6 class Student { private: string name; // string 객체를 가진다. valarray\u0026lt;double\u0026gt; scores; // valarray 객체를 가진다. }; 학생 클래스 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Student.h class Studentc { private: typedef valarray\u0026lt;double\u0026gt; ArrayDb; // typedef를 사용해서 표기를 단순화하였다. string name; ArrayDb scores; ostream\u0026amp; PrintScores(ostream\u0026amp; os) const; public: Studentc() : name(\u0026#34;Null Studentc\u0026#34;), scores() {} explicit Studentc(const string\u0026amp; s) : name(s), scores() {} explicit Studentc(int n) : name(\u0026#34;Nully\u0026#34;), scores(n) {} Studentc(const string\u0026amp; s, int n) : name(s), scores(n) {} Studentc(const string\u0026amp; s, const ArrayDb\u0026amp; a) : name(s), scores(a) {} Studentc(const char* str, const double* pd, int n) : name(str), scores(pd, n) {} ~Studentc() {} double Average() const; const string\u0026amp; Name() const; double\u0026amp; operator[](int i); double operator[](int i) const; friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studentc\u0026amp; stu); friend istream\u0026amp; getline(istream\u0026amp; is, Studentc\u0026amp; stu); friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studentc\u0026amp; stu); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Student.cpp // scores 출력을 위한 private 멤버 함수 ostream\u0026amp; Studentc::PrintScores(ostream\u0026amp; os) const { int i; int lim = scores.size(); if (lim \u0026gt; 0) { for (i = 0; i \u0026lt; lim; i++) { os \u0026lt;\u0026lt; scores[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (i % 5 == 4) os \u0026lt;\u0026lt; endl; // 5개 출력하고 개행하기 위함 } if (i % 5 != 0) os \u0026lt;\u0026lt; endl; // 혹시 개행이 안 되었을 때 개행하기 위함 } else os \u0026lt;\u0026lt; \u0026#34;빈 배열\u0026#34;; return os; } double Studentc::Average() const { if (scores.size() \u0026gt; 0) return scores.sum() / scores.size(); else return 0; } const string\u0026amp; Studentc::Name() const { return name; } double\u0026amp; Studentc::operator[](int i) { return scores[i]; } double Studentc::operator[](int i) const { return scores[i]; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studentc\u0026amp; stu) { is \u0026gt;\u0026gt; stu.name; return is; } istream\u0026amp; getline(istream\u0026amp; is, Studentc\u0026amp; stu) { getline(is, stu.name); return is; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studentc\u0026amp; stu) { os \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; stu.PrintScores(os); return os; } explicit 사용 이유 암시적으로 변환하는 것을 막아서 실수를 예방한다. 1 2 3 4 5 Student homer(\u0026#34;Homer\u0026#34;, 10); homer = 5; // homer[0] = 5; 로 점수를 바꾸려고 했는데 실수로 오타가 났다. // explicit이 없다면 맞는 문장이다. // Student(int n) 생성자가 불려서 이름이 Nully가 된다. 멤버 초기자 리스트 문법을 사용해서 내포된 객체를 초기화 했다. 만약 멤버 초기자 리스트 문법을 사용하지 않았다면, string과 valarray 객체의 디폴트 생성자를 사용한다. 순서는 멤버 초기자 리스트 순서가 아니다. 선언된 순서이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { private: typedef valarray\u0026lt;double\u0026gt; ArrayDb; string name; // name이 먼저 선언되었다. ArrayDb scores; public: Student(const char* str, const double* pd, int n) : scores(pd, n), name(str) {} // scores를 먼저 써도, 선언된 순서가 name 먼저라서 name 먼저 초기화된다. }; 클래스 메서드 안에서 내포된 객체의 인터페이스를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 double Student::Average() const { // valarray의 sum(), size() 사용 if (scores.size() \u0026gt; 0) return scores.sum() / scores.size(); else return 0; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Student\u0026amp; stu) { // string의 operator\u0026lt;\u0026lt;()를 사용 os \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; //... } private 상속 public 상속\n기초 클래스의 public 메서드가 파생 클래스의 public 메서드가 된다. 즉, 기초 클래스의 인터페이스를 상속한다. is-a private 상속\n기초 클래스의 public 메서드가 파생 클래스의 private 클래스가 된다. 즉, 기초 클래스의 인터페이스를 상속하지 않는다. has-a 디폴트가 private 상속이다. 컨테인먼트와의 차이 컨테인먼트는 객체를 이름이 있는 멤버 객체로 클래스에 추가한다. 반면에 private 상속은 객체를 이름이 없는 멤버 객체로 클래스에 추가한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Student.h class Studenti : private string, private valarray\u0026lt;double\u0026gt; { private: typedef valarray\u0026lt;double\u0026gt; ArrayDb; ostream\u0026amp; PrintScores(ostream\u0026amp; os) const; public: Studenti() : string(\u0026#34;Null Student\u0026#34;), ArrayDb() {} explicit Studenti(const string\u0026amp; s) : string(s), ArrayDb() {} explicit Studenti(int n) : string(\u0026#34;Nully\u0026#34;), ArrayDb(n) {} Studenti(const string\u0026amp; s, int n) : string(s), ArrayDb(n) {} Studenti(const string\u0026amp; s, const ArrayDb\u0026amp; a) : string(s), ArrayDb(a) {} Studenti(const char* str, const double* pd, int n) : string(str), ArrayDb(pd, n) {} ~Studenti() {} double Average() const; double\u0026amp; operator[](int i); double operator[](int i) const; const string\u0026amp; Name() const; friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studenti\u0026amp; stu); friend istream\u0026amp; getline(istream\u0026amp; is, Studenti\u0026amp; stu); friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studenti\u0026amp; stu); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // Student.cpp ostream\u0026amp; Studenti::PrintScores(ostream\u0026amp; os) const { int i; int lim = ArrayDb::size(); if (lim \u0026gt; 0) { for (i = 0; i \u0026lt; lim; i++) { os \u0026lt;\u0026lt; ArrayDb::operator[](i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (i % 5 == 4) os \u0026lt;\u0026lt; endl; } if (i % 5 != 0) os \u0026lt;\u0026lt; endl; } else os \u0026lt;\u0026lt; \u0026#34;빈 배열\u0026#34;; return os; } double Studenti::Average() const { if (ArrayDb::size() \u0026gt; 0) return ArrayDb::sum() / ArrayDb::size(); else return 0; } const string\u0026amp; Studenti::Name() const { return (const string\u0026amp;)*this; } double\u0026amp; Studenti::operator[](int i) { return ArrayDb::operator[](i); } double Studenti::operator[](int i) const { return ArrayDb::operator[](i); } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is, Studenti\u0026amp; stu) { is \u0026gt;\u0026gt; (string\u0026amp;)stu; return is; } istream\u0026amp; getline(istream\u0026amp; is, Studenti\u0026amp; stu) { getline(is, (string\u0026amp;)stu); return is; } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studenti\u0026amp; stu) { os \u0026lt;\u0026lt; (const string\u0026amp;)stu \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; stu.PrintScores(os); return os; } 멤버 초기자 리스트 문법을 사용해서 내포된 객체를 초기화 했다. 컨테인먼트는 멤버 이름을 사용했다. 하지만 private 상속은 클래스 이름을 사용한다. 1 2 3 4 5 // 컨테인먼트 - name과 같은 멤버 이름을 사용함. Studentc::Studentc() : name(\u0026#34;Null Student\u0026#34;), scores() {} // private 상속 - string과 같은 클래스 이름을 사용함. Studenti::Studenti() : string(\u0026#34;Null Student\u0026#34;), ArrayDb() {} 클래스 메서드 안에서 기초 클래스의 인터페이스를 사용한다. 컨테인먼트는 멤버의 메서드를 사용한다. 하지만 private 상속은 클래스 이름과 사용 범위 결정 연산자를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 // 컨테인먼트 - scores.sum() 처럼 멤버의 메서드를 사용한다. double Studentc::Average() const { if (scores.size() \u0026gt; 0) return scores.sum() / scores.size(); else return 0; } // private 상속 - ArrayDb::sum() 처럼 클래스 이름과 사용 범위 결정 연산자를 사용한다. double Studenti::Average() const { if (ArrayDb::size() \u0026gt; 0) return ArrayDb::sum() / ArrayDb::size(); else return 0; } 기초 클래스 객체에 접근하기 컨테인먼트는 멤버를 사용한다. 하지만 private 상속은 데이터형 변환을 사용해서 기초 클래스로 변환한다. 1 2 3 4 5 6 7 8 9 10 11 // 컨테인먼트 - 멤버인 name을 사용한다. const string\u0026amp; Studentc::Name() const { return name; } // private 상속 - 자기 자신을 기초 클래스 string로 형변환한다. const string\u0026amp; Studenti::Name() const { return (const string\u0026amp;)*this; } 기초 클래스 프렌드에 접근하기 컨테인먼트는 멤버를 사용한다. 하지만 private 상속은 데이터형 변환을 사용해서 기초 클래스로 변환한다. 명시적으로 변환해야 한다. private 상속에서는 명시적인 형변환이 없으면, 파생 클래스에 대한 참조/포인터를 기초 클래스에 대한 참조/포인터에 대입할 수 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 컨테인먼트 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Student\u0026amp; stu) { // string 멤버인 name의 operator\u0026lt;\u0026lt;()를 사용 os \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; //... } ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Studenti\u0026amp; stu) { // (const string\u0026amp;)stu으로 매개변수를 형변환 하여 string의 operator\u0026lt;\u0026lt;()를 사용 os \u0026lt;\u0026lt; (const string\u0026amp;)stu \u0026lt;\u0026lt; \u0026#34; 학생의 성적표: \u0026#34; \u0026lt;\u0026lt; endl; //... } has-a를 구현하기 위해서 어떤 것을 사용할까? 컨테인먼트 vs private 상속 컨테인먼트의 장점 사용하기 쉽다. private의 경우에 하나 이상의 기초 클래스를 상속하면 문제가 발생할 수 있다. 같은 클래스를 여러개 내포할 수 있다. (string 멤버가 여러 개) private 상속의 장점 기초 클래스의 protected 멤버에 접근할 수 있다. 가상 함수를 재정의할 수 있다. protected 상속 각 상속의 특성 특성 public 상속 protected 상속 private 상속 기초 클래스의 public 멤버 public protected private 기초 클래스의 protected 멤버 protected protected private 기초 클래스의 private 멤버 접근 불가 접근 불가 접근 불가 기초 클래스로 암시적 업캐스팅 가능하다 파생 클래스 안에서만 가능하다 불가능하다 처음 두 행의 설명 예를 들어, 기초 클래스의 public 멤버의 경우 public 상속일 때는 파생 클래스 안에서 public 멤버가 된다는 말이다. 기초 클래스의 private 멤버의 경우, 기초 클래스의 인터페이스를 통해서만 접근이 가능하다. protected나 private 상속 일 때, 기초 클래스의 메서드를 파생 클래스에서 public으로 사용하는 방법 (1) 메서드를 새롭게 하나 만든다. (2) using 선언을 사용해서 지정한다. 이것은 컨테인먼트일 때는 적용되지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Studenti : private string, private valarray\u0026lt;double\u0026gt; { public: // 방법 2 using valarray\u0026lt;double\u0026gt;::sum; // 방법 1 double Studenti::max() const { return valarray\u0026lt;double\u0026gt;::max(); } //... }; int main() { Studenti s(\u0026#34;Kim\u0026#34;, {1, 2, 3, 4, 5}); cout \u0026lt;\u0026lt; s.max() \u0026lt;\u0026lt; endl; // (O) private 상속이지만 max를 public처럼 사용 가능하다. } 다중 상속 다중 상속 (multiple inheritance; MI)\n직계 인접한 기초 클래스를 하나 이상 가지는 클래스이다. public, protected, private 키워드는 각각의 기초 클래스에 명시해서 제한해야 한다. 명시하지 않으면 디폴트인 private 상속이 된다. 여기서는 public 상속을 중심으로 설명한다.\n다중 상속은 조심스럽게 절제하여 사용해야 한다.\n하나의 조상을 공유하는 다중 상속은 위험하기 때문이다. 예를 들어, 다음과 같은 클래스 구조가 있을 때 문제가 발생한다.\n1 2 3 4 5 Worker ↙ ↘ Singer Waiter ↘ ↙ SingingWaiter 1 2 SingingWaiter sw; Worker * ptr = \u0026amp;sw; // (X) 이 경우 선택지가 두 개가 존재한다.\n하나는 Waiter에 있는 Worker이며, 다른 하나는 Singer에 있는 Worker이다. 또한 Worker 객체의 복사본을 두 개나 가지게 된다.\n해결방법: 가상 기초 클래스 공통 조상의 유일한 객체를 상속하는 방식으로 객체를 파생시킨다. virtual 키워드를 사용해서 상속한다. 그러면, SingingWaiter는 하나의 Worker 객체를 내포한다. 1 2 3 4 5 6 7 class Worker {}; class Waiter : public virtual Worker {}; // public과 virtual의 위치는 상관 없다. class Singer : virtual public Worker {}; // 즉, 이렇게 써도 된다. class SingingWaiter : public Singer, public Waiter {}; 왜 가상 기초 클래스가 디폴트가 아닌가? (1) 기초 클래스 객체의 여러 개의 복사본을 원할 수 있다. (2) 기초 클래스를 가상으로 만드려면 추가적인 작업을 해야한다. (3) 중간 클래스를 통해 기초 클래스에게 자동으로 정보를 전달하는 기능을 못하게 만든다. (3) 가상 기초 클래스를 사용하면 생성자에서 중간 클래스를 통해 기초 클래스에게 자동으로 정보를 전달하는 기능을 못하게 만든다. C(int, int, int)의 호출로 B(int, int)는 호출되지만, 자동으로 A(int)까지 호출하지는 않는다. 따라서 A()의 생성자가 호출된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A의 디폴트 생정자\u0026#34; \u0026lt;\u0026lt; endl; } A(int a) { cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public virtual A { public: B(int a, int b) : A(a) // A(a)가 아니라 A()가 호출된다. { cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; class C : public B { public: C(int a, int b, int c) : B(a, b) { cout \u0026lt;\u0026lt; \u0026#34;C\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { C c(1, 2, 3); } 1 2 3 A의 디폴트 생성자 B C 기초 생성자를 명시적으로 호출함으로써 수정가능하다. 1 2 3 4 5 6 7 8 9 class C : public B { public: // 명시적으로 A(int)의 생성자를 호출한다. C(int a, int b, int c) : A(a), B(a, b) { cout \u0026lt;\u0026lt; \u0026#34;C\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 A B C 간접적인 가상 기초 클래스를 사용하는 파생 클래스는, 그 파생 클래스의 생성자들이 간접적인 가상 기초 클래스 생성자들을 직접 호출하게 해야 한다.\n(2) 기초 클래스를 가상으로 만드려면 추가적인 작업을 해야한다. 어느 메서드를 사용하는 가? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Worker { public: virtual void Show(); }; class Waiter : virtual public Worker { public: void Show(); } class Singer : virtual public Worker { public: void Show(); } class SingingWaiter : public Waiter, public Singer { } int main() { SingingWaiter sw; sw.Show(); // (X) Singer와 Waiter 중에 어느 메서드인지 모호하다. sw.Singer::Show(); // (O) } 대안 SingingWaiter에서 Show()를 다시 정의하고, 사용할 Show()의 버전을 지정해 준다. 1 2 3 4 void SingingWaiter::Show() { Singer::Show(); } 가상 기초 클래스와 가상이 아닌 기초 클래스의 혼합 다음 예시에서 B와 C에 대해서만 A가 가상 클래스이고, X와 Y에 대해서는 가상 클래스가 아니라면. M은 결과적으로 3개의 클래스 A 종속 객체를 내포하게 되겠다. 1 2 3 4 5 A ↙ ↙ ↘ ↘ [B] [C] X Y ↘ ↘ ↙ ↙ M 가상 기초 클래스와 비교 우위 파생 클래스에 있는 이름은 조상 클래스에 있는 동일한 이름보다 비교 우위를 가진다. 이것은 가시성과는 상관 없다. 아래 예시에서는\u0026hellip; A의 AB()보다 B의 AB()가 우위를 가진다. B와 C에 있는 BC()는 D()의 입장에서 모호하다. 이것은 어느 하나가 private 이든 간에 상관없이 비교 우위를 가지는 것들이다. 즉, B의 AB()가 private이라고 해도 A의 AB()보다 비교 우위를 가진다. 1 2 3 4 5 A ↙ ↘ [B] [C] ↘ ↙ D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class A { public: void AB(); }; class B : public virtual A { public: void AB(); void BC(); } class C : public virtual A { public: void BC(); } class D : public B, public C { public: void Test() { AB(); // B의 AB() 호출 BC(); // (X) 모호하다 } } ","date":"2022-03-21T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-14-1/","title":"[C++ Primer Plus] Chapter 14. C++ 코드의 재활용 (1) 컨테인먼트와 private, protected 상속"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n서론 C의 전통적인 함수 라이브러리는\n그 라이브러리의 소스 코드를 제공하지 않는다면, 사용자의 특정 요구에 맞게 그 함수를 확장하거나 수정할 수 없다. C++의 클래스 라이브러리는\n클래스 상속을 사용한다. 이것은 기초 클래스(base class)로 부터 멤버 변수, 함수들을 상속받아서 새로운 파생 클래스(derived class)를 만드는 것이다. 기초 클래스의 소스 코드에 접근할 필요 없이, 상속으로 새로운 기능이나 데이터를 추가하거나, 함수의 동작 방식을 변경할 수 있다. 기초 클래스를 상속 받는 파생 클래스 파생 클래스는 기초 클래스의 구현들을 상속받는다. (데이터 멤버)\n파생 클래스는 기초 클래스의 인터페이스를 상속받는다. (메서드)\n파생 클래스는 자기 자신의 생성자를 필요로 한다.\n파생 클래스는 부가적인 데이터 멤버들과 멤버 함수들을 필요한 만큼 추가할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class BaseClass { private: int baseClassNumber; public: BaseClass() { baseClassNumber = 0; }; BaseClass(int n) { baseClassNumber = n; } int GetBaseClassNumber() const { return baseClassNumber; } }; class DerivedClass : public BaseClass { private: int derivedClassNumber; public: // 기초 클래스의 생성자를 멤버 초기자 리스트 문법을 사용해 먼저 호출한다. DerivedClass(int base, int derived) : BaseClass(base) { derivedClassNumber = derived; } int Sum() { // 기초 클래스의 private 멤버는 public 멤버로 접근할 수 있다. return derivedClassNumber + GetBaseClassNumber(); } }; 생성자 파생 클래스의 생성자는 기초 클래스의 생성자를 사용해야 한다. 프로그램은 기초 클래스의 객체를 생성 한 후, 파생 클래스의 객체를 생성한다. 파생 클래스 생성자의 몸체 안으로 들어가기 전에 기초 클래스 객체를 생성하기 위해 멤버 초기자 리스트 문법을 사용할 수 있다. 1 2 3 4 DerivedClass::DerivedClass(int base, int derived) : BaseClass(base) { derivedClassNumber = derived; } 멤버 초기자 리스트를 생략하면? 디폴트 기초 클래스 생성자를 사용한다. 1 2 3 4 DerivedClass::DerivedClass(int base, int derived) // 이것은 : BaseClass()와 같다. { derivedClassNumber = derived; } 원한다면, 파생 클래스 멤버들에도 멤버 초기자 리스트 문법을 사용할 수 있다. 1 2 3 4 5 DerivedClass::DerivedClass(int base, int derived) : BaseClass(base), derivedClassNumber(derived); { } 파괴자는 반대 순서로 일어난다. 파생 클래스 파괴자의 먼저 호출되고, 기초 클래스의 파괴자라 호출된다. 파생 클래스는 private이 아니면 기초 클래스의 메서드들을 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class DerivedClass : public BaseClass { private: int derivedClassNumber; public: // ... int Sum() { // 기초 클래스의 private 멤버는 public 멤버로 접근할 수 있다. return derivedClassNumber + GetBaseClassNumber(); } }; 기초 클래스 포인터, 참조는 명시적 데이터형 변환 없이도 파생 클래스의 객체를 지시, 참조할 수 있다. 반대는 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 DerivedClass derivedClass(5, 6); // 기초 클래스로 파생 클래스를 지시, 참조할 수 있다. BaseClass * basePtr = \u0026amp;derivedClass; BaseClass \u0026amp; baseRef = derivedClass; // 기초 클래스의 메서드를 사용할 수 있다. basePtr-\u0026gt;GetBaseClassNumber(); baseRef.GetBaseClassNumber(); // 파생 클래스의 메서드는 사용할 수 없다. basePtr-\u0026gt;Sum(); // (X) baseRef.Sum(); // (X) 1 2 3 4 5 6 BaseClass baseClass(5); // 반대로 // 파생 클래스로 기초 클래스를 지시, 참조할 수 없다. DerivedClass * derivedPtr = \u0026amp;baseClass; // (X) DerivedClass \u0026amp; derivedRef = baseClass; // (X) 따라서 기초 클래스 포인터, 참조를 매개변수를 사용하는 함수는 파생 클래스 객체에도 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 void Show(BaseClass \u0026amp; baseRef) { cout \u0026lt;\u0026lt; baseRef.GetBaseClassNumber() \u0026lt;\u0026lt; endl; } int main() { BaseClass baseClass(5); DerivedClass derivedClass(5, 6); Show(baseClass); Show(derivedClass); // (O) } 파생 클래스의 객체로 기초 클래스 객체를 초기화하는 것도 간접적으로나마 허용한다. 초기화하는 생성자의 원형은 BaseClass(const DerivedClass \u0026amp;);일 것이다. 이러한 생성자를 만들지 않았으므로 암시적인 복사 생성자가 그 역할을 대신한다. BaseClass(const BaseClass \u0026amp;); 기초 클래스의 참조는 파생 클래스를 참조할 수 있으므로, 파생 클래스의 멤버들을 복사한다. 1 2 3 4 5 6 7 8 DerivedClass derivedClass(5, 6); BaseClass baseClass(derivedClass); // (O) // 이러한 복사 생성자가 암시적으로 호출되었을 것이다. BaseClass::BaseClass(const BaseClass\u0026amp; b) { baseClassNumber = b.baseClassNumber; } 대입도 마찬가지이다. BaseClass \u0026amp; operator=(const BaseClass \u0026amp;)과 같은 암시적인 오버로딩 대입 연산자를 대입에 사용한다. 1 2 3 DerivedClass derivedClass(5, 6); BaseClass baseClass; baseClass = derivedClass; // (O) is-a 관계 is-a관계는 파생 클래스와 기초 클래스의 특별한 관계를 나타낸다. 바나나와 과일 바나나는 과일이다. 바나나 is a 과일. is-a 관계는 파생 클래스가 기초 클래스이기도 하다는 것을 뜻한다. 바나나(파생 클래스)는 과일(기초 클래스)이다. 점심과 과일 점심은 과일를 가진다. 점심 has a 과일. 점심이 과일인 것은 아니다. 이것은 has-a 관계이다. 점심 클래스는 데이터 멤버로 과일 객체를 가진다. public 다형 상속 호출하는 객체가 어떤 것인가에 따라서 메서드의 행동이 달라질 수 있다.\n메서드가 여러 가지 다른 행동을 할 수 있기 때문에 그러한 행동을 다형이라고 부른다.\n방법\n기초 클래스 메서드를 파생 클래스에서 다시 정의한다. 그리고 virtual 키워드를 사용해서 가상 메서드로 만든다. virtual 키워드\nvirtual 키워드를 사용한 메서드를 가상 메서드라고 한다. virtual 키워드를 사용하면 각각의 클래스에서 서로 다른 행동을 하는 메서드을 만들 수 있다. 만약 같은 행동을 한다면 기초 클래스에 단 한 번만 선언된다. virtual 키워드를 사용하지 않을 경우, 프로그램은 참조형이나 포인터형에 기초하여 메서드를 선택한다. virtual 키워드를 사용할 경우, 프로그램은 참조형이나 포인터형이 지시하는 객체가 무엇인가에 기초하여 메서드를 선택한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Animal { public: virtual void WhatIsThis() { cout \u0026lt;\u0026lt; \u0026#34;이것은 Animal 객체입니다.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog : public Animal { public: virtual void WhatIsThis() { cout \u0026lt;\u0026lt; \u0026#34;이것은 Dog 객체입니다.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Animal animal; Dog dog; Animal * aniPtr = \u0026amp;animal; Animal * dogPtr = \u0026amp;dog; aniPtr-\u0026gt;WhatIsThis(); // Animal의 WhatIsThis() 호출 dogPtr-\u0026gt;WhatIsThis(); // Dog의 WhatIsThis() 호출 } 출력 결과 포인터가 실제 어떤 객체를 가리지는 지 판단해서 메서드를 선택한다. 1 2 이것은 Animal 객체입니다. 이것은 Dog 객체입니다. 만약 virtual 키워드를 사용하지 않으면 출력 결과는 다음과 같다. 포인터가 실제 어떤 객체를 가리키는 지에 상관없이 포인터형으로만 메서드를 선택한다. 1 2 이것은 Animal 객체입니다. 이것은 Animal 객체입니다. virtual 파생 클래스 메서드에서 기초 클래스의 메서드를 부르는 방법 사용 범위 결정 연산자를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 class Dog : public Animal { public: virtual void WhatIsThis() { Animal::WhatIsThis(); // Animal 기초 클래스의 메서드를 호출한다. WhatIsThis(); // 이것은 자기 자신을 부르는 재귀호출이다. cout \u0026lt;\u0026lt; \u0026#34;이것은 Dog 객체입니다.\u0026#34; \u0026lt;\u0026lt; endl; } }; 가상 파괴자의 필요성 파괴자가 가상이 아니면, 포인터형에 대한 파괴자만 호출될 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { public: ~Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; }; }; class Dog : public Animal { public: ~Dog() { cout \u0026lt;\u0026lt; \u0026#34;Dog 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 // 예시 1 Animal * ptr = new Animal; delete ptr; // Animal 파괴자 호출 1 2 3 4 // 예시 2 Animal * ptr = new Dog; delete ptr; // Animal 파괴자 호출 1 2 3 4 // 예시 3 Dog * ptr = new Dog; delete ptr; // Dog 파괴자 호출 후, Animal 파괴자 호출 Dog객체를 지시하는 경우에도 Animal 객체의 파괴자만 호출한다. (예시 2번) 하지만, 파괴자를 가상으로 만들면 실제로 지시하는 Dog 객체의 파괴자를 호출한 후 Animal객체의 파괴자를 호출한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { public: virtual ~Animal() // 가상 소멸자 { cout \u0026lt;\u0026lt; \u0026#34;Animal 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; }; }; class Dog : public Animal { public: ~Dog() { cout \u0026lt;\u0026lt; \u0026#34;Dog 파괴자 호출됨\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 // 예시 2 Animal * ptr = new Dog; delete ptr; // Dog 파괴자 호출 후, Animal 파괴자 호출 일반적으로, 파괴자가 필요 없는 기초 클래스라 하더라도 가상 파괴자를 제공해야 한다.\n정적 바인딩과 동적 바인딩 바인딩(binding; 결합)\n함수가 호출되었을 때 어떤 블록을 실행할지 결합하는 것을 바인딩이라고 한다. 정적 바인딩(static binding) = 초기 바인딩(early binding)\n컴파일 동안 일어나는 바인딩. 동적 바인딩(dynamic binding) = 말기 바인딩(lately binding)\n프로그램 실행 시에 올바른 가상 메서드가 선택되도록 하는 바인딩. C++은 일반적으로 한 데이터형의 주소를 다른 데이터형 포인터에 대입하는 것을 허용하지 않는다. 참조하는 것도 허용하지 않는다. 1 2 3 4 double d = 1.5; int * iPtr = \u0026amp;d; // (X) int \u0026amp; iRef = d; // (X) 그러나 앞서 보았듯이, 상속하는 클래스는 허용된다. 1 2 3 4 DerivedClass d; BaseClass * bPtr = \u0026amp;d; // (O) 업캐스팅 BaseClass \u0026amp; bRef = d; // (O) 업캐스팅(upcasting) 파생 클래스의 참조/포인터를 기초 클래스의 참조/포인터로 변환하는 것을 업캐스팅이라고 한다. public 상속에서는 명시적인 데이터형 변환이 없어도 업캐스팅이 허용된다. 업캐스팅은 전이된다. 예를 들어, DerivedClass를 상속받는 DerivedDerivedClass가 있다면, 이 클래스 또한 BaseClass에 의해 참조될 수 있다. 다운캐스팅(downcasting) 반대로 기초 클래스의 참조/포인터를 파생 클래스의 참조/포인터로 변환하는 것을 다운캐스팅이라고 한다. 다운캐스팅은 명시적인 데이터형 변환 없이는 허용되지 않는다. 왜냐하면 is-a관계는 일반적으로 대칭적이지 않기 때문이다. 예를 들어, 사과 is a 과일이지만, 과일 is a 사과는 아니다. 암시적 업캐스팅 때문에 동적 바인딩이 필요한 것이다. virtual 멤버 함수는 이러한 필요성 때문에 만들어 졌다. 컴파일러는 virtual이 아닌 멤버 함수는 정적 바인딩을 사용한다. 반면 virtual인 멤버 함수는 프로그램이 실행되는 동안에 결정되는 객체형에 따라서 맞는 함수를 바인딩한다. 즉, 동적으로 바인딩한다. 왜 두 종류의 바인딩이 필요한가? 효율성 프로그램이 무언가를 실행 시간에 결정하려면, 기초 클래스 참조/포인터가 지시하는 객체가 무엇인지 추적하는 방법이 필요하다. 이것은 가외의 처리 부담(다음 차례에 설명되어 있다)이 생긴다. 따라서 동적 바인딩이 필요 없는 경우, 정적 바인딩이 좀 더 효율적이며, C++에서는 정적 바인딩이 디폴트로 되어있다. 개념 모델 파생 클래스에서 다시 정의되는 것을 원하지 않는 멤버 함수는 가상이 아닌 함수로 만듦으로써, 다시 정의되면 안 된다는 의도를 드러낸다. 가상 함수는 어떻게 동작하는가? 일반적으로 컴파일러는 각각의 객체에 숨겨진 멤버를 하나씩 추가한다. 그 숨겨진 멤버는 어떤 배열을 지시하는 포인터이다. 배열에는 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장되어 있다. 이 배열을 가상 함수 테이블(virtual function table; vtbl) 이라고 한다. 파생 클래스가 가상 함수를 다시 정의하지 않으면, vtbl은 그 함수의 오리지널 버전의 주소를 저장한다. 반면, 파생 클래스가 새로운 함수를 정의하면, 그 주소가 vtbl에 저장된다. 따라서 가상 함수를 호출하면, 프로그램은 객체에 있는 vtbl에 접근한다. 사용하는 함수가 첫 번째 가상 함수라면, 프로그램은 vtbl의 첫 번째 주소를 사용한다. 이렇듯 가상 함수를 사용하면 메모리, 실행 속도 면에서 약간의 부담이 따른다. 각 객체의 크기가 커진다. (vtbl을 가리키는 주소를 저장하므로) 컴파일러는 테이블을 만들어야 한다. 함수 호출 시 테이블에 접근하는 가외의 단계가 더 필요하다. 생성자는 가상으로 선언할 수 없다. 파생 클래스의 객체 생성 (1) 파생 클래스의 생성자를 호출한다. (2) 파생 클래스의 생성자가 기초 클래스의 생성자를 호출한다. 이 시퀀스는 상속 매커니즘과 다르다. 그래서, 파생 클래스는 기초 클래스 생성자를 상속하지 않는다. 따라서 가상으로 만들 이유가 전혀 없다. 파생 클래스가 가상 함수를 다시 정의 하지 않으면? 기초 클래스의 버전을 사용한다. 만약, 파생 클래스가 길게 이어진 파생 사슬의 일부라면? 가장 최근에 정의된 버전을 사용한다. 다만, 기초 클래스의 버전이 은닉되어 있는 경우는 예외이다. 가상 함수를 다시 정의하면, 메서드가 은닉된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class BaseClass { public: virtual void Show(int n) const; // 매개변수 존재 }; class DerivedClass : public BaseClass { public: virtual void Show() const; // 매개변수 없음. }; int main() { DerivedClass derived; derived.Show(); // (O) derived.Show(1); // (X) 매개변수 없는 버전에 의해 가려졌다. } 매개변수가 없는 새로운 정의는 매개변수가 있는 기초 클래스 버전을 가린다.\n다시 말하면, 상속된 메서드를 다시 정의하는 것은 오버로딩과는 다르다. 매개변수 시그내처와는 상관 없이 같은 이름을 가진 모든 기초 클래스 메서드들을 가린다. 따라서 이것 때문에 두 가지 규칙이 성립된다.\n(1) 재정의 시 오리지널 원형과 정확히 일치시켜야 한다. 예외: 리턴형의 공변(covariance) 리턴형이 기초 클래스에 대한 참조/포인터인 경우 파생 클래스에 대한 참조/포인터로 대체 될 수 있다. (2) 기초 클래스 선언이 오버로딩되어 있다면, 파생 클래스에서 모두 재정의해야 한다. 만약 한 가지 버전만 제공하면, 그 한 가지가 나머지를 모두 가린다. 변경이 필요 없다면 다음과 같이 재정의 할 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BaseClass { public: virtual BaseClass \u0026amp; ReturnTest(); virtual void Show() const; virtual void Show(int n) const; }; class DerivedClass : public BaseClass { public: virtual DerivedClass \u0026amp; ReturnTest(); // (1번 설명 예시) 동일한 함수 시그내처이다. virtual void Show() const; virtual void Show(int n) const { BaseClass::Show(n); // (2번 설명 예시) 필요 없다면, 이렇게 하면 된다. } }; 접근 제어: protected 클래스 접근 제어를 위한 키워드 세 가지\nprivate protected public protected\n바깥 세계에서 바라보면 private처럼 행동하지만, 파생 클래스 입장에서는 public 멤버와 같이 행동한다. 가능하다면 protected 접근 제어보다 private 접근 제어를 사용해서 메서드를 통해 안전하게 기초 클래스의 데이터에 접근하도록 해야한다.\n추상화 기초 클래스 원과 타원 클래스를 만들고자 한다. 원을 타원의 한 종류로 보아 타원을 상속받아서 원 클래스를 만들 수 있겠다. 하지만 타원에 속한 것들 중 대다수는(반장경 변수, 반당경 변수, 회전시키기 함수 등)은 원에는 필요 없는 것들이다. 그냥 따로 각각 클래스를 만드는 게 낫겠다. 아니면 공통적인 것들만 뽑아서 기초 클래스를 만들어보던지? 추상화 기초 클래스(abstract basic class; ABC) 두 클래스의 공통적인 부분만 따로 뽑아서 만든 기초 클래스이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class BaseEllipse { private: double x, y; public: BaseEllipse(double x0 = 0, double y0 = 0) : x(x0), y(y0) {} virtual ~BaseEllipse() {} void Move(int nx, int ny) { x = nx; y = ny; } virtual double Area() const = 0; // 순수 가상 함수 }; Area()는 원과 타원 각각 다르게 구현해야 하므로 순수 가상 함수(pure virual function) 로 만들었다. 순수 가상 함수는 함수 선언 뒤에 =0을 가진다. 순수 가상 함수는 반드시 정의를 할 필요는 없다. 해도 되고, 안 해도 된다. 순수 가상 함수가 들어 있는 클래스는 자신의 객체를 생성할 수 없다. 왜냐하면 순수 가상 함수는 기초 클래스의 역할을 하기 위해서만 존재하기 때문이다. 어떤 클래스가 진짜 ABC가 되려면 순수 가상 함수가 적어도 하나 이상 있어야 한다. 상속과 동적 메모리 대입 1. 파생 클래스가 new를 사용하지 않는 경우.\n기초 클래스는 동적 메모리 대입을 사용한다. 그래서 파괴자, 복사 생성자, 대입 연산자를 가지고 있다.\n하지만 파생 클래스는 동적 메모리 대입을 사용하지 않는다.\n이 때, 파생 클래스에도 명시적 파괴자, 복사 생성자, 대입 연산자를 정의해야 할까?\n정답은 아니오이다. 파괴자\n파생 클래스의 디폴트 파괴자는 기초 클래스의 파괴자를 항상 호출한다. 따라서 디폴트 파괴자로 충분하다. 복사 생성자\n파생 클래스의 디폴트 복사 생성자는 가지고 있는 기초 클래스의 성분을 복사하기 위해, 명시적인 기초 클래스의 복사 생성자를 사용한다. 따라서 파생 클래스의 디폴트 복사 생성자로도 괜찮다. 대입 연산자\n마찬가지로, 기초 클래스의 대입 연산자를 사용하므로 파생 클래스는 명시적으로 대입 연산자를 정의하지 않아도 된다. 2. 파생 클래스가 new를 사용하는 경우\n당연히 명시적 파괴자, 복사 생성자, 대입 연산자를 정의해야 한다.\n파괴자\n파생 클래스에서 사용한 메모리를 해제하는 명시적 파괴자를 만든다. 복사 생성자\n파생 클래스의 복사 생성자는 자신의 데이터에만 접근할 수 있으므로 기초 클래스의 복사 생성자를 호출한다. 1 2 3 4 5 DerivedClass::DerivedClass(const DerivedClass \u0026amp; d) : BaseClass(d) // 기초 클래스의 복사 생성자를 호출한다. { // new로 메모리 할당 후 복사 } 대입 연산자 마찬가지로, 기초 클래스의 대입 연산자를 호출해준다. 1 2 3 4 5 6 7 8 9 10 DerivedClass \u0026amp; DerivedClass::operator=(const DerivedClass \u0026amp; d) { // ... // 기초 클래스의 대입 연산자를 호출한다. // *this = d; 와 같은 효과이다. BaseClass::operator=(d); //... } 기초 클래스의 friend에 접근하는 법 프렌드는 멤버 함수가 아니기 때문에 사용 범위 결정 연산자로 접근할 수 없다. 해결 방법 강제 데이터형 변환을 사용해서 접근한다. 나중에 소개할 dynamic_cast\u0026lt;\u0026gt; 연산자를 사용할 수도 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class BaseClass { public: friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const BaseClass \u0026amp; b) { os \u0026lt;\u0026lt; \u0026#34;기초 클래스\u0026#34;; } }; class DerivedClass : public BaseClass { public: friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const DerivedClass \u0026amp; d) { // 방법 1 os \u0026lt;\u0026lt; (const BaseClass \u0026amp;)d \u0026lt;\u0026lt; \u0026#34; 그리고, 파생 클래스\u0026#34;; // 방법 2 os \u0026lt;\u0026lt; dynamic_cast\u0026lt;const BaseClass \u0026amp;\u0026gt;(d) \u0026lt;\u0026lt; \u0026#34; 그리고, 파생 클래스\u0026#34;; } }; 그 외의 사항들 상속되지 않는 것 생성자 파괴자 대입 연산자 파생 클래스 객체를 기초 클래스 객체에 대입하면 어떻게 될까? 왼쪽에 있는 객체에 의해 호출되므로, 기초 클래스의 대입 연산자가 호출된다. 따라서 파생 클래스가 가지는 값들은 모두 무시된다. 1 2 3 4 BaseClass base; DerivedClass derived; base = derived; // BaseClass의 대입 연산자가 호출된다. 반대로 기초 클래스 객체를 파생 클래스에 대입하면 어떻게 될까? 파생 클래스의 대입 연산자가 호출된다. 파생 클래스의 대입 연산자의 매개변수는 파생 클래스이다. 하지만 파생 클래스는 자동으로 기초 클래스를 참조할 수 없다. 대안 변환 생성자를 만든다. 기초 클래스를 대입하기 위한 또다른 대입 연산자를 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class DerivedClass { public: // 변환 생성자 (방법 1) DerivedClass(const BaseClass \u0026amp; b) { //... } // 대입 연산자 DerivedClass \u0026amp; operator=(const DerivedClass \u0026amp; d) { //... } // 기초 클래스를 대입하기 위한 또다른 대입 연산자 (방법 2) DerivedClass \u0026amp; operator=(const BaseClass \u0026amp; b) { //... } }; int main() { BaseClass base; DerivedClass derived; derived = base; // DerivedClass의 대입 연산자가 호출된다. } 부적절한 코드는 동적 결합을 불가능하게 만들 수 있으므로 주의하자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class BaseClass { public: virtual void View() const; }; class DerivedClass : public BaseClass { public: virtual void View() const; }; void CallByRefernce(const BaseClass \u0026amp; b) { b.View(); } void CallByValue(BaseClass b) { b.View(); } int main() { DerivedClass derived; // 실제 참조하는 객체인 DerivedClass의 View()를 호출된다. CallByRefernce(derived); // BaseClass(const BaseClass \u0026amp;)생성자로 만든 BaseClass의 View()를 호출한다. CallByValue(derived); } 멤버 함수의 특성 함수 상속 멤버 또는 프렌드 디폴트로 생성 가상으로 선언 리턴형 생성자 X 멤버 O X X 파괴자 X 멤버 O O X = X 멤버 O O O \u0026amp; O 둘 중 하나 O O O 변환 O 멤버 X O X () O 멤버 X O O [] O 멤버 X O O -\u0026gt; O 멤버 X O O op= O 둘 중 하나 X O O new O static 멤버 X X void * delete O static 멤버 X X void 기타 연산자 O 둘 중 하나 X O O 기타 멤버 O 멤버 X O O 프렌드 X 프렌드 X X O ","date":"2022-03-20T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-13/","title":"[C++ Primer Plus] Chapter 13. 클래스의 상속"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n서론 어떤 사람의 이름을 저장하는 클래스를 만들고 싶다고 하자, 만약 이름 길이가 40자가 넘어가면 어떻할 것인가? 40개를 저장할 수 있는 문자 배열을 만들면 될까? 그럼 극히 일부만 채워지는 멤버 때문에 많은 메모리가 낭비될 것이다. 문자열의 길이가 컴파일 할 때가 아니라 실행할 때 결정되도록 하면 좋겠다. 일반적으로 string 클래스를 사용하면 되지만, new와 delete를 사용해서 메모리에 대해 배워보기 위해 string 클래스와 비슷한 클래스를 직접 만들어보면서 배워보자. 무언가 잘못된 StringBad 클래스 string 클래스와 비슷한 기능을 하는 StringBad 클래스를 만들어보았다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // StringBad.h #include \u0026lt;iostream\u0026gt; using namespace std; class StringBad { private: char * str; int len; // static 클래스 멤버는 생성되는 객체 수와 상관없이 단 하나만 생성된다. static int stringCount; public: StringBad(const char * s); StringBad(); ~StringBad(); friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const StringBad \u0026amp; st); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // StringBad.cpp #include \u0026lt;cstring\u0026gt; #include \u0026#34;StringBad.h\u0026#34; // static 클래스 멤버를 초기화 한다. int StringBad::stringCount = 0; StringBad::StringBad(const char * s) { // str = s로 하면 안 된다. 주소만 저장하기 때문이다. // 아래와 같이 문자열의 복사본을 만들어서 저장해야 한다. len = strlen(s); str = new char[len + 1]; // 문자열은 힙에 저장되겠다. strcpy(str, s); stringCount++; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; 이 생성됨. \u0026#34; \u0026lt;\u0026lt; \u0026#34; stringCount: \u0026#34; \u0026lt;\u0026lt; stringCount \u0026lt;\u0026lt; endl; } StringBad::StringBad() { len = 6; str = new char[6]; strcpy(str, \u0026#34;empty\u0026#34;); stringCount++; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; 이 생성됨. \u0026#34; \u0026lt;\u0026lt; \u0026#34; stringCount: \u0026#34; \u0026lt;\u0026lt; stringCount \u0026lt;\u0026lt; endl; } StringBad::~StringBad() { --stringCount; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; 이 파괴됨. \u0026#34; \u0026lt;\u0026lt; \u0026#34; 남은 stringCount: \u0026#34; \u0026lt;\u0026lt; stringCount \u0026lt;\u0026lt; endl; // 객체를 파괴할 때 객체가 차지하는 메모리는 해제되지만 // 객체의 멤버인 포인터가 가리키는 메모리는 자동으로 해제되지 않는다. // 따라서 아래와 같이 해제해준다. delete [] str; } ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const StringBad \u0026amp; st) { os \u0026lt;\u0026lt; st.str; return os; } static 멤버 변수 해당 클래스로 만들어지는 객체의 전체 수를 카운트해보기 위해 만들었다. 생성되는 객체 수에 상관 없이 이 변수는 단 하나만 생성되고, 공유된다. 초기화를 클래스 선언 안에서 할 수 없다. 왜냐하면 static 멤버 변수는 객체의 일부분으로 저장되는 것이 아니라 별도로 저장되기 때문이다. 그래서 클래스 선언 바깥에서 초기화해주어야 한다. 헤더 파일에서 초기화한다면, 헤더파일이 여러번 포함되어 그 개수만큼 여러번 반복되어 초기화하기 때문에 에러가 발생한다. 따라서 멤버 함수 구현 파일에 넣는다. 정수형/열거형의 const인 경우에는 클래스 선언 안에서 초기화할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026#34;StringBad.h\u0026#34; using namespace std; void CallByReference(StringBad\u0026amp; s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; 가 참조로 전달되었다\u0026#34; \u0026lt;\u0026lt; endl; } // 값으로 객체를 전달하면, 복사 생성자가 호출된다. void CallByValue(StringBad s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; 가 값으로 전달되었다\u0026#34; \u0026lt;\u0026lt; endl; } int main() { { StringBad one(\u0026#34;one\u0026#34;); StringBad two(\u0026#34;two\u0026#34;); StringBad three(\u0026#34;three\u0026#34;); cout \u0026lt;\u0026lt; endl; CallByReference(one); cout \u0026lt;\u0026lt; \u0026#34;돌아온 one: \u0026#34; \u0026lt;\u0026lt; one \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; CallByValue(two); cout \u0026lt;\u0026lt; \u0026#34;돌아온 two: \u0026#34; \u0026lt;\u0026lt; two \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; // 하나의 객체를 다른 객체로 초기화하면 복사 생성자가 호출된다. cout \u0026lt;\u0026lt; \u0026#34;three 객체로 초기화하기\u0026#34; \u0026lt;\u0026lt; endl; StringBad three2 = three; cout \u0026lt;\u0026lt; \u0026#34;three2: \u0026#34; \u0026lt;\u0026lt; three2 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; // 하나의 객체러르 다른 객체에 대입하면 대입 연산자가 호출된다. cout \u0026lt;\u0026lt; \u0026#34;one 객체로 대입하기\u0026#34; \u0026lt;\u0026lt; endl; StringBad one2; one2 = one; cout \u0026lt;\u0026lt; \u0026#34;one2: \u0026#34; \u0026lt;\u0026lt; one2 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } } 출력 결과 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 one 이 생성됨. stringCount: 1 two 이 생성됨. stringCount: 2 three 이 생성됨. stringCount: 3 one 가 참조로 전달되었다 돌아온 one: one two 가 값으로 전달되었다 two 이 파괴됨. 남은 stringCount: 2 // 문제 1 돌아온 two: L three 객체로 초기화하기 three2: three one 객체로 대입하기 empty 이 생성됨. stringCount: 3 one2: one one 이 파괴됨. 남은 stringCount: 2 three 이 파괴됨. 남은 stringCount: 1 � 이 파괴됨. 남은 stringCount: 0 signal: aborted (core dumped) // 문제 2 다음과 같은 문제가 있다. (1) 값으로 전달된 후 파괴자가 호출되었다. 그리고 원본 two 객체의 값이 이상해졌다. (2) 블록을 빠져나오면 파괴자가 줄줄이 호출되는데 객체 수가 2개나 부족하다. 무언가 또 다른 것이 파괴자를 호출한 것임에 분명하다. C++이 자동으로 다음과 같은 멤버 함수들을 제공한다.\n(1) 생성자를 전혀 정의하지 않았을 경우에 디폴트 생성자 (2) 디폴트 파괴자를 정의하지 않았을 경우에 디폴트 파괴자 (3) 복사 생성자를 정의하지 않았을 경우에 복사 생성자 (4) 대입 연산자를 정의하지 않았을 경우에 대입 연산자 (5) 주소 연산자를 정의하지 않았을 경우에 주소 연산자 이동 생성자, 이동 대입 연산자 (C++11) (Chapter 18) 암시적 주소 연산자는 호출한 객체(this 포인터의 값)의 주소를 리턴한다.\n이것은 StringBad 클래스의 설계 목적에 합당하다. 하지만 복사 생성자와 대입 연산자는 그렇지 않다. 복사 생성자 원형 1 StringBad(const StringBad \u0026amp;); 복사 생성자가 불리는 경우: 프로그램이 객체의 복사본을 생성할 때 새로운 객체가 생성되어 같은 종류의 기존의 객체로 초기화될 때 함수가 객체를 값으로 전달할 때 함수가 객체를 리턴할 때 임시객체를 생성할 때 1 2 3 4 5 6 StringBad one(\u0026#34;one\u0026#34;) // 초기화 시에는 모두 복사 생성자를 호출한다. StringBad two(one); StringBad three = StringBad(one); StringBad * four = new StringBad(one); 하는 일 static 멤버를 제외한 멤버들을 멤버별로 복사한다(얕은 복사). 각 멤버는 값으로 복사한다. 따라서 아래의 두 코드는 같은 말이다. 1 2 3 4 5 StringBad two = one; // 이것과 StringBad two; // 이것은 같은 말이다. two.str = one.str; two.len = one.len; StringBad 예시에서 값으로 전달된 후에 원본 객체의 값이 이상해진 건 복사 생성자 때문이었다.\nCallByValue()가 호출될 때 값으로 전달되는 매개변수를 초기화하는 데 복사 생성자가 사용된다. CallByValue() 함수가 끝나면서 파괴자를 호출해서 전달된 객체 원본의 메모리를 해제해버린다. StringBad 예시에서 파괴된 객체가 두 개 더 많았던 것 중 하나는 복사 생성자 때문이었다.\nthree2 객체를 three 객체로 초기화할 때 복사 생성자가 사용된다. 우리는 복사 생성자를 정의하지 않았으므로 이 때 불리는 복사 생성자는 stringCount를 올려주지 않는다. 또한 복사 생성자는 문자열 자체를 복사하지 않고 문자열을 지시하는 포인터를 복사한다. 즉, 얕은 복사를 한다. 두 개의 포인터가 하나의 문자열을 가리키는 형상이 되는 것이다. 따라서 다음과 같은 문제가 생겼던 것이다. 그래서 three2의 파괴자가 불렸을 때 three의 메모리를 해제해버린다. 그리고 three의 파괴자는 이미 삭제한 문자열을 다시 삭제하려고 시도한다. 명시적 복사 생성자를 제공함으로써 문제를 해결할 수 있다. 아래의 코드는 깊은 복사를 수행한다. 즉, 문자열 자체를 복사하고, 그 복사본의 주소를 str 멤버에 대입하게 한다. 1 2 3 4 5 6 7 StringBad::StringBad(const StringBad \u0026amp; st) { stringCount++; len = st.len; str = new char[len + 1]; strcpy(str, st.str); } 클래스 멤버 중에 포인터가 있다면 복사 생성자를 필수로 정의해야 한다.\n대입 연산자 원형 1 StringBad \u0026amp; StringBad::operator=(const StringBad \u0026amp;); 대입 연산자가 불리는 경우 하나의 객체를 기존의 다른 객체에 대입할 때 1 2 3 StringBad one(\u0026#34;one\u0026#34;); StringBad one2; one2 = one; 하는 일 복사 생성자와 마찬가지로 static 멤버를 제외한 멤버들을 멤버별로 복사한다(얕은 복사). StringBad 예시에서 파괴된 객체가 두 개 더 많았던 것 중 하나는 대입 연산자 때문이었다. one2 객체를 one 객체로 초기화할 때 대입 연산자가 사용된다. 우리는 대입 연산자를 정의하지 않았으므로 이 때 불리는 대입 연산자는 stringCount를 올려주지 않는다. 또한 대입 연산자는 얕은 복사를 하기 때문에 one2의 파괴자가 불렸을 때 one의 메모리를 해제해버린다. 그리고 one의 파괴자는 이미 삭제한 문자열을 다시 삭제하려고 시도한다. 명시적 대입 연산자를 제공함으로써 문제를 해결할 수 있다. 복사 연산자와의 차이에 유념하며 구현해야 한다. 차이점은 아래와 같다. (1) 이전에 대입된 데이터를 참조하고 있을 수도 있으므로 먼저 해제해주어야 한다. (2) 자기 자신에게 대입하지 못하게 막아야 한다. (3) 호출한 객체에 대한 참조를 리턴해야 한다. 그래야 one = two = three; 와 같은 연산이 가능해진다. 1 2 3 4 5 6 7 8 9 10 11 StringBad \u0026amp; StringBad::operator=(const StringBad \u0026amp; st) { if (this == \u0026amp;st) return *this // 2 delete [] str; // 1 len = st.len; str = new char[len + 1]; strcpy(str, st.str); return *this; // 3 } 대입은 새로운 객체를 만들지 않는다. 따라서 stringCount를 올릴 필요는 없다. 개선된 String 클래스 위와 같은 문제들을 개선한 String 클래스이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // String.h #include \u0026lt;iostream\u0026gt; using namespace std; class String { private: char * str; int len; static int stringCount; static const int CINLIM = 80; // cin 입력 제한 글자수 public: String(const char * s); String(); String(const String \u0026amp;); // 명시적 복사 생성자 ~String(); int length () const { return len; } String \u0026amp; operator=(const String \u0026amp;); // 명시적 대입 연산자 String \u0026amp; operator=(const char *); // 보통의 문자열을 String 객체에 복사하기 위한 대입 연산자 char \u0026amp; operator[](int i); // []표기를 사용해서 개별 문자에 접근하기 const char \u0026amp; operator[](int i) const; // const 객체에 사용하기 위함 friend bool operator\u0026lt;(const String \u0026amp;st, const String \u0026amp;st2); friend bool operator\u0026gt;(const String \u0026amp;st1, const String \u0026amp;st2); friend bool operator==(const String \u0026amp;st, const String \u0026amp;st2); friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const String \u0026amp; st); friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp; is, String \u0026amp; st); static int HowMany(); // static 멤버 함수 }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // string1.cpp #include \u0026lt;cstring\u0026gt; #include \u0026#34;String.h\u0026#34; using namespace std; int String::stringCount = 0; // static 멤버 함수 int String::HowMany() { return stringCount; } String::String(const char * s) { len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); stringCount++; } // 개선된 디폴트 생성자 String::String() { len = 0; str = new char[1]; str[0] = \u0026#39;\\0\u0026#39;; stringCount++; } String::String(const String \u0026amp; st) // 명시적 복사 생성자 { stringCount++; len = st.len; str = new char [len + 1]; std::strcpy(str, st.str); } String::~String() { --stringCount; delete [] str; } String \u0026amp; String::operator=(const String \u0026amp; st) // 명시적 대입 연산자 { if (this == \u0026amp;st) return *this; delete [] str; len = st.len; str = new char[len + 1]; std::strcpy(str, st.str); return *this; } // 보통의 문자열을 String 객체에 복사하기 위한 대입 연산자 String \u0026amp; String::operator=(const char * s) { delete [] str; len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); return *this; } // []표기를 사용해서 개별 문자에 접근하기 char \u0026amp; String::operator[](int i) { return str[i]; } // const 객체에 사용하기 위함 const char \u0026amp; String::operator[](int i) const { return str[i]; } // friend 함수들 bool operator\u0026lt;(const String \u0026amp;st1, const String \u0026amp;st2) { return (std::strcmp(st1.str, st2.str) \u0026lt; 0); } bool operator\u0026gt;(const String \u0026amp;st1, const String \u0026amp;st2) { return st2 \u0026lt; st1; } bool operator==(const String \u0026amp;st1, const String \u0026amp;st2) { return (std::strcmp(st1.str, st2.str) == 0); } ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const String \u0026amp; st) { os \u0026lt;\u0026lt; st.str; return os; } istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp; is, String \u0026amp; st) { char temp[String::CINLIM]; is.get(temp, String::CINLIM); if (is) st = temp; while (is \u0026amp;\u0026amp; is.get() != \u0026#39;\\n\u0026#39;) continue; return is; } 1. 개선된 디폴트 생성자\n1 2 3 4 5 6 7 8 9 10 11 12 13 String::String { len = 0; // 이것은 파괴자에 있는 delete [] str;과 맞추기 위함이다. str = new char[1]; str[0] = \u0026#39;\\0\u0026#39;; // 이렇게 써도 된다. str = nullptr; stringCount++; } 널 포인터 아무것도 가리키는 않는 포인터이다. C++가 소스 코드에서 0을 표현할 때 널 포인터를 사용했다. 하지만 종종 포인터 상수와 정수 모두 0으로 표현하기 때문에 문제가 발생했고 새로운 키워드 nullptr을 제공했다. 이것은 포인터 타입이며 정수형으로 변환할 수 없다. nullptr == 0은 true지만, 예를 들어서 int형 매개변수를 받는 함수에서 0은 통과되지만 nullptr은 컴파일 에러가 난다. 따라서 컴파일러가 분명하고 안전하게 받아들일 수 있도록 nullptr를 사용해야 한다. 2. []표기를 사용해서 개별 문자에 접근하기\n1 2 char name[10] = \u0026#34;Kim\u0026#34;; cout \u0026lt;\u0026lt; name[0] \u0026lt;\u0026lt; endl; name은 첫번째 피연산자이고, []은 연산자이고, 0은 두 번째 피연산자이다. 따라서 []연산자를 다음과 같이 만들 수 있다. 리턴형이 char \u0026amp;이기 때문에 값을 대입하는 것 또한 가능하다. 1 2 3 4 5 6 7 8 char \u0026amp; String::operator[](int i) { return str[i]; } String one(\u0026#34;one\u0026#34;); cout \u0026lt;\u0026lt; one[0] \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; one[0]; // (O) 하지만 const 객체에는 사용이 불가능하다. C++이 const함수 시그내처와 const가 아닌 함수 시그내처를 구별하기 때문이다. 따라서 const String 객체가 사용할 수 있는 제 2의 버전을 제공할 수 있다. 1 2 3 4 5 6 7 8 const char \u0026amp; String::operator[](int i) const { return str[i]; } const String one(\u0026#34;one\u0026#34;); cout \u0026lt;\u0026lt; one[0] \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; one[0]; // (X) const 객체는 쓰기가 불가능하다. 3. 보통의 문자열을 String 객체에 복사하기를 원한다면 어떻게 해야 할까?\n1 2 3 4 String name; char temp[40]; cin.getline(temp, 40); name = temp; 이 예제의 마지막 구문은 이렇게 동작한다.\n(1) String(const char *) 생성자(변환 함수의 역할)를 사용해서 temp를 String 임시 객체로 만든다. (2) String \u0026amp; operator=(const String \u0026amp; ) 함수를 사용해서 String 임시 객체의 내용을 name에 담는다. (3) String 임시 객체를 파괴한다. 따라서 다음과 같은 대입 연산자를 오버로딩하면, 임시 객체를 생성하고 파괴하는 절차가 생략되겠다.\n1 2 3 4 5 6 7 8 String \u0026amp; String::operator=(const char * s) { delete [] str; len = strlen(s); str = new char[len + 1]; strcpy(str, s); return *this; } 4. static 멤버 함수\nstatic 키워드는 함수 선언에 나타나야 한다. 다음과 같은 특징을 가진다. 객체에 의해 호출될 필요가 없다. 클래스 이름과 사용범위 결정 연산자를 사용하여 호출된다. 어떤 특정 객체와도 결합하지 않기 때문에 사용할 수 있는 데이터 멤버는 static 데이터 멤버밖에 없다. 1 2 3 4 5 6 7 8 9 10 11 class String { public: // … static int HowMany() { return stringCount; } // static 멤버에만 접근할 수 있다. }; int main() { int count = String::HowMany(); // static 멤버 함수를 호출한다. } 객체 리턴에 대한 관찰 1. const 객체를 참조 리턴하는 경우\n효율성 측면에서 유리하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 class Vector {}; // 리턴형이 Vector 라면 복사 생성자를 호출할 것이다. // 참조를 리턴함으로써 좀 더 효율적이게 된다. const Vector \u0026amp; Max(const Vector \u0026amp; v1, const Vector \u0026amp; v2) { if (v1.magval() \u0026gt; v2.magval()) return v1; else return v2; } Vector vec1(30, 60); Vector vec2(10, 70); Vector max = Max(vec1, vec2); 2. const가 아닌 객체를 참조 리턴 하는 경우\n대입 연산자 오버로딩 cout과 함께 사용하기 위한 \u0026lt;\u0026lt; 연산자 오버로딩 1 2 3 4 5 6 7 8 9 String s1(\u0026#34;Good Stuff\u0026#34;); String s2, s3; s3 = s2 = s1; // s2 = s1의 리턴 값이 s1의 참조여야 s3 = s1가 가능하다. // 참조가 아니면 복사 생성자가 호출되므로, 참조로 리턴하는 게 효율적이다. cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34; is coming!\u0026#34;; // ostream은 public 복사 생성자를 만들지 않으므로 // 참조가 아니면 동작하지 않는다. 3. const 객체를 리턴하는 경우\n리턴되는 객체가 지역적이면 참조를 리턴하면 안 된다. 1 2 3 4 5 6 7 8 9 Vector vec1(50, 60); Vector vec2(10, 70); Vector sum = vec1 + vec2; // 두 벡터의 합의 결과인 임시벡터를 참조로 리턴하면 안된다. 실제 객체를 리턴해야 한다. Vector Vector::operator+(const Vector \u0026amp; v) const { return Vector(x + v.x, y + v.y); } 4. const가 아닌 객체를 리턴하는 경우\n위의 코드인 경우 아래와 같은 것이 가능해진다. 1 2 3 4 sum = vec1 + vec2; // 이것도 가능하다. vec1 + vec2의 결과로 임시객체를 만들고, 그것에 sum의 값이 대입된다. vec1 + vec2 = sum; 따라서 다음과 같이 리턴형을 const로 하면 두번째 경우는 불가능해 진다. 1 2 3 4 const Vector Vector::operator+(const Vector \u0026amp; v) const { return Vector(x + v.x, y + v.y); } 위치 지정 new와 클래스 1 2 3 4 5 6 7 8 char * buffer = new char[512]; TestClass *t1, *t2; t1 = new (buffer) TestClass(\u0026#34;test one\u0026#34;); t2 = new (buffer) TestClass(\u0026#34;test two\u0026#34;); // t1의 데이터를 덮어쓴다 delete [] buffer; t2의 경우 t1의 데이터를 덮어 쓴다. 이것은 t1에 대한 파괴자가 호출하지 않기 때문에 위험하다. 따라서 다음과 같이 바꿀 수 있겠다. 1 t2 = new (buffer + sizeof(TestClass)) TestClass(\u0026#34;test two\u0026#34;); 이 구현은 t1, t2 객체에 대한 파괴자를 부르지 않는다. delete [] t1; 으로 한다고 해도 t1은 buffer를 해제할 것이다. 따라서 파괴자를 명시적으로 호출할 수 있겠다. (역순으로) 1 2 t2-\u0026gt;~TestClass(); t1-\u0026gt;~TestClass(); 큐 시뮬레이션 만들기 1. 구조체, 클래스, 열거체가 어떤 클래스 안에서 선언되면, 그 선언은 그 클래스의 사용 범위를 가진다.\n데이터 객체를 생성하지 않고, 그 클래스 안에서 내부적으로 사용할 수 있는 데이터형을 서술한다. public 부분에 있다면, 클래스 바깥에서 변수를 선언할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Queue { private: struct PrivateNode { int data; }; public: struct PublicNode { int data; }; }; int main() { PrivateNode n1; // (X) private struct는 그 클래스 안에서만 사용할 수 있다. PublicNode n2; // (X) public struct는 아래 처럼 사용해야 한다. Queue::PublicNode n3; // (O) } 2. 멤버 초기자 리스트\nconst형 멤버를 초기화하기 위해서는 어떻게 해야할까? 1 2 3 4 5 class Queue { private: const int queueSize; // 이것을 0으로 초기화해야 한다. }; 생성자에서 하면 될까? const 변수는 초기화될 수는 있지만, 대입될 수는 없다. 생성자의 중괄호 안의 내용이 실행되기 전에 객체가 먼저 생성된다. 따라서 중괄호 안의 내용은 const 멤버 변수를 초기화하는 것이 아니라 대입하는 것이다. 1 2 3 4 Queue::Queue(int size) { queueSize = size; // (X) 대입이다. 안 된다. } 이럴 경우 객체가 생성될 때 초기화하는 멤버 초기자 리스트를 사용할 수 있다. 1 2 3 4 Queue::Queue(int size) : queueSize(size) { // … } 멤버 초기자 리스트 문법은 생성자만이 사용할 수 있다. 참조로 선언된 클래스 멤버들에 대해서도 이 문법을 사용해야 한다. 참조는 생성될 때만 초기화될 수 있기 때문이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Agency { }; class Agent { private: Agency \u0026amp; belong; // 참조로 선언된 클래스 멤버 public: Agent(Agency \u0026amp; a); }; // 멤버 초기자 리스트를 사용해서 초기화해야 한다. Agent::Agency(Agency \u0026amp; a) : belong(a) { // … } 3. 복사와 대입을 막는 복사 연산자와 대입 연산자를 구현 방법\n지금 당장은 깊은 복사를 하는 복사 연산자와 대입 연산자가 필요 없다. 하지만 위험하므로 복사와 대입은 막고 싶다면? 명목상의 private 메서드로 정의한다. 그러면 바깥에서 사용하지 못하게 된다. 또 다른 방법은 delete 키워드를 사용하는 것이다. (Chapter 18) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Queue { private: // 선점 정의 Queue(const Queue \u0026amp; q) : queueSize(0) { } Queue \u0026amp; operator=(const Queue \u0026amp; q) { return *this; } }; int main() { Queue q1; Queue q2(q1); // (X) Queue q3; q3 = q1; // (X) } ","date":"2022-03-19T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-12/","title":"[C++ Primer Plus] Chapter 12. 클래스와 동적 메모리 대입"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n연산자 오버로딩 시그내처(매개변수 리스트)를 다르게 제공하면 이름이 같은 여러 함수를 정의할 수 있다. 이것을 함수 오버로딩 또는 함수 다형이라고 한다. 연산자 오버로딩은 그 개념을 연산자에까지 확장해서 C++ 연산자에 다중적인 의미를 부여하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Time { private: int hours; int minutes; public: Time(); Time(int h, int m = 0); // 두 Time 객체의 시간을 더하는 함수 Sum Time Sum(const Time \u0026amp; other) const { Time result; result.minutes = minutes + other.minutes; result.hours = hours + other.hours + result.minutes / 60; result.minutes %= 60; return result; } // 연산자 오버로딩을 활용한 버전 Time operator+(const Time\u0026amp; other) const { Time result; result.minutes = minutes + other.minutes; result.hours = hours + other.hours + result.minutes / 60; result.minutes %= 60; return result; } }; int main() { Time t1(3, 30); Time t2(2, 50); // 모두 같은 결과이다 Time sumResult1 = t1.Sum(t2); Time sumResult2 = t1.operator+(t2); Time sumResult3 = t1 + t2; Time t3(4, 29); Time sumResult4 = t1 + t2 + t3; // 적법한 문법이다 Time sumResult5 = t1.operator+(t2.operator+(t3)); } 이 예제의 Sum() 함수에서 리턴값은 참조형이 될 수 없다. 리턴되는 객체는 함수 안에서 만들어지므로 함수가 종료되면 사라진다. 따라서 존재하지 않는 객체에 대한 참조가 되어버린다. 오버로딩 제약 적어도 하나의 피연산자가 사용자 정의 데이터형이어야 한다. 예를 들면, 표준 데이터형인 두 개의 int형의 빼기를 다른 식으로 재정의 할 수 없다. 연산자 기호를 새로 만들 수 없다. 본래 그 연산자에 적용되는 문법적인 규칙을 위반할 수 없다. 연산자의 우선순위도 변경할 수 없다.예를 들면, 다음과 같은 연산은 안 된다. 1 2 3 4 int x; Time t; % x; // 나머지 연산자로 사용할 수 없다. % t; // 따라서 오버로딩 연산자로 사용할 수도 없다. 오버로딩 할 수 있는 연산자들 + - * / % ^ \u0026amp; | ~ ! = \u0026lt; \u0026gt; += -= *= /= %= ^= \u0026amp;= |= \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;= \u0026lt;\u0026lt;= == != \u0026lt;= \u0026gt;= \u0026amp;\u0026amp; || ++ -- , -\u0026gt;* -\u0026gt; () [] new delete new [] delete [] 다음과 같은 연산자들은 멤버함수로만 오버로딩 할 수 있다. 연산자 이름 = 대입 연산자 () 함수 호출 연산자 [] 배열 인덱스 연산자 -\u0026gt; 클래스 멤버 접근 포인터 연산자 프렌드 일반적으로 객체의 private 부분에 접근할 수 있는 유일한 통로는 public 멤버 함수들이다. 하지만 프렌드를 사용하면 객체의 private 부분에도 접근할 수 있다.\n만약, Time 객체와 double 형 데이터를 곱셈하는 연산자가 필요하다면 어떻게 해야할까?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Time { private: int hours; int minutes; public: Time operator*(double d) const { Time result; long totalMinutes = hours * d * 60 + minutes * d; result.hours = totalMinutes / 60; result.minutes = totalMinutes % 60; return result; } } int main() { Time t(10, 2); Time mulResult1 = t * 2.75; Time mulResult2 = 2.75 * t; // 멤버 함수로 구현이 불가능하다. } Time형 객체 * double형 데이터는 operator*멤버함수로 해결 가능하다. 하지만 double형 데이터 * Time형 객체의 연산은 불가능하다. 멤버 함수는 객체를 사용해서만 호출이 가능하기 때문이다. 그렇다면 멤버가 아닌 함수를 만들어볼 수 있다. 멤버가 아닌 오버로딩 연산자 함수는 첫번째 매개변수가 왼쪽 피연산자이며, 두번째 매개변수가 오른쪽 피연산자가 된다. 하지만 멤버가 아닌 함수는 Time의 private 데이터에 접근할 수 없는 또 다른 문제가 생긴다. 1 2 3 4 5 6 7 8 9 10 11 12 Time operator*(double d, const Time \u0026amp; t) { // (X) 멤버가 아닌 함수는 Time의 private 데이터에 접근할 수 없다. Time result; long totalMinutes = t.hours * d * 60 + t.minutes * d; result.hours = totalMinutes / 60; result.minutes = totalMinutes % 60; return result; } 이때, 멤버 함수는 아니지만 private 멤버에 접근할 수 있는 프렌드라는 특별한 함수를 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Time { private: // … public: // 앞에 friend를 붙인 함수 원형을 클래스 선언에 넣는다. friend Time operator*(double d, const Time\u0026amp; t); // … } Time operator*(double d, const Time \u0026amp; t) // 정의에는 friend를 넣지 않는다. { // t.operator*(d)를 사용해서 간단하게 만들 수 있다. return t * d; //Time result; // //long totalMinutes = t.hours * d * 60 + t.minutes * d; //result.hours = totalMinutes / 60; //result.minutes = totalMinutes % 60; // //return result; } 프렌드와 \u0026lt;\u0026lt; 연산자 오버로딩 \u0026lt;\u0026lt; 연산자를 오버로딩해서 cout을 사용해서 우리가 만든 Time 클래스를 출력할 수 있다면 좋겠다. 1 2 3 4 5 int number = 1; cout \u0026lt;\u0026lt; number; Time t(10, 2); cout \u0026lt;\u0026lt; t; // 이렇게 만들어 보자 \u0026lt;\u0026lt; 연산자는 비트 조작 연산자 중에 하나이다. ostream 클래스는 이 연산자를 오버로딩해서 출력 도구로 변환시킨다. ostream 클래스 선언에는 기본 데이터형에 맞게 오버로딩된 operator\u0026lt;\u0026lt;() 정의를 가지고 있다. 그래서 cout \u0026lt;\u0026lt; number; 와 같은 구문으로 기본 데이터형을 출력할 수 있다. 그렇기 때문에 기본 데이터형 대신 우리가 만든 Time클래스를 넣어서 ostream에 연산자 함수의 정의를 추가하면, Time 클래스도 cout을 통해 객체의 내용을 출력할 수 있을 것이다. 하지만 직접 iostream 파일에 접근하는 것은 위험한 생각이다. 1 2 3 4 Time t(10, 2); cout \u0026lt;\u0026lt; t; // ostream 클래스 객체인 cout을 첫번째 피연산자로 사용하므로 // 연산자 오버로딩에 대한 정의가 ostream 클래스 내에 있어야 하겠다. 반대로 Time 클래스에게 cout을 사용하는 법을 가르칠 수 있다. 하지만 \u0026lt;\u0026lt; 연산자를 다음과 같이 사용해야 하며 이것은 혼돈을 준다. 1 2 Time t(10, 2); t \u0026lt;\u0026lt; cout; // 헷갈리는 사용법 따라서 프렌드 함수를 이용해 볼 수 있겠다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Time { private: int hours; int minutes; public: friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Time\u0026amp; t); //... }; ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const Time \u0026amp; t) { os \u0026lt;\u0026lt; t.hours \u0026lt;\u0026lt; \u0026#34; 시간, \u0026#34; \u0026lt;\u0026lt; t.minutes \u0026lt;\u0026lt; \u0026#34;분\u0026#34;; return os; } int main() { Time t(10, 2); cout \u0026lt;\u0026lt; t; // 가능 } 연산자 오버로딩 함수의 리턴형이 ostream인 이유는 다음과 같은 경우 때문이다. 1 2 3 Time t1(10, 2); Time t2(20, 3); cout \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; t2; // (cout \u0026lt;\u0026lt; t1)의 리턴형이 cout이어야 cout \u0026lt;\u0026lt; t2도 가능하겠다. 클래스의 데이터형 변환 기본 데이터형을 특정 클래스로 변환할 수 있을까? 변환 생성자를 사용하면 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class PoundToKg { private: double pounds; int kg; public: PoundToKg(); explicit PoundToKg(double p) // explicit은 암시적 데이터형 변환을 못하게 한다. { kg = p * 0.453592; pounds = p; } ~PoundToKg(); void ShowKg() { cout \u0026lt;\u0026lt; kg \u0026lt;\u0026lt; \u0026#34; kg\u0026#34; \u0026lt;\u0026lt; endl; } void ShowPounds() { cout \u0026lt;\u0026lt; pounds \u0026lt;\u0026lt; \u0026#34; lbs\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { PoundToKg kg; // PoundToKg(double p) 생성자를 사용해서 19.6을 PoundToKg로 변환한다. kg = 19.6; // 암시적 데이터형 변환. explicit로 선언되었다면 (X)이다. kg = PoundToKg(19.6); // 명시적 데이터형 변환. kg = (PoundToKg) 19.6; // 명시적 데이터형 변환의 옛날 방식. } 암시적 데이터형 변환이 가능하면 이런 식으로도 동작 가능하다. 1 2 3 4 5 6 7 8 9 10 void Display(PoundToKg p) { p.ShowKg(); p.ShowPounds(); } int main() { Display(19.6); } 반대로 클래스를 기본 데이터형으로 변환할 수 없을까? 변환 함수를 사용하면 가능하다. 변환 함수 조건 (1) 클래스의 멤버 함수여야 한다. (2) 리턴형을 가지면 안 된다. (3) 매개변수를 가지면 안 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class PoundToKg { private: double pounds; int kg; public: //... explicit operator double() const // explicit은 암시적 데이터형 변환을 못하게 한다. { return pounds; } } int main() { PoundToKg kg(19.6); double dKg; // PoundToKg 클래스형을 operator double() 변환함수를 사용해서 double형으로 변환한다. dKg = kg; // 암시적 데이터형 변환. explicit로 선언되었다면 (X)이다. dKg = double(kg); // 명시적 데이터형 변환. } ","date":"2022-03-17T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-11/","title":"[C++ Primer Plus] Chapter 11. 클래스의 활용"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n클래스 추상화란 어떤 정보를 사용자 인터페이스로 표현하는 것이다. 따라서 클래스는 추상화 인터페이스를 구현하는 사용자 정의 데이터형이라고 볼 수 있다. public으로 정의된 인터페이스를 통해서만 접근이 가능하다. 클래스는 데이터와 메서드를 하나로 결합한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // cpp 파일에서 클래스의 정의를 제공한다. // = 캡슐화(세부적인 구현들을 추상화와 분리한다) class Stock // 사용자 정의 데이터형인 class. { private: // 정보 은닉. 데이터 무결성을 보호한다. = 캡슐화 char company[30]; int shares; double shareVal; double totalVal; void SetTotal() { totalVal = shares * shareVal; } public: // 설계를 추상화하여 인터페이스로 제공한다 void Acquire (const char * co, int n, double pr); void Buy (int num, double price); void Sell (int num, double price); void Update (double price); void Show (); }; 구조체와 클래스의 차이점 구조체는 디폴트 접근 제어가 public이지만, 클래스는 private이다. 인라인 메서드 클래스 선언 안에 정의를 가지는 모든 함수는 자동으로 인라인 함수가 된다. 원한다면, 선언 외부에 함수를 정의하고 inline 키워드를 넣어서 인라인 함수로 만들 수 있다. 1 2 3 4 5 6 7 8 9 10 11 class Stock { private: void SetTotal(); //… }; inline void Stock::SetTotal() { //… } 객체는 각기 자체의 데이터를 갖지만 동일한 클래스 메서드 집합을 공유한다. 1 2 3 4 5 Stock s1; // 각각의 데이터 공간을 가진다. Stock s2; s2.Show(); // 하나의 멤버 함수를 공유한다. s2.Show(); 클래스의 생성자 클래스의 데이터들은 private 접근제어를 가지고 있기 때문에 프로그램이 직접 데이터 멤버에 접근할 수 없다. 따라서 struct와 같은 방법으로 초기화할 수가 없다. 1 2 3 4 5 6 7 8 struct Student { char* name; int age; }; Student s = { \u0026#34;John\u0026#34;, 12 }; Stock ss = { \u0026#34;Sukie\u0026#34;, 200, 50.25 } // (X) 컴파일 에러. ss객체의 private 데이터에 접근 불가. 그렇기 때문에 C++은 객체를 생성할 때 자동으로 초기화하는 특별한 멤버함수인 \u0026lsquo;클래스 생성자\u0026rsquo;를 제공한다. 프로그램이 객체를 선언할 때 자동으로 생성자가 호출된다. 생성자는 리턴값을 가질 수 없으며, 명시적, 암시적으로 호출할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Stock { public: Stock(const string\u0026amp; co, int n, double pr); //… }; Stock s1 = Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); // 명시적 호출 Stock s2 (\u0026#34;Sukie\u0026#34;, 200, 50.25); // 암시적 호출 Stock* s3 = new Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); // 동적 객체 // C++11에서 허용 (초기화 리스트를 사용) Stock s4 = Stock{\u0026#34;Sukie\u0026#34;, 200, 50.25}; Stock s5 {\u0026#34;Sukie\u0026#34;, 200, 50.25}; Stock* s6 = new Stock{\u0026#34;Sukie\u0026#34;, 200, 50.25}; 디폴트 생성자는 명시적인 초기화값을 제공하지 않을 때 사용하는 생성자이다. C++는 사용자가 생성자를 제공하지 않을 때 자동으로 디폴트 생성자를 제공한다. 만약, 다른 생성자를 사용자가 만들었다면 디폴트 생성자를 제공하지 않는다. 1 2 Stock s1 = Stock(); // 디폴트 생성자를 사용한다. 만약 다른 생성자가 있다면 에러가 발생한다. Stock s2; 디폴트 생성자 정의 방법 생성자의 모든 매개변수에 디폴트 값을 제공한다. 함수 오버로딩을 사용하여 매개변수가 없는 또 하나의 생성자를 정의한다. 그러나 두 가지 방법을 동시에 사용하는 것은 안 된다. 1 2 3 4 5 6 7 class Stock { public: Stock(const string\u0026amp; co = \u0026#34;Error\u0026#34;, int n = 0, double pr = 0.0); // 방법1 Stock(); // 방법2 //... }; 클래스의 파괴자 객체의 수명이 끝나는 시점에서 프로그램은 파괴자를 자동으로 호출한다. 파괴자는 클래스 이름 앞에 틸데(~)가 붙으며 매개변수와 리턴값을 가질 수 없다. 사용자가 명시적으로 파괴자를 호출하면 안 된다. 파괴자는 컴파일러에 의해 자동으로 불려지는 것이다. 예를 들어, 정적 기억 공간에 클래스 객체를 생성한다면, 프로그램이 종료될 때 자동으로 파괴자가 호출된다. 파괴자는 반드시 있어야 하며, 사용자가 파괴자를 제공하지 않으면 컴파일러가 디폴트 파괴자를 선언한다. 이미 존재하는 객체에 생성자를 사용하면, 생성자가 새로운 임시객체를 생성하고, 새로 생성된 임시 객체의 내용이 복사된다. 그리고 임시객체의 파괴자가 호출된다. 1 2 Stock s = Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); s = Stock(\u0026#34;Nifty\u0026#34;, 100, 20.5); // 임시 객체를 생성하고, s 객체에 복사한 후, 임시 객체를 파괴한다. const 멤버 함수 어떤 멤버함수가 호출 객체를 변경하지 않는다고 약속하기 위해 const를 함수 괄호 뒤에 넣는다. 1 2 3 4 5 6 class Stock { public: void Show() const; //... }; this 포인터 this 포인터는 멤버 함수를 호출하는 데 사용된 객체를 지시한다. 일반적으로, 모든 클래스의 멤버 함수들은 this를 가지며, this는 그 해당 객체의 주소로 설정된다. 따라서 *this는 해당 객체 자체를 의미한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Stock { public: //… // 매개변수로 전달된 Stock 객체와 비교해서 totalVal이 높은 객체를 리턴한다 const Stock\u0026amp; TopValue(const Stock\u0026amp; s) const { if (s.totalVal \u0026gt; totalVal) // totalVal은 this-\u0026gt;totalVal의 약식 표기이다. return s; else return *this // 이 멤버함수를 호출한 객체 s1을 리턴한다 } }; Stock s1 = Stock(\u0026#34;Sukie\u0026#34;, 200, 50.25); Stock s2 = Stock(\u0026#34;Nifty\u0026#34;, 100, 20.5); s1.TopValue(s2); // this 포인터를 s1 객체의 주소로 설정하고, TopValue에서 그 포인터를 사용할 수 있게 한다. 객체 배열 표준 데이터형의 배열을 선언하는 것과 동일한 방법으로 선언한다. 1 2 3 4 5 6 7 Stock myStocks1 [4]; // 배열 각 원소 마다 디폴트 생성자가 호출된다. Stock myStocks2 [4] = { Stock(\u0026#34;NanoSmart\u0026#34;, 12, 20), Stock(\u0026#34;Boffo\u0026#34;, 200, 2.0), Stock(\u0026#34;Monolithic\u0026#34;, 130, 3.27), Stock(\u0026#34;Fleep\u0026#34;, 60, 6.5) }; 클래스 사용 범위 C++ 클래스는 전역 사용 범위와 지역 사용 범위와 다르게 클래스 사용 범위라는 새로운 종류의 사용 범위를 가지고 있다. 클래스 사용 범위를 갖는 것들은 클래스 안에는 알려지지만 클래스 바깥에는 알려지지 않는다.\n그렇다면 클래스 사용 범위를 가지는 기호 상수는 어떻게 만들 수 있을까?\n1 2 3 4 5 6 7 class Stock { private: const int Months = 12; double costs[Months]; // (X) //… }; 클래스를 선언하는 것은 객체가 어떻게 생겼는지 서술하는 것이지, 그 객체를 생성하는 것은 아니다. 따라서 값을 저장할 기억 공간은 객체가 생성될 때까지 마련되지 않는다. 그렇기 때문에 위의 예제는 실패한다. 이러한 문제의 해결 방안은 두 가지가 있다. 클래스 안에 열거체를 선언한다. 단, 각 객체는 그 안에 열거체를 담지 않는다. 컴파일 할 때 클래스 사용 범위에 있는 코드에서 기호이름 Months가 발견되면, 컴파일러는 그것을 단순히 12로 대체할 뿐이다. static 키워드를 사용하여 정적 클래스 멤버를 선언한다. 그래서 해당 클래스의 모든 객체들이 하나의 상수를 공유한다. 1 2 3 4 5 6 7 8 9 class Stock { private: enum { Months = 12 }; // 방법 1 static const int Months = 12; // 방법 2 double costs[Months]; // (O) //… }; 범위가 정해진 열거 (C++11) 전통적인 열거 방식은 다음과 같은 경우 충돌한다는 문제점을 안고 있다. 1 2 enum Egg { Small, Medium, Large }; enum Shirts { Small, Medium, Large }; 따라서 class 키워드를 사용해서 열거자에게 클래스 사용 범위를 갖게 함으로써 해결할 수 있다. 이 경우 열거자를 사용하려면 이름을 사용해야 한다. 그러나 이 경우 int형으로의 암시적 변환이 이루어지지 않는다. 1 2 3 4 5 6 7 8 enum class Egg { Small, Medium, Large }; // class 키워드 사용 enum class Shirts { Small, Medium, Large }; Egg e = Egg::Large; // 사용하려면 열거자 이름을 사용해야 함 Shirts s = Shirts::Large; int number1 = e; // (X) int형으로의 암시적 변환 불가능 int number2 = int(e); // (O) 명시적 변환은 가능 범위가 정해진 열거의 내재적 형태는 int형이다. 이것을 선택적으로 바꿀 수도 있다. 1 enum class : short Pizza { Small, Medium, Large }; // : short 는 기본형이 short형임을 의미한다. ","date":"2022-03-16T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-10/","title":"[C++ Primer Plus] Chapter 10. 객체와 클래스"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n분할 컴파일 형식 설명 #include \u0026lt; ... \u0026gt; 컴파일러가 표준 헤더 파일이 들어 있는 호스트 시스템의 파일 시스템 영역에서 찾는다. #include \u0026quot; ... \u0026quot; 컴파일러가 현재 작업 디렉토리나 소스 코드 디렉토리에서 찾는다. 그곳에서 찾지 못하면 표준 위치에서 찾는다. 따라서 사용자가 만든 헤더 파일을 포함할 때는 큰 따옴표를 사용해야 한다. 서로 다른 컴파일러는 하나의 동일한 함수에 대해 다르게 장식한 이름을 만들어 낸다. 따라서 컴파일 된 모듈을 링크시켜야 할 때는 각각의 목적파일이나 라이브러리들이 같은 컴파일러로 만들어진 것인 것 반드시 확인해야 한다. 헤더 파일은 단 한 번만 포함시켜야 하므로 다음과 같이 중복을 방지할 수 있다. 1 2 3 4 5 6 #ifndef MYHEADER_H_ #def MYHEADER_H_ // ... #endif 기억 존속 시간 (storage duration) C++은 네 가지 유형으로 데이터를 저장한다. 이 네 가지 유형은 메모리에 데이터를 존속시키는 시간에서 차이가 난다. 유형 설명 자동 기억 존속 시간 (automatic) 함수 정의 안에 선언된 변수. 함수 안에서만 유효하다. 정적 기억 존속 시간 (static) 함수 바깥에서 선언된 변수, 혹은 static 키워드로 선언된 변수. 프로그램 실행 중에 유효하다. 쓰레드 존속 시간 (Theard) 여러 작업을 동시에 실행할 수 있는 CPU(멀티코어 프로세서)를 사용해서 연산 작업을 쓰레드 단위로 쪼개서 처리한다. 동적 기억 존속 시간 (dynamic) new를 통해 할당되고, delete를 통해 해제된다. 사용범위 (scope) 어떤 이름이 하나의 파일(번역 단위) 안에서 얼마나 널리 알려지는가를 의미한다. 유형 설명 지역 사용범위 = 블록 사용범위 (local) 그 변수를 정의한 블록 안에만 알려진다. 전역 사용범위 = 파일 사용범위 (global) 파일 전체에 알려진다. 함수 원형 사용 범위 함수 안에서만 알려진다. 클래스 사용 범위 클래스 안에서만 알려진다. 이름 공간 사용 범위 이름 공간 안에서만 알려진다. 링크 (linkage) 서로 다른 파일(번역 단위)들이 이름을 공유하는 것을 말한다. 유형 설명 외부 링크 (external) 여러 파일들이 이름을 공유할 수 있다. 내부 링크 (internal) 한 파일 안에서 이름을 공유할 수 있다. 링크 없음 한 블록 안에서만 이름을 공유할 수 있다. 네 가지 종류의 변수들 분류1 분류2 기억존속시간 사용 범위 링크 선언 방법 자동 변수 지역 변수 (local) 자동 지역 없음 블록 안에서 선언 정적 변수 외부 변수 전역 변수 (global) 정적 전역 외부 어떤 블록에도 속하지 않는 바깥에 선언 정적 변수 정적 전역 내부 어떤 블록에도 속하지 않는 바깥에 선언 + static 키워드 정적 변수 정적 지역 없음 블록 안에서 선언 + static 키워드 1. 자동 변수\n블록 안에서 선언된 변수이다. auto 키워드는 자동 변수에만 사용할 수 있다. register 키워드는 C++11이전에 레지스터를 사용해서 자동 변수를 저장함으로써 좀 더 빠르게 접근하게 만들기 위해서 나온 것이었다. 스택과 두개의 포인터를 사용해서 관리된다. 포인터 중 하나는 스택의 시작점인 바닥을, 하나는 스택의 다음 메모리 저장위치인 꼭대기를 가리킨다. 함수가 호출되었다가 종료되면 꼭대기를 가리키는 포인터가 이전 위치를 지시한다. 값들은 지워지지 않는다. 2. 정적 변수\n정적 변수를 명시적으로 초기화하지 않으면, 컴파일러가 자동으로 0으로 초기화한다. 2-1. 전역 변수\n어떤 블록에도 속하지 않는 바깥에 선언 여러 파일에서 똑같은 이름의 전역 변수를 사용한다면 extern 키워드를 넣어준다. 1 2 // 파일 1에서 전역 변수 num을 선언한다. extern을 생략해도 된다. extern int num = 20; 1 2 3 4 5 6 7 8 9 10 11 12 13 // 파일 2에서 전역 변수 num을 사용하기 위해 extern 키워드를 사용한다. extern int num; void Global() { extern int num; // 함수 안에서 선택적으로 재선언해서 전역 변수를 사용 할 수도 있다. } void Local() { int num = 10; // 지역 변수가 전역 변수를 가린다. cout \u0026lt;\u0026lt; ::num; // 전역 변수 사용을 위한 사용 범위 결정 연산자 :: } 2-2. 내부 링크 정적 변수\n어떤 블록에도 속하지 않는 바깥에 선언 + static 키워드 서로 다른 파일에서 같은 이름으로 각각 다른 변수를 만들 수 있다. 1 2 // 파일 1에서 전역 변수를 선언한다. int num = 10; 1 2 // 파일 2에서 내부 링크를 가진 정적 변수를 선언한다. 이 파일에서만 쓰는 또 다른 변수이다. static int num = 14; 2-3. 링크 없음 정적 변수\n블록 안에서 선언 + static 키워드 프로그램이 시작할 때 한번만 초기화 된다. 함수가 호출될 때 누적되는 값으로 사용할 수 있다. 1 2 3 4 5 6 void Function() { // 블록 안에서 링크가 없는 정적 변수를 선언한다. static total = 0; total += 1; } CV-제한자 const 메모리가 초기화 된 후에는 프로그램이 그 메모리를 변경할 수 없다. 특이한 점은, const 전역변수는 외부링크가 아니라 내부링크가 디폴트라는 점이다. 따라서 외부링크인 const 전역변수를 만들고 싶으면 extern 키워드를 사용한다. 1 2 // 파일 1에서 const 전역변수를 extern 키워드를 사용해서 선언한다. extern const int states = 10; 1 2 // 파일 2에서 states을 사용하기 위해서 extern 키워드를 사용한다. extern const int states; volatile 외부적인 요인으로 그 변수의 값이 언제든지 바뀔 수 있음을 뜻한다. 컴파일러의 최적화를 막아서 레지스터에 로드된 값을 사용하지 않고 매번 메모리를 참조하게 만든다. 같은 변수를 여러 번 대입하면 마지막 대입만 의미 있다. 따라서 컴파일러는 나머지 앞의 불필요한 구문을 누락시킴으로써 최적화한다. volatile 제한자는 이러한 최적화를 막는다. 기억 공간 제한자 auto (C++11에서는 의미 변경) 1 2 auto int a = 3; // (X) auto는 더 이상 자동 변수라는 의미의 선언이 아니다. auto b = 3; // (O) auto는 자동 형변환에 사용한다. register (C++11에서는 의미 변경) 변수를 RAM이 아니라, 가능한 Register에 저장하도록 요청한다. C++11에서는 단순히 자동 변수임을 명시하는 방법이다. static 바깥에 선언하면 내부 링크, 블록 안에 선언하면 링크 없음. extern 다른 파일에 존재하는 전역변수를 사용할 수 있게 한다. thread_local (C++11에서 추가됨) thread_local 키워드로 선언한 변수는 그 존속 시간이 변수를 포함하는 쓰레드의 존속 시간이 된다. mutable 특정 구조체나 클래스가 const로 선언되어 있더라도 그 안의 특정 멤버를 변경할 수 있음을 나타낸다. 함수 정적 기억 존속 시간, 외부 링크\nstatic 키워드로 내부 링크를 부여할 수 있다. 이것은 함수의 사용 범위를 파일 하나로 제한한다.\n1 2 3 4 // static 키워드로 내부 링크를 가진 함수를 만든다. static void Function(); // 함수 원형 static void Function() {} // 함수 정의 함수는 모두 하나의 정의만을 가진다. 하지만 인라인 함수는 각각의 파일에서 모두 인라인함수의 정의를 가진다. 언어 링크 각 언어의 컴파일러는 각기 다른 방식으로 함수들의 이름을 장식한다.\n만약 C++프로그램에서 C 라이브러리의 미리 컴파일된 함수를 사용하고 싶다면, 사용할 프로토콜을 알려주는 함수 원형을 사용할 수 있다.\n1 extern \u0026#34;C\u0026#34; void Function(int); 동적 메모리 동적메모리는 사용 범위나 링크 규칙이 아닌, new와 delete에 의해 관리된다. 1 int * ptr = new int; 4바이트의 메모리가 new에 의해 대입된다. delete에 의해 해제될 때까지 메모리에 유지된다. 반면 ptr은 선언된 함수가 종료될 때 사라진다. new 연산자를 이용한 초기화 1 2 3 int * ptr = new int (10); int * ptr = new int {10}; int * ptr = new int[5] {10, 11, 12, 13, 14}; new는 필요한 메모리 양을 확보할 수 없는 경우 std::bad_alloc 예외를 반환한다. 위치 지정 new 사용할 메모리를 프로그래머가 지정할 수 있는 new이다. 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;new\u0026gt; struct StructSample { // ... }; char buffer[50]; // 정적 메모리인 buffer를 사용한다. delete는 안 한다. StructSample * ptr = new (buffer) StructSample; 이름 공간 새로운 종류의 선언영역을 정의하는 것이다.\n전역위치나 다른 이름 공간 안에 놓일 수 있다. 하지만 블록 안에는 놓일 수 없다.\n기본적으로 외부 링크를 가진다.\n1 2 3 4 5 6 7 namespace Jack { int jackNum = 10; int isJackHome = false; } Jack::jackNum = 20; // 사용 범위 결정 연산자 ::를 사용해서 이름공간 안에 이름을 접근한다. using 선언과 using 지시자 using 선언 using 선언으로 특정 이름을 선언된 영역에 추가할 수 있다. 1 2 3 4 5 using Jack::jackNum; // using 선언 jackNum = 20; int jackNum = 10; // (X) using 지시자 using 선언이 하나의 이름만을 사용할 수 있게 만든다면, using 지시자는 모든 이름을 사용할 수 있게 만든다. using 선언은 그 위치에 그 이름을 선언하는 것이라면, using 지시자는 해당 범위에 namespace를 넣는 것이다. 따라서 똑같은 이름을 이후에 재선언했을 때 그 전에 using 선언을 했다면 에러가 나지만, using 지시자의 경우에는 namespace의 변수를 가리기만 한다. 따라서 일반적으로 using 선언이 좀 더 안전하다. 1 2 3 4 5 6 using namespace Jack; // using 지시자 jackNum = 20; isTrue = true; int jackNum = 10; // (O) 이름공간의 대용이름 1 2 3 4 5 namespace J = Jack; // 이렇게 대용이름을 만들 수도 있다. using J::jackNum; jackNum = 20; 명명하지 않은 이름공간 다른 파일에서 사용할 수 없다. 마치 내부링크를 가진 정적변수와 같다. 1 2 3 4 namespace // static int count;와 같다. { int count; }; ","date":"2022-03-10T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-09/","title":"[C++ Primer Plus] Chapter 9. 메모리 모델과 이름공간"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n참조 변수 실제 변수의 대용이름. 함수의 매개변수에 사용한다. 포인터와 달리 초기화로만 참조를 설정할 수 있다. 참조 매개변수가 const일 경우 다음 조건일 때 임시변수가 생성된다. 그래서 원본 데이터가 변하지 않는다. (1) 올바른 데이터형이지만 lvalue가 아닐 때 (2) 잘못된 데이터형이지만 올바른 데이터형으로 변환할 수 있을 때 1 2 3 4 5 6 7 8 9 10 11 double RefCube( const double \u0026amp; ref ) { return ref * ref * ref; } double dNum = 5.0; long lNum = 5L; RefCube( lNum ); // 2 RefCube( dNum + 5.0 ); // 1 RefCube( 7.0 ); // 1 rvalue 참조는 \u0026amp;\u0026amp;를 사용한다. lvalue는 단일 표현식 이후에도 없어지지 않고 지속되는 객체이다. rvalue는 표현식 종료 이후에는 더 이상 존재하지 않는 암시적인 값이다. rvalue 참조는 Chapter 18에 나올 move semantics에 쓰인다. 1 2 3 double \u0026amp;\u0026amp; rref1 = 13.0; // 리터럴 상수 double \u0026amp;\u0026amp; rref2 = 2.0 + dNum; // 표현식 double \u0026amp;\u0026amp; rref3 = sqrt(2.0); // rvalue를 반환하는 함수 매개변수에 const 사용이 좋은 이유 실수로 데이터형 변경을 막을 수 있다. const와 const가 아닌 매개변수를 모두 처리할 수 있다. 참조로 매개변수가 전달되면 임시변수를 생성해서 사용할 수 있다. 구조체 참조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct Student { //... } Student\u0026amp; Func(Student\u0026amp; s) { //... } Student s1, s2; // 대입 구문으로 값이 복사된다. s1 = Func(s2); // 만약 Func 함수의 리턴값이 const이면 안 되는 구문이다. // 리턴 값이 const이면 상수 참조이기 때문이다. Func(s2) = s1; 구조체를 참조로 리턴하는 경우 전체 구조체를 임시 장소에 복사한 후 다시 복사하는 과정이 없고, 직접적으로 복사되기 때문에 보다 효율적이다. 함수가 종료될 때 수명이 끝나는 임시 변수를 참조로 리턴하지 않도록 주의해야 한다. 해결 방안은 매개변수로 전달된 참조를 리턴하거나, 포인터를 사용하는 방법이 있다. 1 2 3 4 5 6 7 8 9 10 11 12 struct Student { //... } const Student\u0026amp; Func(Student\u0026amp; s) { Student *ptr = new Student; // delete를 까먹을 수 있다. (unique_ptr이 괜찮은 대안이다) *ptr = s; return *ptr; // 포인터를 사용해서 구조체를 참조로 리턴한다. } string 객체 참조 매개변수에 C 스타일 문자열 매개변수 전달하기 string 클래스가 char *형을 string으로 변환한다. const 참조 형식의 매개변수라면 임시 변수를 만들게 된다. 1 2 3 4 5 6 void Func(string str) // str과 “Hello”는 서로 주소가 다르다. { //... } Func(\u0026#34;Hello\u0026#34;); 객체의 상속과 참조 ostream을 상속받는 ofstream형 객체들은 ostream \u0026amp; 참조형으로 받을 수가 있다. 1 2 3 4 5 6 ios_base::fmtflags initial; initial = cout.setf(ios_base::fixed); // 고정소수점 표기. 바꾸기 전 포맷팅 설정을 리턴한다. cout.precision(1); // 소수점 이하 숫자 개수 cout.setf(ios::showpoint); // 0이더라도 소수점 표시 cout.width(17); // 필드 폭 설정 ( 한번 출력 후 초기화됨) cout.setf(initial); // 이전 포맷팅 설정 복원 참조 매개변수를 사용하는 이유 전달되는 데이터 객체의 변경을 위해 객체 대신 참조를 전달해서 속도를 높이기 위해 매개변수가 배열이라면 참조 매개변수는 배열의 크기를 구체적으로 명시해야 하므로, 포인터가 유일한 대안이겠다. 디폴트 매개변수 함수의 원형에 명시한다. 어떤 매개변수를 디폴트 매개변수로 만들려면, 그 오른쪽에 있는 모든 매개변수를 디폴트 매개변수로 만들어야 한다. 1 2 3 4 5 6 void Func(int one, int two = 2, int three = 3) { //... } Func (1, ,3); // (X) 매개변수를 건너뛸 수는 없다. 함수 오버로딩 (함수의 다형) 서로 다른 여러 개의 함수가 하나의 이름을 공유하는 것. 함수를 호출하면 매개변수 리스트(= 함수 시그내처)에 따라 알맞은 시그내처를 가진 함수원형을 찾아준다. 리턴형이 달라도, 시그내처가 같으면 오버로딩이 불가능하다. 반면, 시그내처가 다르면 다른 리턴형을 가질 수 있다. 함수 오버로딩이 되어서 여러 개의 함수가 존재하는데, 알맞은 시그내처가 없을 경우 컴파일 에러가 난다. 1 2 3 4 5 6 7 8 9 10 11 12 void Solution (int num) { //... } void Solution (float num) { //... } double test = 5.0; Solution(test); // double형 매개변수를 가진 시그내처가 없으므로 컴파일 에러 데이터형과 그 참조는 서로 같은 것으로 친다. const와 const가 아닌 변수는 구별된다. 이름장식 컴파일러는 오버로딩된 함수들의 이름을 알아보기 어려운 내부 형식으로 변환하여 암호화한다. 이것으로 서로 구분한다. 오버로딩 참조 매개변수 변경가능 lvalue ( x ) const lvalue ( 1 ) rvalue ( x + y ) void Solution ( int \u0026amp; num ); O X X void Solution ( const int \u0026amp; num ); O O O void Solution ( int \u0026amp;\u0026amp; num ); X X O 함수 템플릿 1 2 3 4 5 6 7 8 9 10 // 함수 템플릿 원형. class 대신 typename을 사용해도 된다. template \u0026lt;class T\u0026gt; void Swap (T \u0026amp; a, T \u0026amp; b); // 함수 템플릿 정의 template \u0026lt;class T\u0026gt; void Swap (T \u0026amp; a, T \u0026amp; b) { //... } 함수 템플릿의 제한 1 2 3 4 5 template \u0026lt;typename T\u0026gt; int Add(T a, T b) { return a + b; } 이경우 T가 struct라면 작동하지 않는다. 대안은\u0026hellip;? 연산자를 오버로드한다. 특별한 형에 대하여 특화된 템플릿을 정의한다. (명시적 특수화) 명시적 특수화 다른 Swap() 템플릿을 사용하지 말고, 주어진 형에 맞게 특별히 명시적으로 정의된 이 함수 정의를 사용해라. 조건 매개변수 동일 반환형 동일 앞에 template \u0026lt;\u0026gt; 붙이기 1 2 3 4 5 6 7 8 9 10 struct Student { //... } // \u0026lt;Student\u0026gt;에서 Student 생략가능. template \u0026lt;\u0026gt; void Swap\u0026lt;Student\u0026gt;(Student \u0026amp; s1, Student \u0026amp; s2) { //... } 암시적 구체화, 명시적 구체화 구체화: 컴파일러가 특정 데이터형에 맞는 함수 정의를 생성하기 위해 템플릿을 사용한 결과.\nSwap() 템플릿을 사용해서, 주어진 형에 맞는 함수 정의를 생성해라.\n암시적 구체화: 컴파일러에게 암시적으로 Swap() 템플릿을 사용해서, x, y 형에 맞는 함수 정의를 생성하라고 알린다.\n명시적 구체화: 컴파일러에게 명시적으로 Swap() 템플릿을 사용해서, int 형에 맞는 함수 정의를 생성하라고 알린다.\n1 2 3 4 5 6 // 암시적 구체화 Swap(x, y); // 명시적 구체화 template void Swap\u0026lt;int\u0026gt; (int, int); Swap\u0026lt;int\u0026gt; (x, y); 컴파일러는 어떤 함수를 선택할까? 순서 일반 함수 \u0026gt; 명시적 특수화 \u0026gt; 일반 템플릿 가능한 함수가 둘 이상이면 모호하기 때문에 에러가 발생한다. 사용자가 컴파일러에게 적절한 함수를 사용하도록 리드할 수 있다. 1 2 Swap\u0026lt;\u0026gt;(x, y); // \u0026lt;\u0026gt;는 템플릿 함수를 선택해야한다는 것을 의미한다. Swap\u0026lt;int\u0026gt;(x, y); decltype 키워드 declared type의 줄임말이다. 특정 인스턴스가 생성되기 전까지 타입을 결정할 수 없을 때 템플릿을 정의하는 데 사용하는 특별한 방법이다. 내부 괄호로 한번 더 묶으면 그 안의 표현식을 lvalue참조로 본다. 1 2 3 4 5 6 7 8 int x = 1, y = 2; decltype (x + y) xpy; // x+y과 동일한 타입의 xpy를 만들어라 xpy = x + y; decltype (x + y) xpy = x + y; // 위와 같은 구문 decltype ((x)) xr = x; // int \u0026amp; 타입 1 2 3 4 5 template\u0026lt;class T1, class T2\u0026gt; auto Solution(T1 x, T2 y) -\u0026gt; decltype(x + y) // 적절한 x + y의 리턴형을 선언할 수 있다. { return x + y; } ","date":"2022-03-09T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-08/","title":"[C++ Primer Plus] Chapter 8. 함수의 활용"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n함수 1 2 3 4 5 6 7 8 double Solution(int); // 원형 Solution(num); // 호출 double Solution(int num) // 정의 { return num * 3.0f } 함수의 원형이 필요한 이유 함수의 원형은 컴파일러에게 함수의 인터페이스를 알려준다. 즉, 리턴값과 매개변수의 데이터형을 알려준다. 함수는 자신의 리턴값을 CPU의 지정된 레지스터/메모리에 복사한다. 어떤 형의 값인지는 자신의 정의를 본다. 호출한 함수가 그 위치에서 값을 꺼내온다. 함수 원형을 보면 리턴값이 뭔지 알 수 있으므로 컴파일러는 그 위치에서 몇 바이트를 꺼내야 하는 지 알고 있다. 함수 원형의 매개변수 1 2 3 4 5 6 7 8 double Solution(int); // 매개변수 이름을 생략해도 된다. double Solution(...); // 매개변수 리스트가 무엇인지 확인하지 않겠다는 뜻이다. double Solution(int x); Solution(5); // 5 = 실제 매개변수 = 함수에 전달되는 값 = argument // x = 형식 매개변수 = 전달되는 값을 넘겨받는데 쓰는 변수 = parameter // 매개변수란 argument가 parameter에 대입되는 것이다. 배열 매개변수 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int nums [3] = {1, 2, 3}; Solution(nums, 3); void Solution(int arr [] , int size); void Solution(int * arr , int size); // 같은 의미이다. // 이렇게 할 수도 있다. Solution(nums, nums + 3); void Solution(int * begin, int * end) cout \u0026lt;\u0026lt; sizeof(nums) \u0026lt;\u0026lt; endl; // 12. 배열 전체의 크기. cout \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; // 4. 포인터 변수의 크기. // 따라서 매개변수로 배열의 크기를 넘겨주려면 따로 추가적인 매개변수가 필요하다. // 배열의 값을 변경하는 걸 원하지 않으면 const로 선언해준다. void Solution(const int arr []); 포인터와 const 표기 ptr = \u0026amp;other; *ptr = 3; 의미 const int * ptr O X ptr을 이용해서 num의 값 변경 불가. int * const ptr X O ptr이 가리키는 값을 변경 불가. 1 2 3 4 5 6 7 8 int num1 = 5; const int * ptr = \u0026amp;num1; // 만약 num이 const라면 ptr은 무조건 const여야 한다. int num2 = 3; ptr = \u0026amp;num2 // (O) ptr에 새로운 val이라는 값을 가리키게 할 수는 있다. *ptr = 3; // (X) 하지만 ptr을 이용해서 그 값 자체를 바꿀 수는 없다. 1 2 3 4 5 6 7 8 int num1 = 5; int * const ptr = \u0026amp;num1; *ptr = 3; // (O) num의 값을 변경할 수는 있다. int num2 = 3; ptr = \u0026amp;num2; // (X) 하지만 ptr을 이용해서 다른 값을 가리키게 할 수는 없다. 2차원 배열 매개변수의 전달 배열 포인터 1 2 3 // 포인터다. 4개의 int형 원소들을 가지고 있는 배열을 지시하는 포인터다. int (*arr) [4]; int arr[][4]; 포인터 배열 1 2 // 배열이다. 4개의 int형 포인터들을 가지고 있는 배열이다. int *arr [4]; arr[3][4] == *(*(arr + 3) + 4) arr[3] == *(arr + 3) 4개의 원소를 가지고 있는 3번째 행 배열의 이름이다. (sizeof(arr[3])하면 16바이트) C스타일 문자열의 전달 1 2 3 4 5 6 7 void Solution(const char * str); // 문자열은 마지막이 널문자이므로 배열 크기를 넘길 필요가 없다. char name[4] = \u0026#34;Kim\u0026#34;; Solution(name); char * nik = \u0026#34;KeKe\u0026#34;; Solution(nik); 구조체, string의 전달 일반 변수처럼 값으로 전달된다. array 객체의 전달 1 2 3 4 5 6 7 8 9 10 11 12 std::array\u0026lt;double, 4\u0026gt; expenses; Solution(expenses); void Solution(std::array\u0026lt;double, 4\u0026gt; * exp) { cout \u0026lt;\u0026lt; (*exp)[0] \u0026lt;\u0026lt; endl; } // exp는 포인터다. // *exp는 객체이다. // (*exp)[0] 은 그 객체에 있는 원소이다. 함수 포인터의 전달 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 double Function(int num); // pf는 함수를 지시하는 포인터, *pf는 함수 자체. // 함수 포인터 void Solution(double (*pf) (int)) { double result = pf(5); // (*pf)(5) } // 함수 포인터들의 배열 void Solution(double (*pf [3]) (int)) { double result = pf[0](5); // (*pf[0])(5) } // 함수 포인터의 포인터 void Solution(double (**pf) (int)) { double result = pf[0](5); // (*pf[0])(5) } // 함수 포인터들의 배열의 포인터 void Solution(double (*(*pf) [3]) (int)) { double result = (*pf)[0](5); // (*(*pf)[0])(5) } // pf를 함수 포인터형으로 쓸 수 있다. typedef double (*pf) (int); pf function = f1; ","date":"2022-03-08T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-07/","title":"[C++ Primer Plus] Chapter 7. 함수"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n연산자 우선순위 연산자 결합규칙 :: (괄호묶기, 함수호출, 값 생성) [] . -\u0026gt; ++ -- const_cast dynamic_cast reinterpret_cast static_cast typeid → ! ~ + - ++ -- \u0026amp; * (형변환) sizeof alignof new delete noexcept ← .* -\u0026gt;* → * / % → + - → \u0026lt;\u0026lt; \u0026gt;\u0026gt; → \u0026lt; \u0026lt;= \u0026gt;= \u0026gt; → == != → \u0026amp; → ^ → | → \u0026amp;\u0026amp; → || → :? ← = *= /= %= += -= \u0026amp;= ^= != \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= ← throw → , → cctype 라이브러리 함수명 쓰임새 isalpha 영문자인가? isdigit 숫자인가? tolower 소문자로 toupper 대문자로 switch 구문 case 레이블은 그 값이 int형이어야 한다. (enum 가능) 많은 구현체들이 switch문을 jump table로 구현하기 때문에 if else보다 실행 속도면에서 효율적이다. 보통 if문이 3개일때까지는 if else문이 빠르고 그 이상은 switch문이 빠르다. 하지만 그 속도 차이가 미미해서 가독성을 더 고려하는 것이 좋겠다. 루프로 읽기 1 2 int n; cin \u0026gt;\u0026gt; n; 여기서 수 대신 문자를 입력하면 벌어지는 일\n(1) n의 값은 변하지 않는다. (2) 입력 큐에 잘못된 입력이 그대로 유지된다. (3) cin 객체에 에러 플래그가 설정된다. (4) cin 메서드 호출이 false(bool형으로 변환된다면)를 리턴한다. 따라서 다시 입력을 재개하려면\n(1) cin을 초기화한다. (2) 불량입력을 제거한다. 1 2 3 4 5 while (!(cin \u0026gt;\u0026gt; golf[i])) // 제대로 입력하면 종료 하고 아니면 다시 입력 재개 { cin.clear(); while( cin.get() != \u0026#39;\\n\u0026#39; ) continue; } 텍스트 파일 쓰고 읽기 쓰기 1 2 3 4 5 6 7 8 9 #include \u0026lt;fstream\u0026gt; ofstream outFile; outFile.open(\u0026#34;text.txt\u0026#34;); outFile \u0026lt;\u0026lt; \u0026#34;안녕\u0026#34;; outFile.close(); 읽기 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;fstream\u0026gt; ifstream inFile; inFile.open(\u0026#34;text.txt\u0026#34;); if (!inFile.isopen) exit(EXIT_FAILURE); if (inFile.good()) inFile \u0026gt;\u0026gt; str; inFile.close(); open() 을 하면 새 파일을 만든다. 기존 파일이 존재하면 내용이 모두 지운다. inFile.eof() 는 파일의 끝에 도달하면 true inFile.fail() 은 데이터형 불일치나 파일의 끝에 도달하면 true inFile.bad() 는 파일이 깨지거나 하드웨어 실패하면 true inFile.good() 은 잘못된 것이 하나도 없으면 true ","date":"2022-03-07T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-06/","title":"[C++ Primer Plus] Chapter 6. 분기 구문과 논리 연산자"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n표현식 대입 표현식은 값을 가지기 때문에 이런 구문도 가능하다. 1 x = y = z = 0; 표현식에 세미콜론을 붙이면 구문이 된다. statement = expression + semicolon 시퀀스 포인트 (Sequence Point) 시퀀스 포인트란 프로그램의 실행이 다음 단계로 넘어가기 전에, 모든 부수 효과(변수 값 변경 등)들이 확실하게 평가되는 포인트이다. 예를 들면 세미콜론, 완전 수식(while문의 조건문)의 끝, || 연산자 등은 시퀀스 포인트이다. 따라서 아래 예제에서는 시퀀스 포인트에서 다음 명령을 실행하기 전에 증가 연산자로 인해 값이 증가한다. 1 2 3 4 5 6 7 int point = 1; point++; // 여기 while(point++ \u0026lt; 10) // 여기 { //… } 접두어와 접미어 방식 내장 데이터형의 경우에는 둘 다 결과적으로 동일한 결과를 가져온다. 하지만 클래스와 같이 사용자 정의 데이터형인 경우에는 접두어 방식이 효율적이다. 왜냐하면 접미어 방식은 복사본을 만들어서 값을 증가시키고 복사본을 리턴하는 방식으로 동작하기 때문이다. 포인터와 증가/감소 연산자 표기 설명 *++pt 오른쪽부터 왼쪽으로 결합하므로, ++pt는 주소 증가, 그 후 *(++pt)는 값 출력. ++*pt *pt는 값이므로, ++(*pt)는 값이 증가. (*pt)++ *pt는 값이므로, (*pt)++는 다음 단계로 넘어가면서 값이 증가. *pt++ pt++는 주소 증가지만 다음 단계로 넘어갈 때 증가. *(pt++)는 현재 주소의 값 출력. 그 후 다음 단계로 넘어가면서 주소 증가. 콤마 연산자로 두 개의 표현식 넣기 1 2 3 4 5 // temp를 사용해서 i인덱스와 j인덱스에 해당하는 값을 교환하여 거꾸로 만들기 int i, j, temp; for (i = 0, j = size - 1; i \u0026lt; j; i++, j--) // ...\ttemp가 바깥에 선언되었다. 매 주기마다 새로 대입하고 해제되지 않아도 돼서 좋다. i, j가 바깥에 선언되었다. int i = 0, j = size - 1에서 콤마는 연산자가 아닌 분리자가 된다. 그래서 for 제어문 안에서 선언할 수 없다. 문자열 비교 C스타일 strcmp()를 사용한다. 같으면 0, 첫문자가 앞순서면 -1, 뒷순서면 1을 리턴 대문자가 소문자보다 앞이다. 1 2 3 char word[5] = \u0026#34;word\u0026#34;; if (strcmp(word, \u0026#34;mate\u0026#34;) == 0) //... string 관계 연산자를 사용한다. 1 2 3 string word = \u0026#34;word\u0026#34;; if (word == \u0026#34;mate\u0026#34;) //... 시간지연 루프 프로세스 성능에 따라 1초에 반복되는 루프문의 수가 달라질 수 있다. 그래서 똑같은 시간을 재기 위해서는 클록 수를 카운트한다. clock() 프로그램 실행 순간부터 이 함수가 호출될 때 까지의 클록 수 CLOCK_PER_SEC 1초 당 클록 수 clock_t형 clock()의 리턴 데이터형이 시스템마다 달라질 수 있는데 그것을 모두 수용할 수 있는 데이터형이다. 1 2 3 4 clock_t delay = 10 * CLOCK_PER_SEC; // 10초 지연한다. clock_t start = clock(); while(clock() - start \u0026lt; delay) 루프와 텍스트 입력 cin \u0026gt;\u0026gt; ch\n빈칸, 탭, 개행을 무시하고 건너뛴다. 입력: Do you need# 출력: Doyouneed cin.get(ch);\n빈칸, 탭, 개행을 포함한다. 입력: Do you need# 출력: Do you need 운영 체제들이 리디렉션(표준 스트림을 사용자 지정 위치로 우회할 수 있는 것) 기능을 제공하기 때문에, 파일 입력 대신 키보드 입력을 바탕으로 프로그램을 실행할 수 있다. 키보드로 Ctrl + Z를 입력하면 EOF를 나타낼 수 있다. 1 2 3 4 5 // cin.get(ch)는 cin을 리턴하고. cin은 읽기가 성공하면 true를 리턴한다. while (cin.get(ch)) // cin.get()은 문자를 읽어서 리턴한다. 그 문자가 EOF이면 -1이겠다. while ((ch = cin.get()) != EOF) cin은 EOF(파일의 끝; End Of File; -1)를 탐지했을 때 eofbit와 failbit를 1로 설정한다. cin.eof()는 eofbit가 1이면 true를 리턴한다. cin.fail()는 eofbit 혹은 failbit이 1이면 true를 리턴한다. EOF가 설정되면 cin이 더 이상 입력을 받지 않는다. 따라서 다시 입력을 받으려면 cin.clear()를 해주어야 한다. ","date":"2022-03-05T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-05/","title":"[C++ Primer Plus] Chapter 5. 루프와 관계표현식"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n배열 배열을 선언할 때 원소의 개수는 다음 중에 하나여야 한다. 값 정수 상수 상수 수식 1 2 3 4 5 6 int values1[40]; // 1 const int length = 40; int values2[length]; // 2 int values3[10 * sizeof(int)]; // 3 생성과 동시에 초기화할 수 있다. 반면, 초기화를 나중에 할 수는 없다. 1 int arr[3] = {1, 2, 3}; 초기화할 때 처음 원소를 명시적으로 하면 나머지는 알아서 0이 된다. 1 int arr[3] = {0}; [] 속을 비우면 초기화 개수 대로 배열이 만들어진다. 배열의 원소 개수는 sizeof(arr) / sizeof(int) 로 구할 수 있다. 1 int arr[] = {1, 2, 3}; // 3개의 int형 데이터를 가진 배열로 만들어진다. 배열 초기화 시 = 가 없어도 된다. 중괄호 공백으로 0으로 다 초기화할 수 있다. 초기화 시 narrowing은 안 된다. 1 2 3 int arr[] {1, 2, 3, 4}; int arr[] {}; int arr[] {1, 2, 3.3333, 4}; // (X) 문자열 모든 문자열의 마지막 문자는 널 문자(\\0)여야 한다. 문자열 상수로 배열을 초기화할 때 널 문자까지 고려해야 한다. [] 속을 배우면 알아서 널 문자까지 고려 해 준다. 배열이 문자열 상수보다 더 크면 널 문자로 계속 채운다. 1 char arr[] = \u0026#34;Hello\u0026#34;; // 6개의 char형 데이터를 가진 배열로 만들어진다. ‘S’는 문자이다. \u0026quot;S\u0026quot;는 문자열이며 S문자와 널 문자가 합쳐진 두 개의 문자로 이루어진 문자열이다. 따라서 아래와 같은 것은 안 된다. 1 char keyword = \u0026#34;S\u0026#34;; (X) White space(빈칸, 탭, 캐리지리턴)로 분리된 두 개의 문자열 상수는 하나의 문자열 상수로 결합된다. 1 cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026#34;My friend\u0026#34;; // \u0026#34;Hello My friend\u0026#34; \u0026lt;cstring\u0026gt; 헤더 파일에 있는 strlen()함수는 배열의 전체 크기가 아니라 배열에 저장된 문자열의 크기를 리턴한다. 널 문자는 제외한다. 문자열 읽기 cin은 White Space를 문자열의 끝으로 간주한다. 그래서 중간에 White Space가 있는 문자열을 입력하면 White Space 전까지만 저장하고 그 이후 문자들은 입력 큐에 남겨 놓는다. 그러면 다음 cin에서는 사용자 입력을 받지 않고 입력 큐에 남아있던 문자들을 저장한다. 전체 한 줄의 문자열을 저장하기 위해서는\u0026hellip; cin.getline(배열이름, 배열크기) getline은 매개변수로 입력받은 (배열크기 – 1)크기를 넘어서거나, 개행 문자를 만나면 개행 문자를 널 문자로 교체하고 입력한 후 읽기를 종료한다. getline이 지정된 배열 크기를 넘어서는 문자를 입력받으면 나머지는 입력 큐에 남겨두고, failbit를 설정한다. cin.get(배열이름, 배열크기) get은 개행 문자를 입력 큐에 남겨둔다. 다음 입력이 개행 문자를 입력하는 것을 방지하기 위해 cin.get()을 사용해 문자 하나를 읽어버릴 수 있다. 아니면 cin.get(배열이름, 배열크기).get() 이렇게 할 수도 있다. get이 빈 행을 읽으면 failbit라는 것이 설정되어서 추가적은 입력을 막는다. 이것을 복원하려면 cin.clear()를 해주어야 한다. 함수 입력 버퍼남김 무엇을 읽으면 failbit? cin White Space 이전까지 개행 문자 cin.getline(배열이름, 크기) 개행까지 X (개행은 널로 대체) 초과 크기의 문자열 cin.get(배열이름, 크기) 개행까지 개행 문자 빈 행 1 2 3 4 5 if (cin.fail() == 1) { cin.clear(); // 내부 상태 플러그 초기화 cin.ignore(INT_MAX, \u0026#39;\\n\u0026#39;); // 해당 길이 만큼 or 개행 문자까지 읽어서 입력 버퍼를 비운다. } string 클래스 리스트 초기화가 가능하다. 1 2 char arr[] = {\u0026#34;Hello\u0026#34;}; string str = {\u0026#34;Hello\u0026#34;}; 문자배열 string 크기 선언만 하면 크기가 제각각이다. 이후에 cin으로 입력을 저장하면 지정된 크기 만큼만 저장된다. 선언만 하면 크기가 0이다. 이후에 cin으로 입력을 저장해도 자동으로 크기를 조절해 문자열을 넣는다. 대입과 추가 C라이브러리 \u0026lt;cstring\u0026gt;를 사용해서 strcpy(arr1, arr2)로 복사한다. strcat(arr1, arr2)로 덧붙인다. =로 대입한다. +, += 으로 덧붙인다. 길이구하기 길이는 strlen(arr) 로 구할 수 있다. 길이는 str.size() 로 구할 수 있다. 1 2 3 4 5 6 // 문자배열 cin.getline(arr, arrSize); // string // \u0026lt;istream\u0026gt;은 string형을 인식하지 못한다. getline(cin, str); 다른 형태의 문자열 상수 wchar_t, char16_t, char32_t L, u, U 접두사를 사용해서 문자열 상수로 초기화할 수 있다. 1 wchar_t arr[] = L\u0026#34;Hello\u0026#34;; 접두사 R을 붙여서 raw 문자열을 사용할 수도 있다. 구조체 여러 종류의 데이터를 모아서 하나의 단위로 묶어서 저장할 수 있다. 함수도 멤버로 가질 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Student { char name[20]; int age; }; Student s1 = { \u0026#34;KimKim\u0026#34;, 1 }; Student s2 {}; // =를 생략할 수도 있다, 0으로 모두 초기화. cout \u0026lt;\u0026lt; s1.age; struct // 데이터형 이름 없음. 구조체의 정의와 동시에 변수생성. { char name[20]; int age; } s1, s2; 구조체 배열 1 Student sArr[2] = { { \u0026#34;KimKim\u0026#34;, 1 }, { \u0026#34;SoSo\u0026#34;, 2 } }; 공용체 여러 종류의 데이터를 모아서 하나의 단위로 묶었지만, 하나의 데이터만 보관할 수 있다. 공용체의 크기 = 제일 큰 멤버의 크기 1 2 3 4 5 union OneForAll { int Num; char Name[20]; }; 열거체 0부터 순서대로 대입되며, 명시적으로 지정하면 기본값은 무시된다. 1 enum Color { Red, Orange, Yellow, Blue, Green, Purple }; int형으로 자동으로 승급될 수 있다. 1 int number = 3 + Red; 반대로 int형이 자동으로 enum형으로 되진 않는다. 1 Color c = Color (3); 대입연산자만 사용할 수 있고, 산술 연산자는 안 된다. 1 ++c; // (X) 주로 기호 상수들을 정의하는 용도로 사용되므로 이름을 생략할 수도 있다. 1 enum { Red, Orange, Yellow, Blue, Green, Purple }; 어떤 정수값이 열거체 값 범위 안에 들어있으면, 그 값이 열거자 값이 아니더라도, 데이터형 변환을 통해서 열거체 변수에 대입할 수 있다. 포인터 int * 이든 double *이든 그 크기는 같다. (컴퓨터 시스템에 따라 다름) 1 2 3 4 5 6 7 int number = 7; int * pointer = \u0026amp;number; // *pointer == number == number의 값 // pointer == \u0026amp;number == number의 주소값 int * ptr, num; // ptr은 포인터형으로 num은 int형으로 생성된다. 포인터에 직접 주소를 대입할 수 있다. 데이터형을 반드시 명시해야 한다. 1 int * number = (int *) 0xB8000000; new연산자로 런타임에 메모리 할당 (C의 malloc 대체) 1 int * ptr = new int; 여기서 ptr이 가리키고 있는 메모리의 이름(number같은 변수 이름)이 없다. 그냥 메모리 블록을 가리키고 있다. 그래서 ptr을 통해서만 메모리 접근이 가능하다. 컴퓨터 메모리가 부족해서 new의 메모리 할당 요청을 허용할 수 없으면 new는 0을 리턴한다. 이렇게 값이 0인 포인터는 널 포인터라고 부른다. 널 포인터는 무언가 일이 잘못되었다는 것을 나타낼 때 사용된다. delete 연산자로 메모리 해제 1 2 int * ptr = new int; delete ptr; 메모리 누수를 방지하기 위해 다 쓴 메모리는 delete 연산자를 사용해 메모리를 해제해 주어야한다. delete로 해제된 메모리를 또 다시 delete로 해제하면 안 된다. 보통의 변수로 대입한 메모리도 delete로 해제할 수 없다. 널 포인터를 delete하면 아무일도 일어나지 않는다 (안전하다) new를 사용해 생성한 동적 배열 (동적 바인딩) 1 2 int * ptr = new int [10]; delete [] ptr; *ptr이나 ptr[0]으로 배열의 첫번째 원소에 접근 가능 하다. ptr + 1을 하면 ptr이 가리키는 데이터형의 크기만큼 한 칸 뒤로 가서, ptr[0]은 두번째 원소인 ptr[1]을 가리키게 된다. 포인터와 배열 1 2 int numbers[3] = {1, 2, 3}; int * ptr = numbers; numbers == \u0026amp;numbers[0]\nnumbers 배열의 첫 번째 원소의 주소값 numbers != \u0026amp;numbers\n\u0026amp;numbers는 배열 전체의 주소값이다. 따라서 numbers + 1은 다음 원소의 주소값이지만, \u0026amp;numbers + 1을 하면 전체 배열을 넘어간 다음의 주소값이다. *numbers == numbers[0]\nnumbers 배열의 첫 번째 원소의 값 *(numbers + 1) == numbers[1]\nnumbers 배열의 두 번째 원소의 값 여기서 numbers 대신 ptr을 넣어도 똑같다. 다른점: (1) ptr은 값을 변경할 수 있지만 배열 이름인 numbers는 값을 변경할 수 없다. (2) sizeof(numbers)는 배열 전체의 크기이지만 sizeof(ptr)은 포인터의 크기이다. 포인터 배열과 배열 포인터 1 2 short * ptr [20];\t// short* 형 포인터가 20개 있는 배열 short (*ptr)[20];\t// short 형 자료가 20개 있는 배열을 가리키는 포인터 포인터와 문자열 배열의 이름, 포인터, 문자열 상수 모두 동등하게 첫번째 문자열의 주소를 나타낸다. 1 2 3 4 5 6 7 char arr[10] = \u0026#34;beautiful\u0026#34;; cout \u0026lt;\u0026lt; arr; char * ptr = \u0026#34;beautiful\u0026#34;; cout \u0026lt;\u0026lt; ptr; cout \u0026lt;\u0026lt; \u0026#34;beautiful\u0026#34; 문자열 상수나 초기화되지 않은 포인터를 문자열 입력에 절대 사용하지 않아야 한다. 포인터의 경우, 초기회되지 않았다면, 입력된 문자가 어디에 저장될지 알 수 없어진다. 1 2 3 4 5 const char * ptr1 = \u0026#34;notgood\u0026#34;; cin \u0026gt;\u0026gt; ptr1; char * ptr2; cin \u0026gt;\u0026gt; ptr2 //(X) strncpy(arr1, arr2, 최대 문자 수); 이것은 최대 문자수가 다 안 담기면 널 문자를 추가하지 않는다. 따라서 반드시 수기로 추가해야 한다. new를 사용한 동적 구조체 생성 연산자 형식 도트 멤버 연산자 [구조체의 이름.멤버], [(*포인터).멤버] 화살표 멤버 연산자 [구조체를 지시하는 포인터-\u0026gt;멤버] 1 2 3 4 5 6 7 8 9 10 11 12 13 struct Flower { char name[20]; double price; }; Flower * f = new Flower; cin.get(f-\u0026gt;name, 20); cin \u0026gt;\u0026gt; f-\u0026gt;price; cin \u0026gt;\u0026gt; (*f).price; delete f; 데이터 저장을 위한 메모리 공간의 종류 자동 공간(automatic) 변수들이 자신이 정의되어있는 함수가 호출되는 순간에 생겨나서, 함수가 종료되는 시점까지만 존재한다. (블록 안에서만 유효하다) 스택에 저장된다. 따라서 순차적으로 저장되고 역순으로 해제된다. 정적 공간(static) 프로그램이 실행되는 동안에 지속적으로 존재하는 공간이다. 함수 외부에서 변수를 정의하거나 static 키워드로 정의하면 된다. 1 static double fee = 56.5; 동적 공간(힙)(dynamic) new와 delete을 사용해서 동적으로 메모리를 할당하고 해제한다. 힙에 저장된다. 배열의 대안 vector 템플릿 클래스 string 클래스처럼 자동으로 런타임에 메모리가 할당/해제 된다. (힙) 1 2 3 4 vector\u0026lt;int\u0026gt; vec(10); // 10개 원소를 가진 int형 배열. // 10자리에 변수가능. // 자동으로 0으로 모두 초기화 됨. array 템플릿 클래스 크기가 고정되어 크기를 런타임에 바꿀 수 없다. (스택) 1 array\u0026lt;int, 10\u0026gt; arr; // 10자리에 변수 불가능. ","date":"2022-03-04T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-04/","title":"[C++ Primer Plus] Chapter 4. 복합 데이터형"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\n변수 이름 규칙 영문자, 숫자, 밑줄만 사용 가능 대문자와 소문자는 구별됨 첫 문자가 숫자일 수는 없음 C++의 키워드는 사용 못함 예약어는 사용 못함 길이 제한은 없음 비트와 바이트 비트 컴퓨터 메모리를 구성하는 기본 단위 바이트 8비트. C++에서는 컴파일러의 기본 문자 세트를 수용할 수 있는 최소한의 연속된 비트들로 구성한다. sizeof 연산자 데이터형의 크기를 바이트 단위로 리턴한다. climits 헤더파일 컴파일러에 알맞은 최대값들을 정의해놓은 헤더파일 (INT_MAX 등) 변수 초기화 문법 1 2 3 4 int var = 10; int var = {10}; int var {10}; int var (10); 진법 진법 조건 10진수 첫 숫자가 1~9 8진수 첫 숫자가 0이고 두번째 숫자가 1~7 16진수 첫 두 문자가 0x 혹은 0X 조정자 hex, oct를 사용하면 16진법, 8진법으로 출력가능 1 2 cout \u0026lt;\u0026lt; hex cout \u0026lt;\u0026lt; oct 정수형 상수의 데이터형을 결정하는 방법 접미어를 붙이면 해당 데이터형으로 10진 정수 int \u0026lt; long \u0026lt; long long형 중에서 크기가 작은 것으로 8진, 16진 정수 int, unsigned int \u0026lt; long, unsigned long \u0026lt; long long, unsigned long long 중에서 크기가 작은 것으로 문자 이스케이프 시퀀스(escape sequence)\n'\\n' \u0026quot;\\n\u0026quot; 개행은 정식 문자로 취급된다. 유니버셜 코드 네임(universal character names)\n\\u나 \\U 뒤에 16진수 숫자가 온다. 이 숫자들은 특정 문자에 해당하는 ISO10646코드를 나타낸다. 이것으로 어떤 문자도 영어가 아니어도 소스코드 안에 쓸 수 가 있다. char형을 수에 쓰려고 한다면 unsigned char와 signed char가 중요해진다. 하지만 문자라면 단순히 char라고만 하면 된다.\n1바이트로 표현할 수 없는 한국어 문자 세트 같은 경우는 확장문자 세트를 제공한다. wchar_t이다. 이것은 기초 데이터형과 동일한 크기와 부호 속성을 가진다. 이 문자의 스트림을 처리하기 위해 wcout, wcin이 존재하고, 문자열 앞에 L을 붙여 나타낸다. const 상수를 기호 이름으로 나타내기 위해서는 #define과 const를 사용할 수 있다. 하지만 const가 나은 이유는\u0026hellip; (1) 데이터형을 명시 가능 (2) 특정 함수나 파일에서만 사용 하게 가능 (3) 복잡한 데이터형도 가능 부동 소수점형 3.14 : 가수, 16 : 지수 유효숫자: 의미 있는 숫자 (3.14이므로 3개), 유효숫자의 개수: 정밀도 지수 허용범위 고정 소수점 표기로 결과를 출력한다. (소수점 6자리까지) 1 cout.setf(ios_base::fixed, ios_base::floatfield) 부동 소수점형 상수의 데이터형을 결정하는 방법 기본은 double형 float로 하고 싶으면 f, F를 붙이고 long double형으로 하고 싶으면 l, L을 접미어로 붙인다. 산술 연산자 %연산자의 두개의 피연산자는 모두 정수여야한다. 아니면 컴파일 에러가 발생한다. /연산자의 두개의 피연산자 중 한 개이상이 부동 소수점형이면 결과도 부동 소수점형이다. 수식에서의 데이터 형 변환 bool, char, unsigned char, signed char, short형은 int로 정수 승급된다. 서로 다른 데이터형을 혼합하면 큰 크기의 데이터형으로 변환된다 데이터형 변환자 강제로 데이터형을 변환시킨다. 1 2 (int) var; int (var); 정수 데이터형 모든 컴퓨터에서 사용하기 위해 데이터의 폭(width, 메모리의 크기)은 최소 크기만 정한다. 데이터형 크기 bool 1바이트 char 1바이트. 시스템의 기본 문자세트의 어떤 문자라도 저장할 만큼 커야 함 signed char -128~127 unsigned char 0~255 short 최소한 2바이트 unsigned short int 4바이트. 최소한 short만큼은 크다 unsigned int long 최소한 4바이트의 폭, int만큼은 크다 unsigned long long long 최소한 8바이트의 폭, long만큼은 크다 부동 소수점 데이터형 데이터형 크기 float 4바이트 double 8바이트. 최소한 float만큼은 크다 long double 16바이트. 최소한 double만큼은 크다 ","date":"2022-03-03T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-03/","title":"[C++ Primer Plus] Chapter 3. 데이터 처리"},{"content":" C++ 기초 플러스 책을 읽고 공부한 노트입니다.\nC++ C++은 다음과 같은 요소를 합쳐서 만든 것이다.\n(1) C의 절차적 프로그래밍\n알고리즘(컴퓨터가 따라가야 할 절차)을 강조함 (2) 객체 지향 프로그래밍\n데이터를 강조함(문제 특성에 맞는 데이터형을 설계힘: Class) (3) 일반화 프로그래밍\n알고리즘을 강조함(데이터형과 무관한 코드를 작성할 수 있게함: Template) 객체 지향 프로그래밍 클래스 데이터 형식과 그것이 사용되는 방법을 서술하는 것. 객체 클래스가 실제로 생성된 구체물. 실행 파일 생성 순서 (1) 전처리기가 선행처리문자(#)로 시작하는 선행처리지시문을 처리한다. (2) 컴파일러가 전처리기문이 사라진 소스코드를 어셈블리 코드로 변환한다. (3) 어셈블러가 목적 코드로 만든다. (4) 링커가 모든 오브젝트 파일들을 연결해서 실행 코드를 만든다. 컴파일러 번역 순서 (1) 어휘 분석(Lexical) 정규 문법에 따라 소스 코드를 토큰(token; 한 행에서 더 이상 분리할 수 없는 기본 요소)의 집합으로 변환한다. (2) 구문 분석 (Syntax) 소스 코드의 문법이 올바른지 분석한다. (3) 의미 분석 (Semantic) 정수와 문자열의 덧셈, 값을 0으로 나누는 행동 등과 같이 의미적으로 올바르지 않은 코드의 존재 유무를 검사한다. (4) 중간코드 생성 (5) 코드 최적화 코드를 좀 더 효율적으로 만든다. (6) 목적코드 생성 함수 함수 원형(prototype) 함수의 인터페이스만 알려주는 것 함수 정의(definition) 실제 코드 ","date":"2022-03-02T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/cpp-primer-plus-01/","title":"[C++ Primer Plus] Chapter 1, 2. 시작하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n무선 랜의 구조 무선 랜이란?\n랜 케이블을 사용하지 않고 전파를 이용해서 컴퓨터를 무선으로 연결하는 방식이다. 유선보다 속도가 불안정하고 전파가 약하면 연결이 잘 안 될 수 있다. 해킹될 위험이 높으므로 반드시 암호화나 인증 설정을 해두어야 한다. 무선 액세스 포인트(Wireless Access Point; WAP; 무선 공유기; 무선 AP)\nWAP는 무선 공유기에 내장되어 있다. 무선 클라이언트(컴퓨터, 스마트폰)\n컴퓨터가 WAP과 통신하려면 무선 랜 칩과 무선 랜 어댑터(USB 메모리 방식 or 컴퓨터 카드 방식)가 필요하다. 통신 방식 인트라스트럭처(infrastructure) 방식 WAP를 통해 통신하는 방식 일반적으로 이 방식을 사용한다. 애드혹(Ad Hoc) 방식 무선 클라이언트끼리 직접 통신하는 방식 무선 랜 규격 IEEE802.11 미국 기술 표준화 단체인 IEEE(Institute of Electrical and Electronics Engineers)에서 승인한 무선 랜의 표준화 기술이다. 다양한 규격이 존재한다. 예를 들어, 무선 공유기가 IEEE802.11ac를 지원하더라도 무선 클라이언트가 그 규격을 지원하지 않으면 사용할 수 없다. SSID의 구조 비콘(beacon)\nWAP가 주기적으로 보내는, 자기를 알리는 신호이다. 해당 네트워크에 있는 무선 클라이언트는 이 신호를 잡아서 연결한다. SSID(Service Set IDentifier)\nWAP의 고유 이름이다. 하나의 무선 랜을 다른 무선 랜으로부터 구분해 준다. 특정 무선 랜에 접속하려는 모든 AP 나 무선 장치들은 반드시 동일한 SSID 를 사용해야만 한다. 네트워크 이름, 인증, 암호화, 암호화 키를 설정해서 WAP와 무선 클라이언트가 연결한다.\nWAP를 여러대 설지하면 채널이 필요하다.\n무선 랜은 여러 기기를 동시에 연결할 수 있도록 주파수 대역을 분리하는데 이것을 채널이라고 한다. WAP는 최적의 채널을 찾아서 자동으로 설정한다. 전파가 겹치는 무선 랜이 같은 채널이면 주파수가 겹쳐서 전파 간섭이 생긴다.\n다른 채널을 사용하더라도 해당 무선 랜이 같은 주파수를 사용하면 전파 간섭이 생긴다.\n예를 들면, IEEE802.11b와 IEEE802.11g는 채널이 1ch, 2ch로 서로 달라도 같은 주파수 대역인 2.4GHz를 사용해서 간섭이 생긴다. ","date":"2022-02-26T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-09/","title":"[Network] Chapter 9. 무선 랜 이해하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n랜 카드에서의 데이터 전달과 처리 OSI 모델과 하는 일 계층 설명 물리 계층 데이터를 전기 신호로 변환한다 데이터 링크 계층 LAN에서 데이터를 송수신한다 네트워크 계층 다른 네트워크에 있는 목적지에 데이터를 전달한다 전송 계층 목적지에 데이터를 정확하게 전달한다 응용 계층 애플리케이션 등에서 사용하는 데이터를 송수신하는데 필요하다 살펴볼 네트워크의 구성 192.168.1.10 컴퓨터 → 스위치A → 라우터A 172.16.0.1 → 172.16.0.2 라우터B → 스위치B → 웹 서버 192.168.10.5 응용 계층\n3-way handshake가 완료되어 연결이 확립되었다고 가정한다. 컴퓨터에서 웹 브라우저를 이용해서 웹 서버의 웹 사이트에 접속하기 위해 요청을 보낸다. 웹 서버에 있는 html 데이터를 얻어야 하므로 GET /index.html HTTP/1.1 ~1과 같은 HTTP 메시지를 보낸다. 전송 계층\nTCP 헤더가 붙는다. 이것이 붙은 데이터를 세그먼트라고 한다. 여기에는 출발지 포트 번호와 목적지 포트 번호가 들어 있다. 출발지 포트 번호(웹 브라우저)는 잘 알려진 포트가 아닌 포트(1025번 이상) 중에서 무작위로 선택된다. 목적지 포트번호는 HTTP이므로 80번 포트가 된다. 네트워크 계층\nIP 헤더가 붙는다. 이것이 붙은 데이터를 IP 패킷이라고 한다. 여기에는 출발지 IP 주소와 목적지 IP 주소가 붙는다. 데이터 링크 계층\n이더넷 헤더가 붙는다. 이것이 붙은 데이터를 이더넷 프레임이라고 한다. 여기에는 출발지 MAC 주소와 목적지 MAC 주소가 붙는다. 물리 계층\n전기신호로 변환하여 네트워크로 전송한다. 전기신호로 변환하는 장비는 랜 카드이다. 스위치와 라우터에서의 데이터 전달과 처리 스위치 물리 계층 → 데이터 링크 계층 → 물리 계층 컴퓨터의 데이터가 전기 신호로 변환되어 전달된다. 데이터를 전기 신호로 변환하여 전송한다. 라우터 물리 계층 → 데이터 링크 계층 → 네트워크 계층 → 데이터 링크 계층 → 물리 계층 전기 신호가 전달된다. 데이터 링크 계층에서 목적지 MAC 주소와 자신의 MAC 주소를 비교한다. 주소가 같으면 이더넷 헤더와 트레일러를 분리하는 역캡슐화를 수행한다. 네트워크 계층에서 라우팅 데이블과 목적지 IP주소를 비교한다. 라우팅을 한다. 현재 출발지 IP 주소(192.168.1.10)를 라우터의 외부 IP 주소(172.16.0.1)로 변경한다. 그런 다음 데이터 링크 계층에서 라우터B로 보내기 위해서 이더넷 헤더와 트레일러를 붙인다. 물리 계층에서 데이터를 전기 신호로 변환하고 네트워크로 전달한다. (같은 과정 생략\u0026hellip;)\n웹 서버에서의 데이터 전달과 처리 물리 계층\n스위치B로부터 전기 신호로 변환된 데이터가 전달된다. 데이터 링크 계층\n목적지 MAC 주소와 자신의 MAC 주소를 비교한다. 주소가 같으면 이더넷 헤더와 트레일러를 분리하고 네트워크 계층에 전달한다. 네트워크 계층\n목적지 IP 주소와 자신의 IP 주소를 비교한다. 주소가 같으면 IP 헤더를 분리하고 전송 계층에 전달한다. 전송 계층\n목적지 포트 번호를 확인해서 어떤 애플리케이션으로 전달해야 되는지 판단하고, TCP 헤더를 분리해서 응용 계층에 전달한다. 응용 계층\n웹 서버의 응용 계층에 GET /index.html HTTP/1.1 ~1 HTTP 메시지가 전달된다. ","date":"2022-02-26T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-08/","title":"[Network] Chapter 8. 네트워크의 전체 흐름 살펴보기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n응용 계층의 역할 응용 계층은 애플리케이션과 데이터를 주고받기 위해 필요하다. 클라이언트의 요청을 서버에 전달하기 위해서 서버가 이해할 수 있는 데이터로 변환한 후 전송 계층으로 전달한다. 클라이언트 측 애플리케이션이 서버 측 애플리케이션과 서로 통신하려면 응용 계층의 프로토콜이 필요하다. 프로토콜 설명 HTTP 웹 사이트 접속 DNS 이름 해석 FTP 파일 전송 SMTP 파일 수신 POP3 메일 수신 웹 서버의 구조(웹 사이트 접속) HTML(HyperText Markup Language) 웹 페이지에서 문장 구조나 문자를 꾸미는 태그를 사용하여 작성하는 마크업 언어이다. HTML로 작성하면 웹 브라우저로 볼 수 있다. HTTP(HyperText Transfer Protocol) 클라이언트(웹 브라우저)는 웹 사이트를 보기 위해서 서버(웹 서버 프로그램)의 80번 포트를 사용해서 HTTP 통신을 한다. HTTP/1.0에서는 HTTP 요청을 보내고 HTTP 응답을 받은 후에는 연결을 끊는 작업을 반복했다. HTTP/1.1에서는 keepalive 라는 기능이 추가되서 연결을 한 번 수립하면 데이터 교확을 마칠 때까지 유지하였다. HTTP/2.0에서는 요청과 응답을 순서대로 응답하지 않아도 되어서 콘텐츠를 빠르게 표시할 수 있게되었다. DNS 서버의 구조(이름 해석) DNS(Domain Name System) 사람이 읽을 수 있는 도메인 이름을 IP 주소로 변환해준다. 이것을 이름 해석(name resolution)이라고 한다. DNS 서버는 전 세계에 흩어져 있고 모두 계층적으로 연결되어 있다. 그래서 어떤 DNS 서버가 해당 도메인의 IP 주소를 모르면 다음 DNS 서버에 요청한다. 메일 서버의 구조(SMTP와 POP3) SMTP(Simple Mail Transfer Protocol)\n이메일을 전송할 때 사용하는 프로토콜이다. 클라이언트가 작성한 메일을 서버로 전송할 때나, 서버 간 메일을 전송할 때 사용한다. POP3(Post Office Protocol 3)\n이메일을 수신할 때 사용하는 프로토콜이다. 이메일 서버에 도착한 메일을 메일 박스(메일 서버에 있는, 메일을 보관하는 곳)에서 클라이언트로 가져올 때 사용한다. 사용자 인증이 필요하다. ping(Packet INternet Groper) 명령 ICMP(Internet Control Message Protocol)라는 프로토콜을 사용해서, 목적지에 ICMP 패킷을 보내고, 패킷에 대한 응답이 제대로 오는지 확인한다. 대상 컴퓨터 동작 여부 혹은 네트워크 상태를 파악할 수 있다. 1 ping 목적지 IP 주소 혹은 목적지 도메인 이름 ","date":"2022-02-25T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-07/","title":"[Network] Chapter 7. 응용 계층 : 애플리케이션에 데이터 전송하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n전송 계층의 역할 전송 계층에서는 목적지에 신뢰할 수 있는 데이터를 전달하기위해 오류를 점검한다. 연결형 통신 신뢰할 수 있고 정확한 데이터를 전달하는 통신이다. 상대편과 확인해 가면서 통신한다. TCP(Transmission Control Protocol) 비연결형 통신 효율적으로 데이터를 전달하는 통신이다. 상대편을 확인하지 않고 일방적으로 데이터를 전송한다. 예를 들면, 동영상을 볼 때 비연결형 통신을 사용한다. UDP(User Datagram Protocol) TCP의 구조 전송 계층에서는 캡슐화할 때 TCP 헤더를 붙인다. TCP 헤더가 추가되어 만들어진 것을 세그먼트(segment) 라고 한다. 3-way handshake 데이터를 전송하려면 먼저 연결(connection) 이라는 가장의 독점 통신로를 확보해야한다. 연결을 확립하기 위해서 패킷 요청을 세 번 교환하는 것을 3-way handshake라고 한다. 연결요청 SYN과 확인응답 ACK를 사용해서 연결은 확립한다. 연결을 끊을 때 연결종류 FIN과 확인응답 ACK를 사용해서 연결을 끊는다. 일렬번호와 확인응답 번호의 구조 3-way handshake로 연결을 끝마친 후에는 일렬번호와 확인응답 번호를 사용해서 데이터를 주고받는다.\n(TCP 헤더에서) 일렬번호(sequence number)\n송신 측에서, 보내는 데이터가 몇 번째 데이터인지 알려주는 역할을 한다. (TCP 헤더에서) 확인응답 번호(acknowledgement number)\n수신 측에서, 다음으로 받고 싶은 데이터가 몇 번째 데이터인지 알려주는 역할을 한다. 재전송 제어 데이터가 항상 올바르게 전달되는 것은 아니므로, 일렬번호와 확인응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송하게 되어있다. 매번 확인응답을 기다리는 대신에 세그먼트를 연속해서 보내고 난 다음에 확인응답을 반환하면 효율이 높아지겠다. 상대방의 세그먼트가 쌓일 수 있게 하기 위한 버퍼(buffer) 가 존재한다. 이 버퍼가 넘쳐버리면 오버플로(overflow) 가 발생하므로, 3-way handshake를 할 때 서로의 버퍼 한계 크기(TCP 헤더에서 window size)를 주고 받는다. 포트 번호의 구조 전송 계층에서는 또한 전송된 데이터를 어떤 애플리케이션에 전송해야 하는지도 알려준다.\n목적지가 어떤 애플리케이션인지 구분하기 위해서는 (TCP 헤더에서) 출발지 포트 번호(source port number) 와 목적지 포트 번호(destination port number) 가 필요하다.\n0~1023번 포트 주요 프로토콜이 사용하도록 예약된 잘 알려진 포트(well-known prots)이다. 1024번 포트 예약되어 있지만 사용되지 않는 포트 1025번 이상 포트 랜덤 포트라고 해서 클라이언트 측으로 가는 송신 포트로 사용된다. 애플리케이션별 포트 번호 애플리케이션 포트 번호 SSH 22 SMTP 25 DNS 53 HTTP 80 POP3 110 HTTPS 443 UDP의 구조 TCP와 달리, UDP는 효율성을 중요하게 생각하는 비연결형 통신이라서 TCP처럼 확인작업을 일일이 하지 않는다. 또한 UDP를 사용하면 LAN에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보내는 브로드캐스트(broadcast) 를 할 수 있다. UDP 헤더가 붙은 데이터를 UDP 데이터그램이라고 한다. ","date":"2022-02-25T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-06/","title":"[Network] Chapter 6. 전송 계층 : 신뢰할 수 있는 데이터 전송하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n네트워크 계층의 역할 데이터 링크 계층에서는 이더넷 규칙을 기반으로 헤서 같은 네트워크에 있는 컴퓨터로 데이터를 전송할 수 있다면, 네트워크 계층에서는 서로 다른 네트워크에 있는 목적지로 데이터를 전송할 수 있다. 라우터(Router) 서로 다른 네트워크를 연결해주는 장치로, 데이터의 목적지가 정해지면 해당 목적지까지 어떤 경로로 가는 것이 좋은지(라우팅; routing) 를 알려주는 기능을 한다. 라우팅 테이블(routing table)이 있어서 경로 정보를 등록하고 관리한다. 가정이나 소규모 기업 용도로 만든 라우터를 인터넷 공유기라고 한다. 목적지의 주소를 아는 방법? IP(Internet Protocol) 주소 LAN에서는 MAC 주소만으로 통신할 수 있지만, 다른 네트워크에는 데이터를 보낼 수 없다. 그래서 IP가 필요하다. IP는 어떤 네트워크의 어떤 컴퓨터인지를 구분할 수 있도록 하는 주소이다. 네트워크 계층에서는 캡슐화할 때 IP 헤더를 붙인다. IP 헤더가 추가되어 만들어진 것을 IP 패킷이라고 한다. IP 주소의 구조 IP 주소는 인터넷 서비스 제공자(ISP)에게 받을 수 있다.\nIPv4는 32bit로, IPv6는 64bit로 주소를 표현한다.\nIP 주소는 공인 IP 주소와 사설 IP 주소가 있다.\nISP가 제공하는 공인 IP 주소는 라우더에만 할당하고, LAN 안의 컴퓨터들에게는 LAN의 네트워크 관리자가 자유롭게 사설 IP 주소를 할당하거나, 라우터의 DHCP(Dynamic Host Configuration Protocol)기능을 사용하여 주소를 자동으로 할당한다. 이렇게 공인 IP 주소를 절약할 수 있다. IP 주소는 네트워크 ID와 호스트 ID로 나뉘어져 있다.\n네트워크 ID는 어떤 네트워크인지를 나타내고, 호스트 ID는 해당 네트워크의 어떤 컴퓨터인지를 나타낸다. IP 주소의 클래스 구조 IP 주소의 네트워크 ID의 크기는 클래스에 따라 달라진다. 일반 네트워크에서는 A~C 클래스까지 사용할 수 있다. 클래스 이름 내용 A 클래스 대규모 네트워크 주소 B 클래스 중형 네트워크 주소 C 클래스 소규모 네트워크 주소 D 클래스 멀티캐스트(multicast) 주소 E 클래스 연구 및 특수용도 주소 각 클래스의 주소 범위 네트워크 주소와 브로드캐스트 주소의 구조 네트워크 주소와 브로드캐스트 주소는 특별한 주소로 컴퓨터나 라우터가 자신의 IP로 사용하면 안 되는 주소이다. 네트워크 주소 호스트 ID가 0인 주소이다. 네트워크 전체를 대표하는 주소이다. 브로드캐스트 주소 호스트 ID가 255인 주소이다. 네트워크에 있는 컴퓨터나 장비 모두에게 한 번에 데이터를 전송하는 데 사용되는 전용 IP 주소이다. 서브넷의 구조 서브넷팅(subneting) 대규모 네트워크를 작은 네트워크로 분할하는 것이다. 분할된 네트워크를 서브넷(subnet) 이라고 한다. 원래 호스트 ID로 사용하던 비트를 서브넷 ID로 바꾼다. 서브넷 마스크(subnet mask)\n네트워크 ID와 호스트 ID를 식별하기 위한 값이다. 프리픽스(prefix) 표기법으로 나타낼 수도 있다.\n서브넷 마스크를 /비트수로 나타낸 것이다. 클래스명 서브넷 마스크 프리픽스 표기법 A 클래스 255.0.0.0 /8 B 클래스 255.255.0.0 /16 C 클래스 255.255.255.0 /24 위와 같은 경우 서브넷 마스크는 255.255.252.0이고, 프리픽스 표기법으로 하면 /22이겠다. 라우터의 구조 라우터는 스위치, 허브와 달리 네트워크를 분리할 수 있다. 그렇다면 분리된 네트워크 끼리는 어떻게 데이터를 전송할 수 있을까? 라우터의 IP 주소인 기본 게이터웨이(default gateway) 를 설정한다. 이렇게 네트워크의 출입구를 지정하고 라우터로 일단 데이터를 전송한다. 그러면 라우터가 라우팅을 한다. 즉, 현재 네트워크에서 다른 네트워크로 가는 최적의 경로를 찾아서 데이터를 전송한다. 경로 정보는 라우팅 테이블에 저장되어 있는데, 여기에 저장된 경로를 바탕으로 라우팅을 한다. 라우터 간에 경로 정보를 교환하기 위한 프로토콜을 라우팅 프로토콜이라고 하며, 여기에는 RIP, OSPF, BGP 등이 있다. 정적 라우팅\n관리자가 미리 라우팅 테이블에 경로를 수동으로 추가하는 방법이다. 소규모 네트워크에서 사용된다. 라우팅 정보가 교환되지 않아 대역폭에 대한 부담이 적고, 보안 유지에 좋다. 하지만, 동적으로 변영되지 않으므로, 장애가 발생하면 다른 경로로 우회할 수 없어서 관리자가 설정을 하나하나 변경해야 한다. 동적 라우팅\n네트워크 변경을 자동으로 감지하여 라우팅 테이블을 업데이트하거나, 네트워크 장애가 발생했을 때 라우터끼지 정보를 교환해서 최적의 경로로 전환한다. 대규모 네트워크에서 사용된다. ","date":"2022-02-24T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-05/","title":"[Network] Chapter 5. 네트워크 계층 : 목적지에 데이터 전달하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n데이터 링크 계층의 역할과 이더넷 이더넷(Ethernet) 같은 네트워크 안에서 컴퓨터 및 기타 장치를 네트워크에 연결하기 위해 개발된 통신 표준이다. 데이터 링크 계층에서는 이더넷 규칙을 기반으로 데이터의 전송을 담당한다. 충돌(collision) 컴퓨터 여러 대가 동시에 데이터를 보내서 데이터들이 서로 부딪히는 것이다. 충돌을 방지하기 위해 이더넷은 여러 컴퓨터가 동시에 데이터를 전송하면, 시점을 늦춰서 충돌을 방지한다. 이것을 CSMA/CD 라고 한다. 하지만 이것은 지금은 효율이 좋지 않아서 사용하지 않고, 스위치(switch)를 사용한다. MAC 주소의 구조 MAC(Medium Access Control) 주소 랜 카드에 부여된 48bit의 숫자로 물리 주소라고도 부르며, 전 세계에서 유일한 번호이다. 앞쪽 24bit는 랜 카드를 만든 제조사의 번호고, 뒤쪽 24bit는 제조사가 랜 카드에 붙인 일렬번호이다. 이더넷 헤더(Ethernet Header) 의 구성(총 14 bytes) 목적지의 MAC 주소(6 bytes) 출발지의 MAC 주소(6 bytes) 유형(2 bytes) 이더넷으로 전송되는 상위 계층 프로토콜 종류를 식별하는 16진수 번호이다. 트레일러(Trailer) FCS(Frame Check Sequence)라고도 하며, 데이터 전송 도중에 오류가 발생하는지 확인하는 용도로 사용한다. 데이터 링크 계층에서는 이더넷 헤더와 트레일러을 붙여서 물리 계층으로 보내는 캡슐화가 일어난다. 이 두 가지가 추가된 데이터를 프레임이라고 한다. 그러면 물리 계층에서 이 프레임 비트열을 전기 신호로 변환해서 네트워크를 통해 전송한다. 목적지의 MAC 주소가 자신의 MAC 주소와 다르면 데이터를 파기한다. 만약에 동시에 컴퓨터 1, 2가 동일한 목적지인 컴퓨터 3으로 데이터를 전송하면 충돌을 방지하기 위해서 CSMA/CD 방식을 사용한다. 스위치의 구조 스위치(switch) 허브와 마찬가지로 여러 기기를 하나로 연결하는 장치이다. 다른 점은 원하는 목적지에만 신호를 보낸다는 것이다. 내부에 MAC 주소 테이블을 가지고 있어서, 포트 번호와 거기에 연결되어 있는 컴퓨터의 MAC 주소가 등록되어 있다. 처음에는 아무것도 등록되어 있지 않지만, 프레임이 전송되면 등록된다. (MAC 주소 학습 기능) 처음에는 아무것도 등록되어 있지 않아서, 컴퓨터 1에서 컴퓨터 3으로 데이터를 전송해도 모든 컴퓨터 1~5에 데이터가 전송된다. 이것을 플러딩(flooding) 이라고 한다. 이 후 등록되면 목적지인 컴퓨터 3에만 데이터가 전송된다. 이처럼 MAC 주소를 기준으로 목적지를 선택하는 것을 MAC 주소 필터링이라고 한다. 데이터가 케이블에서 충돌하지 않는 구조 반이중 통식 방식 데이터 송신과 수신을 번갈아가면서 통신하는 방식 동시에 데이터를 전송하면 충돌이 발생한다. 허브 전이중 통식 방식 데이터 송수신을 동시에 통신하는 방식 동시에 데이터를 전송해도 충돌이 발생하지 않는다. 스위치 충돌 도메인(collision domain) 충돌이 발생할 때 그 영향이 미치는 범위이다. 허브는 접속되어 있는 모든 컴퓨터가 충돌 도메인이 된다. 스위치는 충돌 도메인이 좁으므로 네트워크가 지연되지 않는다. ARP(Address Resolution Protocol) 네트워크 계층과 데이터 링크 계층 주소 사이의 변환을 담당하는 프로토콜이다. 목적지 컴퓨터의 IP주소를 이용해서 MAC 주소를 찾는다. 출발지 컴퓨터가 목적지 컴퓨터의 MAC 주소를 모르면, 네트워크에 브로드캐스트 하고(ARP 요청) 지정된 IP주소를 갖은 컴퓨터는 MAC 주소를 응답으로 보낸다.(ARP 응답) 출발지 컴퓨터는 얻은 MAC 주소와 IP 주소의 매핑 정보를 메모리에 보관한다. (ARP 테이블) 일정 시간이 지나면 ARP 캐시를 삭제하고 다시 ARP 요청을 한다. 이더넷의 종류와 특징 이더넷 규격 예시: 10BASE5, 10BASE-T 10은 Mbps 단위인 통신 속도이다. BASE는 BASEBAND라는 전송 방식을 나타낸다. 5는 동축케이블의 경우 케이블의 최대 길이를 나타낸 것이며, _T는 UTP 케이블의 경우 그 종류를 나타낸다. ","date":"2022-02-24T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-04/","title":"[Network] Chapter 4. 데이터 링크 계층 : LAN에서 데이터 전송하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n물리 계층의 역할과 랜 카드의 구조 물리 계층\n0과 1로 이루어진 비트열을 전기 신호로 바꾼다. 전기 신호는 아날로그 신호(전화회선이나 라디오 방송에 사용)와 디지털 신호가 있다. 랜 카드\n0과 1을 전기 신호로 바꾸는 장치를 랜 카드라고 한다. 케이블의 종류와 구조 전송 매체란? 데이터가 흐르는 물리적인 선로이다. (1) 유선 트위스트 페어 케이블 광케이블 (2) 무선 라디오파 마이크로파 적외선 트위스트 페어 케이블(twisted pair cable) 일반적으로 랜 케이블(LAN cable) 이라고 한다. 양쪽 끝에는 RJ-45라고 부르는 커넥터가 붙어 있다. (1) UTP 케이블 구리 선 여덟 개를 두 개씩 꼬아 만든 네 쌍의 전선 실드(shield; 금속 호일이나 금속 매듭 같은 것)로 보호 되어 있지 않다. 그래서 노이즈의 영향을 받기 쉽다. (2) STP 케이블 두 개씩 꼬아 만든 선을 실드로 보호한 케이블이다. 랜 케이블의 종류 모두 1번, 2번, 3번, 6번만을 사용한다. (1) 다이렉트 케이블(direct cable) 구리 선 여덟 개를 같은 순서로 커넥터에 연결한 케이블이다. 컴퓨터와 스위치를 연결할 때 사용한다. (2) 크로스 케이블(cross cable) 1번과 2번을 3번과 6번에 연결한 케이블이다. 컴퓨터 간에 직접 랜 케이블로 연결할 때 사용한다. 양쪽 컴퓨터 모두 1번, 2번을 사용하므로, 충돌이 나지 않게 교차시킨 것이다. 리피터와 허브의 구조 리피터(repeater) 전기 신호를 정형(일그러진 전기 신호를 복원)하고 증폭하는 기능을 가진 네트워크 중계 장비이다. 요즘은 사용하지 않는다. 허브(hub) 가까운 거리의 장비들을 케이블을 사용해서 연결하여 LAN을 구성하는 장치이다. 포트를 여러 개 가지고 있어서, 컴퓨터를 여러 대 연결할 수 있다. 리피터와 마찬가지로, 전기 신호를 정형하고 증폭하는 기능을 한다. 스스로 판단하지 않고, 전기 신호를 모든 포트로 보내기 때문에 더미 허브(dummy hub) 라고 불리기도 한다. 이 대책으로 나온 것이 스위치(switch)이다. ","date":"2022-02-23T03:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-03/","title":"[Network] Chapter 3. 물리 계층 : 데이터를 전기 신호로 변환하기"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\nOSI 모델과 TCP/IP 모델 프로토콜(protocol)이란? 네트워크에서 문제없이 통신하기 위해 지켜야하는 규칙이다. OSI(Open System Interconnection) 모델이란? ISO(International Organization for Standardization; 국제표준화기구)에서 제정한 것이다. 네트워크에서 데이터를 주고받기 위한 표준 규격이다. 각 계층은 독립적이라서 데이터가 전달되는 동안에 다른 계층의 영향을 받지 않는다. 데이터를 전송하는 쪽(송신 측)은 상위 계층에서 하위 계층으로 데이터를 전달하고, 데이터를 받는 쪽(수신 측)은 하위 계층에서 상위 계층으로 각 계층을 통해 전달된 데이터를 받게 된다. TCP/IP 모델이란? OSI 모델의 7계층을 4계층으로 표현한 것으로, 현재 사용되고 있는 모델이다. OSI가 이론적 표준이라면 TCP/IP는 실무적 표준이라고 할 수 있다. 캡슐화와 역캡슐화 헤더란?\n데이터를 보내려면 데이터 앞부분에 전송하는 데 필요한 정보를 붙여서 다음 계층으로 보내야 한다. 이 정보를 헤더라고 한다. 헤더에는 데이터를 전달받을 상대방에 대한 정보도 포함되어 있다. 캡슐화란?\n데이터를 보내는 쪽에서 헤더를 붙여 나가는 것을 캡슐화라고 한다. 역캡슐화란?\n데이터를 받는 쪽에서 헤더를 하나씩 제거해 나가는 것을 역캡슐화라고 한다. 캡슐화와 역캡슐화 흐름의 전체 구성 세션 계층, 표현 계층은 응용 계층에 포함되어 생각할 수 있다. 계층 데이터 송신 측 데이터 수신 측 응용 계층 데이터 데이터 전송 계층 헤더 → 데이터 헤더 ← 데이터 네트워크 계층 헤더 → 혜더-데이터 헤더 ← 혜더-데이터 데이터 링크 계층 헤더 → 헤더-헤더-데이터 ← 트레일러 헤더 ← 헤더-헤더-데이터 → 트레일러 물리 계층 전기 신호로 전송된다 도착한다 VPN(Virtual Private Network; 가상 사설망)이란? 회사 등에서 내용을 바깥 사람에게 드러내지 않고 통신할 목적으로 쓰이는 사설 통신망이다. 거점 간을 연결하여 통신하거나, 외부에서 인터넷으로 사내에 접속할 때 쓰인다. ","date":"2022-02-23T02:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-02/","title":"[Network] Chapter 2. 네트워크의 기본 규칙"},{"content":" 모두의 네트워크 책을 읽고 공부한 노트입니다.\n네트워크의 구조 네트워크란?\n컴퓨터 간 연결으로 서로 데이터(정보)를 주고 받을 수 있는 것이다. 인터넷이란?\n전 세계의 큰 네트워크부터 작은 네트워크까지를 연결하는 거대한 네트워크이다. 패킷(packet)이란?\n컴퓨터 간에 데이터를 주고받을 때, 네트워크를 통해 전송되는 데이터의 작은 조각이다. 큰 데이터를 보내면 네트워크의 대역폭을 너무 많이 차지해서 다른 패킷의 흐름을 막을 위험이 있기 때문에 작게 나눠서 보낸다. 여러 조각으로 나뉜 패킷은 순서 없이 제각각 도착한다. 그래서 원래 순서를 알기 위해 번호를 붙여서 보낸다. 정보의 양을 나타내는 단위 디지털 데이터란?\n0과 1의 집합이다. 비트(bit)가 최소 단위이며, 비트가 여덟 개 모이면 바이트(byte)이다. 문자 코드(character code)란?\n0과 1만으로 문자를 표현할 수 있도록, 숫자와 문자의 대응표를 만들어 둔 것이다. 대표적으로 ASCII 코드가 있다. 네트워크에 데이터를 전송할 때는 비트 정보를 전기 신호로 변환해서 전송된다.\nLAN과 WAN 네트워크는 접속할 수 있는 범위에 따라 크게 두 가지 종류로 나눌 수 있다.\n(1) LAN 건물 안이나 특정 지역을 범위로 하는 네트워크이다. (2) WAN 지리적으로 넓은 범위에 구축된 네트워크이다. 인터넷 서비스 제공자(ISP) 가 제공하는 서비스를 사용하여 구축된 네트워크를 말한다. 인터넷 서비스 제공자(ISP)란?\n인터넷 상용 서비스 사업을 하고 있는 KT, SKT, U+같은 사업자를 말한다. 집에서의 LAN 집에서 인터넷을 쓰려면 인터넷 서비스 제공자와 인터넷 회선을 결정해야 한다. 인터넷 서비스 제공자와 네트워크를 연결하기 위해서는 인터넷 공유기가 필요하다. 인터넷 공유기를 중심으로 내부 인터넷망을 구성하고 다양한 기기를 유선 혹은 무선으로 연결할 수 있다. 회사에서의 LAN 집과 다른 점은 DMZ(Demilitarized Zone) 라는 네트워크 영역이 있다는 것이다.\n이것은 외부에 공개하기 위한 네트워크이다. 서버를 공개하는데 주로 웹 서버, 메일 서버, DNS 서버를 공개한다. 서버를 운영하는 방법\n(1) 서버를 사내에 설치한다. → 온프레미스(on-premise) 라고 한다. (2) 데이터 센터에 서버를 둔다. → 온프레미스(on-premise) (3) 클라우드에 서버를 둔다. ","date":"2022-02-23T01:00:00+09:00","permalink":"https://pepperedpepper.github.io/p/network-01/","title":"[Network] Chapter 1. 네트워크 기초 지식"}]